<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用网站记录</title>
    <link href="/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
    <url>/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p><a href="https://onedrive.live.com/">onedrive</a><br><a href="https://www.zhihu.com/">知乎</a></p><h2 id="医学图像的网站"><a href="#医学图像的网站" class="headerlink" title="医学图像的网站"></a>医学图像的网站</h2><p><a href="https://www.cancerimagingarchive.net/">TCIA数据集</a><br><a href="http://www.via.cornell.edu/lidc/">LIDC Size Report</a><br><a href="https://wiki.cancerimagingarchive.net/display/Public/LIDC-IDRI">LIDC-IDRI</a><br><a href="https://pylidc.github.io/">Pylidc</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://leetcode-cn.com/">leetcode</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的官方网站</a></p><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图</a><br><a href="https://www.gnome-look.org/browse/cat/">Gnome-look</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/">清华大学开源镜像</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.myhuiban.com/">会伴</a><br><a href="https://www.overleaf.com/">overleaf</a><br><a href="https://sockboom.art/">sockboom</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三维CT切片方法、Python代码实现</title>
    <link href="/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.researchgate.net/publication/328774789_A_Lightweight_Multi-Section_CNN_for_Lung_Nodule_Classification_and_Malignancy_Estimation">A Lightweight Multi-Section CNN for Lung Nodule Classification and Malignancy Estimation</a><br><a href="https://github.com/PranjalSahu/MultiSectionCNN">源码</a></p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="np-meshgrid"><a href="#np-meshgrid" class="headerlink" title="np.meshgrid"></a>np.meshgrid</h3><p>numpy.meshgrid()——生成网格点坐标矩阵。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">image_size = <span class="hljs-number">5</span><br>(yy, zz) = np<span class="hljs-selector-class">.meshgrid</span>(range(image_size), range(image_size))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;yy=&#x27;</span>, yy)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;zz=&#x27;</span>, zz)</span></span><br><br>plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;x axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;y axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.plot</span>(yy, zz, marker=<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;none&#x27;</span>)<br>plt<span class="hljs-selector-class">.grid</span>()<br>plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">yy= [[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]]<br>zz= [[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br> [1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1]<br> [2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2]<br> [3<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 3 </span>3]<br> [4<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 4 </span>4]]<br></code></pre></td></tr></table></figure><h3 id="scipy-ndimage-map-coordinates"><a href="#scipy-ndimage-map-coordinates" class="headerlink" title="scipy.ndimage.map_coordinates"></a>scipy.ndimage.map_coordinates</h3><p>文档：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    # 将输入数组通过插值映射到新的坐标。<br>    Map the <span class="hljs-built_in">input</span> array <span class="hljs-keyword">to</span> <span class="hljs-keyword">new</span> coordinates by interpolation.<br>    # 坐标数组用来寻找输出里每一个点在输入中对应的坐标，这些位置输入的坐标值通过设定的阶数的插值得出。<br>    The array of coordinates <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">find</span>, <span class="hljs-keyword">for</span> each point in the output,<br>    the corresponding coordinates in the <span class="hljs-built_in">input</span>. The value of the <span class="hljs-built_in">input</span> at<br>    those coordinates <span class="hljs-keyword">is</span> determined by spline interpolation of the<br>    requested order.<br>    #<br>    The shape of the output <span class="hljs-keyword">is</span> derived from that of the coordinate<br>    array by dropping the <span class="hljs-keyword">first</span> axis. The <span class="hljs-built_in">values</span> of the array along<br>    the <span class="hljs-keyword">first</span> axis are the coordinates in the <span class="hljs-built_in">input</span> array at which the<br>    output value <span class="hljs-keyword">is</span> found.<br><br>    Parameters<br>    ----------<br>    %(<span class="hljs-built_in">input</span>)s<br>    coordinates : array_like<br>        The coordinates at which `<span class="hljs-built_in">input</span>` <span class="hljs-keyword">is</span> evaluated.<br>    %(output)s<br>    order : <span class="hljs-keyword">int</span>, optional<br>        The order of the spline interpolation, default <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>.<br>        The order <span class="hljs-built_in">has</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> in the <span class="hljs-built_in">range</span> <span class="hljs-number">0</span>-<span class="hljs-number">5</span>.<br>    %(<span class="hljs-keyword">mode</span>)s<br>    %(cval)s<br>    %(prefilter)s<br><br>    Returns<br>    -------<br>    map_coordinates : ndarray<br>        The result of transforming the <span class="hljs-built_in">input</span>. The shape of the output <span class="hljs-keyword">is</span><br>        derived from that of `coordinates` by dropping the <span class="hljs-keyword">first</span> axis.<br><br>    See Also<br>    --------<br>    spline_filter, geometric_transform, scipy.interpolate<br><br>    Examples<br>    --------<br>    &gt;&gt;&gt; from scipy import ndimage<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span> = np.arange(<span class="hljs-number">12</span>.).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span><br>    array([[  <span class="hljs-number">0</span>.,   <span class="hljs-number">1</span>.,   <span class="hljs-number">2</span>.],<br>           [  <span class="hljs-number">3</span>.,   <span class="hljs-number">4</span>.,   <span class="hljs-number">5</span>.],<br>           [  <span class="hljs-number">6</span>.,   <span class="hljs-number">7</span>.,   <span class="hljs-number">8</span>.],<br>           [  <span class="hljs-number">9</span>.,  <span class="hljs-number">10</span>.,  <span class="hljs-number">11</span>.]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, [[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>]], order=<span class="hljs-number">1</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">7</span>.])<br><br>    Above, the interpolated value of <span class="hljs-keyword">a</span>[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>] gives output[<span class="hljs-number">0</span>], <span class="hljs-keyword">while</span><br>    <span class="hljs-keyword">a</span>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> output[<span class="hljs-number">1</span>].<br><br>    &gt;&gt;&gt; inds = np.array([[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=-<span class="hljs-number">33.3</span>)<br>    array([  <span class="hljs-number">2</span>. , -<span class="hljs-number">33.3</span>])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, <span class="hljs-keyword">mode</span>=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">8</span>.])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=<span class="hljs-number">0</span>, output=bool)<br>    array([ True, False], dtype=bool)<br><br>    <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/home/joe/MyBlog/themes/fluid/source/img/meshgrid.png"> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lllxxq141592654/article/details/81532855">meshgrid</a></p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h2><p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><h3 id="树的深度优先搜索"><a href="#树的深度优先搜索" class="headerlink" title="树的深度优先搜索"></a>树的深度优先搜索</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h2 id="BFS（Breadth-First-Search）广度优先搜索"><a href="#BFS（Breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（Breadth First Search）广度优先搜索"></a>BFS（Breadth First Search）广度优先搜索</h2><p>###树的广度优先搜索</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def BFS(root):<br>    if not root:<br>        return<br>    queue = [root]<br>    while queue:<br>        <span class="hljs-literal">current</span> = queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h3><p>（leetcode 111题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = [root]<br>        minDep = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                    <span class="hljs-keyword">return</span> minDep<br>                <span class="hljs-keyword">if</span> node.left:<br>                    level.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    level.append(node.right)<br>            queue = level<br>            minDep += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>分治：最优子结构<br>动规：最优子结构、重叠子问题<br>贪心：最优子结构、重叠子问题、贪心选择性质</p><p>分治：为了解决一个问题，把它分解成若干个与此问题相似的子问题。<br>这样的“能分解”的性质就叫做最优子结构（又称无后效性）。很多问题都可以满足这个性质。</p><p>动态规划：动态规划是分治的特例。采用分治思想得到的子问题“不一定需要再次求解”，因为之前可能已经计算过相同的子问题了。这样的性质叫做重叠子问题。</p><p>贪心：贪心比动态规划更特殊，它还需要问题满足另一个性质——贪心选择性质。每次都可以把原问题分解为一个子问题。<br>动态规划是一种特殊的分治，而贪心是一种特殊的动态规划。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>递归形式：改分治。先进行判断。如果这个子问题已经处理过，那就直接把数组里储存了的值输出；否则就“计算结果”，最后储存答案。<br>递推形式：找出一种可行的拓扑序列。<br>两者在时间复杂度上没什么区别，而递归形式代码一般比较容易实现。具体区别请见：为什么线性动态规划类问题通常使用递推求解子问题，而不使用记忆化递归。<br>事实上动态规划最关键的是上文提到的“计算结果”，即列一个数学方程，这个方程被称为状态转移方程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>**第一步骤：定义数组元素的含义<br>第二步骤：找出数组元素之间的关系式<br>第三步骤：找出初始值<br>**</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>（leetcode70题）经典爬楼梯：<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n  <span class="hljs-comment"># 定义数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 定义初始状态</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]  <span class="hljs-comment"># 状态转移</span><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>（leetcode746题）最小代价爬楼梯：<br>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。<br>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。<br>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        prev = <span class="hljs-number">0</span> <br>        cur = <span class="hljs-number">0</span>   <span class="hljs-comment"># 把dp[i]设为第i阶为天台</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(cost)+<span class="hljs-number">1</span>):<br>            prev, cur = cur, <span class="hljs-built_in">min</span>(prev+cost[i-<span class="hljs-number">2</span>], cur+cost[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="子串、子序列、子数组"><a href="#子串、子序列、子数组" class="headerlink" title="子串、子序列、子数组"></a>子串、子序列、子数组</h3><p>最大子段和（leetcode53题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>最长公共子序列（leetcode1143题）：<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1, text2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type text1: str</span><br><span class="hljs-string">        :type text2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意顺序</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>最长重复子数组（leetcode718题）：<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLength</span>(<span class="hljs-params">self, nums1, nums2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)]<br>        maxr = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                    maxr = <span class="hljs-built_in">max</span>(maxr, dp[i][j])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> maxr<br></code></pre></td></tr></table></figure><h3 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h3><p>（leetcode264题）<br>给你一个整数 n ，请你找出并返回第 n 个 丑数 。<br>丑数 就是只包含质因数 2、3 和/或 5 的正整数。<br>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def nthUglyNumber(self, n):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> n: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        p2 = p3 =p5 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">min</span>(<span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>, <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>, <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>:<br>                p2 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>:<br>                p3 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>:<br>                p5 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">dp</span>[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><p>I. (leetcode198题)<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>II. (leetcode 213题)<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">robRange</span>(<span class="hljs-params">nums</span>):</span><br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(robRange(nums[:-<span class="hljs-number">1</span>]), robRange(nums[<span class="hljs-number">1</span>:]))  <span class="hljs-comment"># 先分解为两个单排问题</span><br><br></code></pre></td></tr></table></figure><p>III. </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/topic/19660018/hot">动态规划概念</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念和算法</title>
    <link href="/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/tree.jpg" alt=" " title="二叉树"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>满二叉树</strong>：顾名思义<br><strong>完全二叉树</strong>：满二叉树从最后一个结点开始删除</p><p><strong>二叉搜索树</strong>（二叉查找树）：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大，递归定义。<br>    二叉搜索树中序遍历从小到大排序<br>正常情况下时间复杂度： O(logn)<br>最差：O(n)<br>避免最差情况：使用<strong>平衡二叉树</strong>（AVL）</p><p><strong>平衡二叉树</strong>：平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。<strong>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)</strong><br><strong>平衡因子</strong>：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。（左减右）<br><strong>最小失衡子树</strong>：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。<br>平衡二叉树的失衡调整主要是通过<strong>旋转</strong>最小失衡子树来实现的。根据旋转的方向有两种处理方式，**左旋 **与 <strong>右旋</strong> 。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><p>节点的<strong>度</strong>就是这个节点的孩子数量，例如有左右孩子的节点，它的度为2，如果只有左孩子或者只有右孩子的节点，它的度就是1，叶节点就是度为0的节点</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = x<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>树的建立：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">if</span> <span class="hljs-type">__name</span><span class="hljs-type">__</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;__main__&quot;</span><span class="hljs-operator">:</span><br>    <span class="hljs-built_in">D</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">D</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">E</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">E</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">F</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">F</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">C</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">C</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">None</span><span class="hljs-operator">,</span> <span class="hljs-variable">F</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">B</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">A</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">A</span><br></code></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root</span>):</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable">root</span>:</span><br><span class="hljs-function">        <span class="hljs-variable">return</span></span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">root.val</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.left</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.right</span>)</span><br></code></pre></td></tr></table></figure><p>深度优先：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><p>广度优先（leetcode101题）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim"># Definition <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> binary tree node.<br># class TreeNode(object):<br>#     def __init__(self, val=<span class="hljs-number">0</span>, <span class="hljs-keyword">left</span>=None, <span class="hljs-keyword">right</span>=None):<br>#         self.val = val<br>#         self.<span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span><br>#         self.<span class="hljs-keyword">right</span> = <span class="hljs-keyword">right</span><br>class Solution(object):<br>    def levelOrder(self, root):<br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">if</span> not roo<span class="hljs-variable">t:</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                level.<span class="hljs-keyword">append</span>(queue[<span class="hljs-number">0</span>].val)<br>                current = queue.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> current.lef<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">left</span>)<br>                <span class="hljs-keyword">if</span> current.righ<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">right</span>)<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(level)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>数组中第K个最大元素（leecode215题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_heap</span>(<span class="hljs-params">i, nums, length</span>):</span>  <span class="hljs-comment"># 构建最大堆</span><br>            left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子树</span><br>            right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子树</span><br>            max_index = i  <span class="hljs-comment"># 最大结点下标</span><br>            <span class="hljs-keyword">if</span> left &lt; length <span class="hljs-keyword">and</span> nums[i] &lt; nums[left]:<br>                max_index = left<br>            <span class="hljs-keyword">if</span> right &lt; length <span class="hljs-keyword">and</span> nums[max_index] &lt; nums[right]:<br>                max_index = right<br>            <span class="hljs-keyword">if</span> max_index != i:<br>                nums[i], nums[max_index] = nums[max_index], nums[i]<br>                build_heap(max_index, nums, length)  <span class="hljs-comment"># 如果经过了调换，对调换的子结点继续构建堆</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            build_heap(i, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            nums[<span class="hljs-number">0</span>], nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>] = nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]<br>            result = nums.pop()<br>            build_heap(<span class="hljs-number">0</span>, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://zhuanlan.zhihu.com/p/106828968">基本概念</a><br><a href="https://zhuanlan.zhihu.com/p/56066942">平衡二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">bubble_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 外层冒泡轮数</span><br>        for <span class="hljs-keyword">j </span>in range(length<span class="hljs-number">-1</span>-i):  <span class="hljs-comment"># 里层依次比较，最大（最小）沉底</span><br>            if arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j+1]:</span><br><span class="hljs-keyword"> </span>               arr[<span class="hljs-keyword">j], </span>arr[<span class="hljs-keyword">j+1] </span>= arr[<span class="hljs-keyword">j+1], </span>arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>   return arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):  <span class="hljs-comment"># 循环轮数</span><br>        <span class="hljs-built_in">min</span> = arr[i]<br>        mini = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, length):<br>            <span class="hljs-keyword">if</span> arr[j] &lt; <span class="hljs-built_in">min</span>:<br>                <span class="hljs-built_in">min</span> = arr[j]<br>                mini = j<br>        arr[i], arr[mini] = arr[mini], arr[i]  <span class="hljs-comment"># 将最小的数和第i个数交换</span><br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insertion_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 循环轮数</span><br>        value = arr[i]<br>        <span class="hljs-keyword">j </span>= i<br>        while <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span>:<br>            if value &lt; arr[<span class="hljs-keyword">j-1]: </span> <span class="hljs-comment">#每次将第i个数插入有序数组中正确位置</span><br>                arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j-1]</span><br><span class="hljs-keyword"> </span>               <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br><span class="hljs-symbol">            else:</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword"> </span>       arr[<span class="hljs-keyword">j] </span>= value<br>    return arr<br></code></pre></td></tr></table></figure><p>插入排序实现方法类比扑克牌摸牌。<br>时间复杂度为<strong>O(n2)。</strong></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shells_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    gap = <span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">while</span> gap &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, length):  <span class="hljs-comment"># 从第二个数开始选择插入</span><br>            value = arr[i]<br>            j = i<br>            <span class="hljs-keyword">while</span> j - gap &gt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 前面还有数</span><br>                <span class="hljs-keyword">if</span> value &lt; arr[j-gap]:<br>                    arr[j] = arr[j-gap]  <span class="hljs-comment"># 当前数更小，则前移</span><br>                    j -= gap<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 否则为正确位置，插入</span><br>            arr[j] = value<br>        <span class="hljs-keyword">if</span> gap == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        gap = <span class="hljs-built_in">int</span>(gap/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>希尔排序也称作“缩小增量排序”，<strong>是插入排序的一种更高效的改进版本。</strong><br>根据增量进行跳跃的插入排序，然后缩小增量，最后进行增量为1的插入排序。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>python实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> merge(arr<span class="hljs-number">1</span>, arr<span class="hljs-number">2</span>):  # 治<br>    <span class="hljs-attribute">arr</span> =<span class="hljs-meta"> []</span><br>    <span class="hljs-attribute">node1</span>, node<span class="hljs-number">2</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> node<span class="hljs-number">1</span> &lt; len(arr<span class="hljs-number">1</span>) and node<span class="hljs-number">2</span> &lt; len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>] &lt; arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>]:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>])<br>            <span class="hljs-attribute">node1</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>])<br>            <span class="hljs-attribute">node2</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">1</span> == len(arr<span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>:])<br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">2</span> == len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>:])<br>    <span class="hljs-attribute">return</span> arr<br><br><br><span class="hljs-attribute">def</span> merge_sort(arr):  # 分<br>    <span class="hljs-attribute">length</span> = len(arr)<br>    <span class="hljs-attribute">if</span> length == <span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> arr<br><br>    <span class="hljs-attribute">left</span> = merge_sort(arr[:int(length/<span class="hljs-number">2</span>)])<br>    <span class="hljs-attribute">right</span> = merge_sort(arr[int(length/<span class="hljs-number">2</span>):])<br>    <span class="hljs-attribute">return</span> merge(left, right)<br></code></pre></td></tr></table></figure><p>分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>python实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">def quick_sort(arr):<br>    length <span class="hljs-operator">=</span> len(arr)<br>    if length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>]  # 取基准元素<br>    <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  # 左指针<br>    <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> length<span class="hljs-number">-1</span>  # 右指针<br>    ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span>  # 左右指针交替移动，先从右指针移动<br>    while <span class="hljs-keyword">left</span> <span class="hljs-operator">!=</span> <span class="hljs-keyword">right</span>:<br>        if ifright:<br>            if arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">right</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            if arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">left</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> quick_sort(arr[:<span class="hljs-keyword">left</span>])<span class="hljs-operator">+</span>[<span class="hljs-keyword">value</span>]<span class="hljs-operator">+</span>quick_sort(arr[(<span class="hljs-keyword">left</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>):])<br></code></pre></td></tr></table></figure><p>快速排序的思想：<br>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）<br>2.将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置<br>3.对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>):<br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左叶子</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右叶子</span><br>    max_index = i  <span class="hljs-comment"># 最大元素下标</span><br>    <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[left] &gt;= nums[i]:<br>        max_index = left<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-literal">right</span>] &gt; nums[max_index]:<br>        max_index = <span class="hljs-literal">right</span><br>    <span class="hljs-keyword">if</span> max_index != i:  <span class="hljs-comment"># 如果需要交换，先进行交换，然后对交换后的叶子构建堆</span><br>        nums[i], nums[max_index] = nums[max_index], nums[i]<br>        bulid_big_heap(nums, max_index, <span class="hljs-built_in">length</span>)<br><br>def heap_sort(nums):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(nums)<br>    sorted = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span><span class="hljs-comment"> // 2 - 1, -1, -1):  # 从最后一个非叶子结点开始构建堆</span><br>        bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):  <span class="hljs-comment"># 输出堆顶元素</span><br>        nums[<span class="hljs-number">0</span>], nums[j] = nums[j], nums[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 与最后一个元素交换</span><br>        sorted.insert(<span class="hljs-number">0</span>, nums.pop())  <span class="hljs-comment"># 输出</span><br>        bulid_big_heap(nums, <span class="hljs-number">0</span>, j)  <span class="hljs-comment"># 从堆顶开始重新构建堆</span><br>    <span class="hljs-literal">return</span> sorted<br></code></pre></td></tr></table></figure><p>堆排序的过程梳理：</p><ol><li>把数组构建成完全二叉树</li><li>从最后一个非叶子结点开始构建堆</li><li>输出堆顶元素，重建构建成堆</li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def count_sort(arr):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(arr)<br>    max_num = arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>):<br>        max_num = <span class="hljs-built_in">max</span>(max_num, arr[i])<br>    count_arr = [<span class="hljs-number">0</span>] * (max_num+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>):<br>        count_arr[arr[i]] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">result</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">while</span> count_arr[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">result</span>.append(i)<br>            count_arr[i] -= <span class="hljs-number">1</span><br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p>计数排序思路：找出最大值; 计数; 取出<br>适合取值范围相差不大的数组</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect">十大排序算法</a><br><a href="https://zhuanlan.zhihu.com/p/63202860">快速排序</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。<br>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</p><p>严谨的进行算法的时间复杂度：「 大O符号表示法 」，即 T(n) = O(f(n))。<br>其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。<br><strong>一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。</strong></p><p>O(1): 无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)<br>O(n): for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。<br>O(n²) : 当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>O(logn): 在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。<br>O(nlogn): 将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p><h2 id="基本算法思想"><a href="#基本算法思想" class="headerlink" title="基本算法思想"></a>基本算法思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</strong><br>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。<br>1.找到如何将大问题分解为小问题的规律<br>2.通过规律写出递推公式<br>3.通过递归公式的临界点推敲出终止条件<br>4.将递推公式和终止条件翻译成代码</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。<br>步骤：<br>定义数组元素的含义;<br>找出数组元素之间的关系式;<br>找出初始值。</p><h3 id="动态规划和递归的区别"><a href="#动态规划和递归的区别" class="headerlink" title="动态规划和递归的区别"></a>动态规划和递归的区别</h3><p>用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。<br>1.动态规划法试图只解决每个子问题一次<br>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。<br>爬台阶（递归）自顶向下:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>爬台阶（动态规划）自底向上：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>int f(<span class="hljs-type">int</span> n) &#123;<br> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> <span class="hljs-number">3</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br> <span class="hljs-number">4</span>    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， <span class="hljs-keyword">temp</span> 保存当前状态的数据<br> <span class="hljs-number">5</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br> <span class="hljs-number">6</span>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">7</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br> <span class="hljs-number">8</span>        <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">9</span>        a = b;<br><span class="hljs-number">10</span>        b = <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">11</span>    &#125;<br><span class="hljs-number">12</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">13</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法，根据字面意思解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/23148377/answer/907915556">程序员必须掌握哪些算法</a><br><a href="https://www.cxyxiaowu.com/852.html">贪心算法</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485228&idx=1&sn=9f48aee51dcb2b98b56b1827cc658439&chksm=fa0e68adcd79e1bbcd0183ef30a79ede4e46c5835ce05ee6644169c3cc9454073019ccd85d3d&scene=21#wechat_redirect">分治算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动调参工具optuna</title>
    <link href="/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/"/>
    <url>/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/optuna/optuna">optuna</a>是一个为机器学习设计的自动超参数优化软件框架。它有一个命令式的、按运行方式定义的用户API，用Optuna编写的代码具有很高的模块化，Optuna的用户可以动态地为超参数构建搜索空间。</p><h2 id="optuna基本概念"><a href="#optuna基本概念" class="headerlink" title="optuna基本概念"></a>optuna基本概念</h2><p>study：根据目标函数的优化Session,由一系列的trial组成。<br>trial：根据目标函数作出一次执行。<br><strong>study的学习目标就是根据多次trial得到的结果发现其中最优的超参数。</strong></p><h2 id="optuna常用搜索方式"><a href="#optuna常用搜索方式" class="headerlink" title="optuna常用搜索方式"></a>optuna常用搜索方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 选择型搜索方式【从MomentumSGD和Adam二者中选】</span><br>trail.suggest_categorical(<span class="hljs-string">&#x27;optimizer&#x27;</span>,[<span class="hljs-string">&#x27;MomentumSGD&#x27;</span>,<span class="hljs-string">&#x27;Adam&#x27;</span>])<br><span class="hljs-comment"># 整型搜索方式【从1～3范围内的int选择】</span><br>trail.suggest_int(<span class="hljs-string">&#x27;num_layers&#x27;</span>,1,3)<br><span class="hljs-comment"># 浮点型搜索方式【从0.0～1.0范围内float选择】</span><br>trial.suggest_float(<span class="hljs-string">&#x27;momentum&#x27;</span>, 0.0, 1.0)<br><span class="hljs-comment"># 连续均匀采样搜索方式 【从0～1.0之间的浮点数进行均匀采样】</span><br>trail.suggest_uniform(<span class="hljs-string">&#x27;dropout_rate&#x27;</span>,0.0,1.0)<br><span class="hljs-comment"># 对数均匀采样方式 【从log(1e-5)~log(1e-2)均匀分布中采样结果再取e的自然指数】</span><br>trail.suggest_loguniform(<span class="hljs-string">&#x27;learning_rate,1e-5,1e-2&#x27;</span>)<br><span class="hljs-comment"># 离散均匀采样方式 【以0.1为步长拆分0～1后的离散均匀分布中采样】</span><br>**trail.suggest_discrete_uniform(<span class="hljs-string">&#x27;drop_path_rate&#x27;</span>,0.0,1.0,0.1)<br></code></pre></td></tr></table></figure><p>具体可以查看一下<a href="https://github.com/optuna/optuna/blob/master/optuna/trial/_trial.py">文档</a></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先导入包，重设随机种子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import optuna<br><span class="hljs-function"><span class="hljs-title">reset_rand</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>定义目标函数，返回需要最大化（最小化）的目标</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def objective(trial):<br>    def model_opt():<br>        lr = trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;lr&#x27;</span>, 1e-3, 1e-2, 1e-3)<br>        model = network()<br>        optimizer = Adam(model.parameters(), lr)<br>        return model, optimizer<br><br>    acc = kFoldTraining(wd,<br>                        int(trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;batch_size&#x27;</span>, 32, 256, 32)),<br>                        epoch,<br>                        <span class="hljs-attribute">model_optimizer</span>=model_opt,<br>                        <span class="hljs-attribute">loss</span>=nn.CrossEntropyLoss(),<br>                        <span class="hljs-attribute">device</span>=<span class="hljs-string">&#x27;cuda:0&#x27;</span>,<br>                        <span class="hljs-attribute">deterministic</span>=<span class="hljs-literal">True</span>,<br>                        <span class="hljs-attribute">parallel</span>=<span class="hljs-literal">False</span><br>                        )<br>    return acc<br></code></pre></td></tr></table></figure><p>最后在主函数中调用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>study = optuna.create_study(<span class="hljs-attribute">direction</span>=<span class="hljs-string">&quot;maximize&quot;</span>, <span class="hljs-attribute">pruner</span>=optuna.pruners.HyperbandPruner())<br>study.optimize(objective, <span class="hljs-attribute">n_trials</span>=50)  # 调参的次数 <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Number of finished trials: &quot;</span>, len(study.trials))<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Best trial:&quot;</span>)<br>trial = study.best_trial<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Value: &quot;</span>, trial.value)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Params: &quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.params.items():<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.format(key, value))<br>df = study.trials_dataframe(attrs=(<span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;params&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>))<br>df.to_csv(keys[<span class="hljs-string">&#x27;result&#x27;</span>] + <span class="hljs-string">&#x27;/dataframe.csv&#x27;</span>, <span class="hljs-attribute">index</span>=<span class="hljs-literal">False</span>)<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/384519338/answer/1206812752">有没有什么可以节省大量时间的 Deep Learning 效率神器？</a><br><a href="https://zhuanlan.zhihu.com/p/259993570">Optuna — 超参自动化调整利器 学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建过程记录</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录简单的个人博客搭建过程。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install git-core<br></code></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh<br></code></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvm install stable<br></code></pre></td></tr></table></figure><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>建立博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p>文件夹名称可以自己随意取，这三句命令的作用是初始化 Hexo </p><p>再次输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>作用是生成静态文件，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>作用是启动服务器。这时候就可以用浏览器打开网址： <a href="http://localhost:4000/">http://localhost:4000/</a> 来进行预览了。</p><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p>注册帐号，创建repo等操作就省略了，具体可参考其他博客（比如参考里面的）</p><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>如果已有public-key可以先删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add -D<br>$ rm -r ~/.ssh<br></code></pre></td></tr></table></figure><p>生成一个github用的SSH-Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@your.com” -f ~/.ssh/github-rsa</span><br></code></pre></td></tr></table></figure><p>添加私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa<br><span class="hljs-comment"># 可以通过 ssh-add -l 来确私钥列表</span><br>$ ssh-add -l<br><span class="hljs-comment"># 可以通过 ssh-add -D 来清空私钥列表</span><br>$ ssh-add -D<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 ~/.ssh 目录下新建一个config文件</span><br>$ touch config<br></code></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github</span><br>Host github.com<br>    HostName github.com<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/github_rsa<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>输出You’ve successfully authenticated, but GitHub does not provide shell access.就表示成功的连上github了</p><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br><span class="hljs-comment"># 本地预览</span><br>$ hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure><p>如果hexo d之后出现 ERROR Deployer not found: git，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>即可</p><p>上传时报错：incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line at….<br>要把标题里英文冒号改为中文的</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8">hexo fluid配置地址</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/hzq_0111/article/details/78956821">在github上搭建hexo个人博客</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://my.oschina.net/stefanzhlg/blog/529403">git配置多个ssh-key</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04 + Pycharm 配置Pyqt5</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/</url>
    
    <content type="html"><![CDATA[<p>安装指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install qt5-default<br>sudo apt-get install qttools5-dev-tools<br>pip install pyqt5 -i https://pypi.douban.com/simple <span class="hljs-comment">#安装pyqt5包</span><br>sudo apt install pyqt5* <span class="hljs-comment">#安装依赖</span><br></code></pre></td></tr></table></figure><p>在Pycharm中进行配置：<br>打开pycharm后点击File - &gt; setting - &gt; Tools - &gt; External Tools, 点击 + 号添加两个文件。<br>（1）第一个是QtDesign用于通过pycharm直接启动QtDesigner，自定义Name（QtDesigner）, Group（Qt5）等参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/designer  <span class="hljs-comment"># 填入Program</span><br><span class="hljs-variable">$FileDir</span>$  <span class="hljs-comment"># 填入Working directory</span><br></code></pre></td></tr></table></figure><p>（2）第二个是将ui文件转换成py文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/usr/bin/python3  <span class="hljs-comment"># 填入Program</span><br>-m PyQt5.uic.pyuic  <span class="hljs-variable">$FileName</span><span class="hljs-variable">$ </span>-o <span class="hljs-variable">$FileNameWithoutExtension</span><span class="hljs-variable">$.</span>py  <span class="hljs-comment"># 填入Arguments</span><br><span class="hljs-variable">$FileDir</span><span class="hljs-variable">$ </span> <span class="hljs-comment"># 填入Working direction</span><br></code></pre></td></tr></table></figure><p>将ui文件转换为py文件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pyuic5 -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>py <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>ui<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/qq_37541097/article/details/80021315">Ubuntu16.04+pycharm+pyqt5安装与配置</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
