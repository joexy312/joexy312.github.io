<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>每周代码(8.21-8.27)</title>
    <link href="/2021/08/24/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-21-8-27/"/>
    <url>/2021/08/24/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-21-8-27/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">leetcode_232_用栈实现队列</a><br>思路：</p><ul><li>最基本的思路就是用两个栈一个模拟后进先出（栈stack）一个模拟先进先出（队列queue）。</li><li>在push的时候，首先将stack中的栈顶元素依次弹出放入queue，此时queue就是队列的顺序，执行完push再反方向传回stack即可。</li><li>其他操作就可以用栈的标准操作完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Initialize your data structure here.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.stack = []<br>        self.queue = []<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Push element x to the back of queue.</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> self.stack:<br>            self.queue.append(self.stack.pop())<br>        self.queue.append(x)<br>        <span class="hljs-keyword">while</span> self.queue:<br>            self.stack.append(self.queue.pop())<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Removes the element from in front of queue and returns that element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.stack.pop()<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Get the front element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns whether the queue is empty.</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/232.png" alt="232"></p><p><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">leetcode_341_扁平化嵌套列表迭代器</a><br>思路：</p><ul><li>基本思路可以用深度优先搜索实现;遍历输入中的一级元素，如果是整数直接插入，如果是列表继续调用dfs</li><li>输入数据结构可以用collections中的双端队列deque实现，可以两端处理，比较方便</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span>(<span class="hljs-title">object</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, nests)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">for</span> nest <span class="hljs-keyword">in</span> <span class="hljs-symbol">nests:</span><br>            <span class="hljs-keyword">if</span> nest.isInteger()<span class="hljs-symbol">:</span><br>                <span class="hljs-keyword">self</span>.queue.append(nest.getInteger())<br>            <span class="hljs-symbol">else:</span><br>                <span class="hljs-keyword">self</span>.dfs(nest.getList())<br>                    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, nestedList)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.queue = collections.deque()<br>        <span class="hljs-keyword">self</span>.dfs(nestedList)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.queue.popleft()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasNext</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">return</span> len(<span class="hljs-keyword">self</span>.queue)<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/341.png" alt="341"></p><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">leetcode_387_字符串中的第一个唯一字符</a><br>思路：</p><ul><li>用了两种思路实现。</li><li>第一种直接用counter进行出现次数统计，然后依次便利字符串，第一个次数唯一的就是结果。</li><li>第二种思路是用一个set保存重复的字符。依次遍历，如果字符在set中就continue;对每一个字符，查找他之后的字符，如果没有重复，说明只出现一次，输出结果，如果有重复就放入set中;这种方法速度更快;</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">wrong = set()<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> range(len(s)):<br>    <span class="hljs-keyword">if</span> s<span class="hljs-selector-attr">[i]</span> not <span class="hljs-keyword">in</span> wrong:<br>        <span class="hljs-keyword">if</span> s<span class="hljs-selector-attr">[i]</span> not <span class="hljs-keyword">in</span> s<span class="hljs-selector-attr">[i+1:]</span>:<br>            return i<br>        <span class="hljs-keyword">else</span>:<br>            wrong<span class="hljs-selector-class">.add</span>(s<span class="hljs-selector-attr">[i]</span>)<br>return -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/387.png" alt="387"></p><p><a href="https://leetcode-cn.com/problems/dota2-senate/">leetcode_649_Dota2 参议院</a><br>思路：</p><ul><li>这道题主要的难点就是对问题的建模过程，首先禁止的时候，应该禁止和自己后面最近的一个对立阵营的，这样就可以最大程度上阻止对面阵营禁止自己阵营的</li><li>另一点是可以把字符串考虑为循环队列，因此禁止对方的位置虽然也要pop，但是可以在下一个循环继续使用</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Radiant, Dire = <span class="hljs-selector-attr">[]</span>, <span class="hljs-selector-attr">[]</span><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, ch <span class="hljs-keyword">in</span> enumerate(senate):<br>    <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;R&#x27;</span>:<br>        Radiant<span class="hljs-selector-class">.append</span>(i)<br>    <span class="hljs-keyword">else</span>:<br>        Dire<span class="hljs-selector-class">.append</span>(i)<br><br>while Radiant and Dire:<br>    <span class="hljs-keyword">if</span> Radiant<span class="hljs-selector-attr">[0]</span> &lt; Dire<span class="hljs-selector-attr">[0]</span>:<br>        Radiant<span class="hljs-selector-class">.append</span>(Radiant<span class="hljs-selector-attr">[0]</span>+len(senate))<br>    <span class="hljs-keyword">else</span>:<br>        Dire<span class="hljs-selector-class">.append</span>(Dire<span class="hljs-selector-attr">[0]</span>+len(senate))<br>    Radiant<span class="hljs-selector-class">.pop</span>(<span class="hljs-number">0</span>)<br>    Dire<span class="hljs-selector-class">.pop</span>(<span class="hljs-number">0</span>)<br>return <span class="hljs-string">&quot;Radiant&quot;</span> <span class="hljs-keyword">if</span> Radiant <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Dire&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/649.png" alt="649"></p><p><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">leetcode_1480_一维数组的动态和</a><br>思路：</p><ul><li>题目比较简单，注意一下边界条件即可。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> range(len(nums)):<br>    nums<span class="hljs-selector-attr">[i]</span> = nums<span class="hljs-selector-attr">[i]</span>+nums<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> != <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> nums<span class="hljs-selector-attr">[i]</span><br>return nums<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/1480.png" alt="1480"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(8.14-8.20)</title>
    <link href="/2021/08/20/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-14-8-20/"/>
    <url>/2021/08/20/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-14-8-20/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业。<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">leetcode_21_合并两个有序链表</a><br>思路：</p><ul><li>可以用递归或者迭代的思路实现，这里用迭代实现。</li><li>实现代码比较简单，与直接操作数字相比只是多了一个链表实现</li><li>l1和l2都不为空的时候，依次向新的链表插入较小的node</li><li>最后有一个为空之后，把另一的当前链表头插到最后面就可以了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1, l2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type l1: ListNode</span><br><span class="hljs-string">        :type l2: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = ListNode()<br>        current = res<br><br>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>            <span class="hljs-keyword">if</span> l1.val &lt; l2.val:<br>                current.<span class="hljs-built_in">next</span> = l1<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                current.<span class="hljs-built_in">next</span> = l2<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">while</span> l1:<br>            current.<span class="hljs-built_in">next</span> = l1<br>            l1 = l1.<span class="hljs-built_in">next</span><br>            current = current.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> l2:<br>            current.<span class="hljs-built_in">next</span> = l2<br>            l2 = l2.<span class="hljs-built_in">next</span><br>            current = current.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/21.png" alt="21"></p><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">leetcode_24_两两交换链表中的节点</a><br>思路：</p><ul><li>主要是繁琐的链表操作;以1,2,3,4中3,4节点的交换为例</li><li>首先保存4之后的节点;</li><li>将4接到2之后;</li><li>将5接到3之后;</li><li>将3接到4之后;</li><li>保存最后一个节点，也就是3,用于下一次交换使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head:<br>            <span class="hljs-keyword">return</span><br>        res = head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">else</span> head<br>        current = head<br>        past = ListNode()<br><br>        <span class="hljs-keyword">while</span> current:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> current.<span class="hljs-built_in">next</span>:<br>                <span class="hljs-keyword">return</span> res<br><br>            tmp = current.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span> = tmp.<span class="hljs-built_in">next</span><br>            tmp.<span class="hljs-built_in">next</span> = current<br>            past.<span class="hljs-built_in">next</span> = tmp<br>            past = current<br>            current = current.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/24.png" alt="24"></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">leetcode_206_反转链表</a><br>思路：</p><ul><li>同样可以用迭代和递归实现，这里用迭代实现</li><li>当下一个节点存在时，保存下下个节点备用（没有就为空）</li><li>头节点接到下一个节点之后</li><li>最后一个节点接下一个节点</li><li>下下个节点变成下个节点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.<span class="hljs-built_in">next</span>:<br>            <span class="hljs-keyword">return</span> head<br>        current = head<br>        prev = current<br>        <span class="hljs-keyword">while</span> current.<span class="hljs-built_in">next</span>:<br>            nextnode = current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = prev<br>            prev = current.<span class="hljs-built_in">next</span><br>            current.<span class="hljs-built_in">next</span> = nextnode<br>        <span class="hljs-keyword">return</span> prev<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/206.png" alt="206"></p><p><a href="https://leetcode-cn.com/problems/power-of-two/">leetcode_231_2 的幂</a><br>思路：</p><ul><li>思路1：一直除以2,变成1之前如果有余数就返回False，否则返回True</li><li>思路2：在题目给定的32位有符号整数的范围内，最大的2的幂为 $2^{30} = 1073741824$，我们只需要判断$n$是否是 $2^{30}$的约数即可。</li><li>思路3：二进制表示：一个数n是2的幂，当且仅当n是正整数，并且的二进制表示中仅包含1个1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfTwo</span>(<span class="hljs-params">self, n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type n: int</span><br><span class="hljs-string">    :rtype: bool</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> n &gt;= <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        n = n / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> n==<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/231.png" alt="231"></p><p><a href="https://leetcode-cn.com/problems/number-of-digit-one/">leetcode_233_数字 1 的个数</a><br>思路：</p><p>数字1的个数等于每个数位上1的个数之和，如$n=1234$,答案为：</p><ul><li>个位上1的数量</li><li>十位上1的数量 </li><li>百位上1的数量</li><li>千位上1的数量<br>四个部分求和。</li></ul><p>以百位为例，对每1000个数，百位上1的数量为100，即100～199。即令数位为$k$（个位$k=0$），完整的循环会有$10^k$个1。<br>剩下不完整的循环应用$n mod 10^{k+1}$表示。如对个位而言，剩下数字为4;对百位而言，剩下数位为234。<br>对剩下的数字（记为$n’$）分类讨论：</p><ul><li>当$n’&lt;10^k$时，1出现的次数为0。</li><li>当$10^k-1&lt;n’&lt;2\times10^k$时，1出现的次数为$n’-10^k+1$</li><li>当$n’&gt;2\times10^k-1$, 1出现的次数为$10^k$<br>综上，对$n’$，1出现的次数可以表示为$min(10^k,max(0, n’-10^k+1))$</li></ul><p>所以，对第k位而言，总的1的个数可以表示为：<br>$$n//10^{k+1}\times10^k+min(10^k,max(0, n’-10^k+1))$$</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> countDigitOne(self, n: int) -&gt; int:<br>    <span class="hljs-attribute">k</span>, mulk = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-attribute">ans</span> = <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> n &gt;= mulk:<br>        <span class="hljs-attribute">ans</span> += (n // (mulk * <span class="hljs-number">10</span>)) * mulk + min(max(n % (mulk * <span class="hljs-number">10</span>) - mulk + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), mulk)<br>        <span class="hljs-attribute">k</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">mulk</span> *= <span class="hljs-number">10</span><br>    <span class="hljs-attribute">return</span> ans<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/233.png" alt="233"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode困难题-233</title>
    <link href="/2021/08/18/leetcode%E5%9B%B0%E9%9A%BE%E9%A2%98-233/"/>
    <url>/2021/08/18/leetcode%E5%9B%B0%E9%9A%BE%E9%A2%98-233/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/">数字1的个数-题解</a></p><p>数字1的个数等于每个数位上1的个数之和，如$n=1234$,答案为：</p><ul><li>个位上1的数量</li><li>十位上1的数量 </li><li>百位上1的数量</li><li>千位上1的数量<br>四个部分求和。</li></ul><p>以百位为例，对每1000个数，百位上1的数量为100，即100～199。即令数位为$k$（个位$k=0$），完整的循环会有$10^k$个1。<br>剩下不完整的循环应用$n mod 10^{k+1}$表示。如对个位而言，剩下数字为4;对百位而言，剩下数位为234。<br>对剩下的数字（记为$n’$）分类讨论：</p><ul><li>当$n’&lt;10^k$时，1出现的次数为0。</li><li>当$10^k-1&lt;n’&lt;2\times10^k$时，1出现的次数为$n’-10^k+1$</li><li>当$n’&gt;2\times10^k-1$, 1出现的次数为$10^k$<br>综上，对$n’$，1出现的次数可以表示为$min(10^k,max(0, n’-10^k+1))$</li></ul><p>所以，对第k位而言，总的1的个数可以表示为：<br>$$n//10^{k+1}\times10^k+min(10^k,max(0, n’-10^k+1))$$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>困难题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>困难题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法基础总结</title>
    <link href="/2021/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-2021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B/"/>
    <url>/2021/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-2021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><blockquote><p>针对一个任务（Task）T，和一个性能指标（Performance Metric）P，若程序通过经验（Experience）E在任务T上的指标P获得了提升，那么就认为，程序针对T和P，对E进行了学习。</p></blockquote><h3 id="机器学习任务模型"><a href="#机器学习任务模型" class="headerlink" title="机器学习任务模型"></a>机器学习任务模型</h3><p>从数据标签来看：有监督、半监督、无监督<br>从数据学习方式来看：生成模型、判别模型<br>任务：分类任务、回归任务、聚类、降维、序列标注……</p><h2 id="机器学习算法基础"><a href="#机器学习算法基础" class="headerlink" title="机器学习算法基础"></a>机器学习算法基础</h2><h3 id="贝叶斯学派与频率学派"><a href="#贝叶斯学派与频率学派" class="headerlink" title="贝叶斯学派与频率学派"></a>贝叶斯学派与频率学派</h3><ul><li>频率学派，其特征是把需要推断的参数θ视作固定且未知的常数，而样本X是随机的，其着眼点在样本空间，有关的概率计算都是针对X的分布。</li><li>贝叶斯学派，他们把参数θ视作随机变量，而样本X是固定的，其着眼点在参数空间，重视参数θ的分布，固定的操作模式是通过参数的先验分布结合样本信息得到参数的后验分布。</li></ul><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>$$P(A|B)=\frac{P(B|A)P(A)}{P(B)}$$<br>其中$P(A)$为先验概率，$P(B|A)$为似然性，最终结果为后验概率。</p><p><a href="https://www.zhihu.com/question/51448623">怎么理解贝叶斯公式</a></p><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><blockquote><p><strong>利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值！</strong>极大似然估计中采样需满足一个重要的假设，就是所有的采样都是独立同分布的。</p></blockquote><p>原理：极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。</p><p>对于函数$p(x|\theta)$，$x$表示某一个具体的数据，$\theta$表示模型的参数：  </p><ul><li><p>如果$\theta$是已知确定的，$x$是变量，这个函数叫做概率函数(probability function)，它描述对于不同的样本点$x$，其出现概率是多少。</p></li><li><p>如果$x$是已知确定的， $\theta$是变量，这个函数叫做似然函数(likelihood function), 它描述对于不同的模型参数，出现 $x$这个样本点的概率是多少。</p></li></ul><p>记已知样本集为$D={ x_1,x_2,\cdots,x_n }$(独立同分布)<br>似然函数：联合概率密度函数$P(D|\theta)$称为相对于${ x_1,x_2,\cdots,x_n }$的$\theta$的似然函数。<br>$$l(\theta)=p(D|\theta)=p(x_1,x_2,\cdots,x_n|\theta)=\prod_{i=1}^n p(x_i|\theta)$$</p><p>能使似然函数最大的$\theta$值就是最可能的参数值，即$\theta$的极大似然估计量。</p><p><a href="https://fengzhe.blog.csdn.net/article/details/80206657">最小二乘法的概率解释</a></p><h4 id="最大后验估计"><a href="#最大后验估计" class="headerlink" title="最大后验估计"></a>最大后验估计</h4><blockquote><p>如果一枚硬币抛10次，10次均为正面，根据最大似然估计，那么这枚硬币的概率应该为1。但这也未免太武断了。</p></blockquote><p>最大后验估计：极大似然估计的基础上引入先验概率</p><ul><li>如果先验认为这个硬币是概率是均匀分布的，被称为无信息先验( non-informative prior )，通俗的说就是“让数据自己说话”，此时贝叶斯方法等同于频率方法。</li><li>随着数据的增加，先验的作用越来越弱，数据的作用越来越强，参数的分布会向着最大似然估计靠拢。而且可以证明，最大后验估计的结果是先验和最大似然估计的凸组合。<br><a href="https://zhuanlan.zhihu.com/p/32616870">最大后验估计</a></li></ul><h3 id="线性回归的概率解释"><a href="#线性回归的概率解释" class="headerlink" title="线性回归的概率解释"></a>线性回归的概率解释</h3><p><a href="https://www.cnblogs.com/qizhien/p/11574433.html">线性回归的概率解释</a></p><h3 id="对数几率回归"><a href="#对数几率回归" class="headerlink" title="对数几率回归"></a>对数几率回归</h3><p><a href="https://zhuanlan.zhihu.com/p/25577671">对数几率回归</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/26614750">一文搞懂极大似然估计</a><br><a href="https://blog.csdn.net/zengxiantao1994/article/details/72787849">极大似然估计详解</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记-UNet++</title>
    <link href="/2021/08/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-UNet/"/>
    <url>/2021/08/11/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-UNet/</url>
    
    <content type="html"><![CDATA[<p>UNet++: Redesigning Skip Connections to Exploit Multiscale Features in Image Segmentation</p> <span id="more"></span> <h2 id="整体设计思路的理解"><a href="#整体设计思路的理解" class="headerlink" title="整体设计思路的理解"></a>整体设计思路的理解</h2><ul><li><p>对编码解码器结构的重新思考：以UNet为例，UNet在医学图像分割问题中取得了良好的效果，他最主要的部分就是<strong>下采样</strong>， <strong>上采样</strong>和<strong>跳跃连接</strong>。但如果想对这个网络结构进行优化，还应该去关注哪些部分？</p><ul><li>要多深合适？</li><li>降采样是否是必须的？<blockquote><p>对于特征提取阶段，浅层结构可以抓取图像的一些简单的特征，比如边界，颜色，而深层结构因为感受野大了，而且经过的卷积操作多了，能抓取到图像的一些说不清道不明的抽象特征，总之，浅有浅的侧重，深有深的优势。既然浅层特征和深层特征都很重要，U-Net为什么只在4层以后才返回去，也就是只去抓深层特征，而不在前面就开始上采样呢？</p></blockquote></li></ul></li><li><p>比较不同深度的UNet发现，并不是越深越好，要根据数据集和任务的复杂度来确定。</p></li></ul><p><img src="/images/pasted-10.png" alt="把不同深度的特征全用上"></p><p><img src="/images/pasted-11.png" alt="Deep Layer Aggregation"></p><ul><li>剪枝：因为在深监督的过程中，每个子网络的输出都其实已经是图像的分割结果了，所以如果小的子网络的输出结果已经足够好了，我们可以随意的剪掉那些多余的部分了。</li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>目前较好的医学图像分割模型都是UNet或者FCN的变体。这些模型具有两个缺陷：</p><ul><li>最优深度无法确定</li><li>跳跃链接限制在同尺度的特征图上<br>为解决这两个问题，本文提出UNet++用于语义和实例分割。</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>编码-解码网络结构被广泛应用在语义和实例分割模型中，这种网络结构的成功可以归功与他的<strong>跳跃连接</strong>结构，将编码器“深度的、语义的、粗粒度的”特征图与解码器“浅层的、低级的、细粒度”的特征图相结合，实验证明这种方法在恢复目标细粒度的细节、甚至复杂背景上都非常有效。<br>然而，这种网络结构存在两个缺陷：</p><ul><li>不同应用中，最优的网络深度往往不同，取决与数据量和模型的复杂度。而集成不同深度网络的方法效率较低。</li><li>网络的设计具有不必要的限制，即需要编码和解码的特征图尺寸相同，没有理论能够保证这是最佳的匹配方式。<br>本文提出了UNet++来解决这两个问题。</li></ul><p><img src="/img/papers/unet++1.png" alt="Unet++的演变"></p><p>UNet++由不同深度的UNet组成，编码器通过重新设计的跳跃链接对相同分辨率进行密集链接，该网络具有以下优点：</p><ul><li>UNet++不倾向于选择网络深度，因为它在其架构中嵌入了不同深度的UNet。所有这些UNet部分共享一个编码器，而它们的解码器是交织在一起的。通过在深度监督下训练UNet++,所有组成的UNet被同时训练，同时受益于共享的图像表示。这种设计不仅提高了整体的分割性能，而且能够在推理过程中进行模型剪枝。</li><li>UNet++没有受到不必要的限制性跳跃连接的阻碍，在普通的跳跃连接中，只有来自编码器和解码器的相同比例的特征图可以被融合。UNet++中引入的重新设计的跳跃连接在解码器节点呈现不同比例的特征图，允许aggregation layer决定如何将跳跃连接中携带的各种特征图与解码器特征图融合。在UNet++中，这种重新设计的跳跃连接通过同样分辨率的解码器和子UNet密集连接实现。</li></ul><h2 id="UNet"><a href="#UNet" class="headerlink" title="UNet++"></a>UNet++</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>本文在不同的数据集上实验比较不同深度的Unet的效果，实验结果表明:</p><ul><li>更深的UNet效果不一定更好</li><li>最优的深度与任务的复杂度和数据集的大小相关</li></ul><p><img src="/img/papers/unet++2.png" alt="Unet深度的消融实验"></p><p>基于这样的发现，一个研究方向是网络结构搜索（NAS），而本文提出一个集成的网络结构，<strong>将不同深度的UNet组合在一起</strong>（Fig 1中$U-Net^e$）。在网络训练中，本文为每个UNet设计了分离的损失函数，$X^{0,j}, j=1,2,3,4$。一些研究中的深监督模型将辅助损失加入解码器网络，而本文只是将他们应用与$X^{0,j}$,在测试阶段，将多个Unet的输出进行平均。<br>$U-Net^e$实现了知识共享，所有UNet共享了同一个编码器，虽然各自的解码器不同。但这个网络仍有两点不足：</p><ul><li>解码器没有连接起来</li><li>仍然只能组合相同尺度的特征<br>为了解决这些问题，本文首先移除了原本的跳跃连接结构，然后将相邻的结点连接起来，即$U-Net^+$网络（Fig.1(f)）。这样，不相交的解码器也得以连接起来。$U-Net^{++}$网络进一步进行了优化，通过密集连接，解码器中的每个节点不仅具有最终聚合后的特征图，还具有中间聚集特征图和来自编码器的原始相同比例特征图。</li></ul><h3 id="Technical-details"><a href="#Technical-details" class="headerlink" title="Technical details"></a>Technical details</h3><h4 id="网络连接（Network-connectivity）"><a href="#网络连接（Network-connectivity）" class="headerlink" title="网络连接（Network connectivity）"></a>网络连接（Network connectivity）</h4><p>用$x^{i,j}$来表示$X^{i,j}$节点的输出,其中$i$表示编码器上的下采样层数,$j$表示跳跃连接中密集连接的卷积层.当$j=0$时(也就是最左边一列,编码器层),$x^{i,j}$的值通过$x^{i-1,j}$的值下采样加上卷积和激活之后得到,当$j=1$时,$X^{i,j}$就会接受两个输入,都来自编码器层,不过是两个连续的层,$j&gt;1$时就接受$j+1$个输入,其中$j$个输入是同一级跳跃连接的之前$j$个节点,最后一个输入是低一级的跳跃连接的上采样输出.</p><h4 id="深监督（Deep-supervision）"><a href="#深监督（Deep-supervision）" class="headerlink" title="深监督（Deep supervision）"></a>深监督（Deep supervision）</h4><blockquote><p>所谓深监督，就是在深度神经网络的某些中间隐藏层加了一个辅助的分类器作为一种网络分支来对主干网络进行监督的技巧，用来解决深度神经网络训练梯度消失和收敛速度过慢等问题。通常而言，增加神经网络的深度可以一定程度上提高网络的表征能力，但随着深度加深，会逐渐出现神经网络难以训练的情况，其中就包括像梯度消失和梯度爆炸等现象。为了更好的训练深度网络，我们可以尝试给神经网络的某些层添加一些辅助的分支分类器来解决这个问题。这种辅助的分支分类器能够起到一种判断隐藏层特征图质量好坏的作用。</p></blockquote><p>本文在$X^{0,1}$，$X^{0,2}$，$X^{0,3}$，$X^{0,4}$之后添加了$1\times 1$的conv和sigmoid激活函数，之后，本文为每一个语义尺度设计了一个混合的分割损失，包含像素级的交叉熵和dice系数损失，这个损失函数具有二者的优点：平滑的梯度和类别不平衡的处理。</p><h4 id="模型剪枝（Model-pruning）"><a href="#模型剪枝（Model-pruning）" class="headerlink" title="模型剪枝（Model pruning）"></a>模型剪枝（Model pruning）</h4><p>深监督让模型剪枝成为可能，UNet$^{++}$可以有两种操作模式：集成模式下将所有分支的结果进行平均，剪枝模式下只选择一个分支的结果。如下图所示，(a)就是没有剪枝，(d)就是最大化的剪枝。</p><p><img src="/img/papers/unet++3.png" alt="剪枝"></p><h2 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h2><h3 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h3><p><img src="/img/papers/unet++4.png" alt="数据集"></p><h3 id="Baselines-and-implementation"><a href="#Baselines-and-implementation" class="headerlink" title="Baselines and implementation"></a>Baselines and implementation</h3><p><img src="/img/papers/unet++5.png" alt="BASELINE"></p><h2 id="RELATED-WORKS"><a href="#RELATED-WORKS" class="headerlink" title="RELATED WORKS"></a>RELATED WORKS</h2><h3 id="SKip-connections"><a href="#SKip-connections" class="headerlink" title="SKip connections"></a>SKip connections</h3><p>跳跃连接最开始是在FCN网络中提出的,用于语义分割任务。之后Ronneberger等人提出了UNet用于医学图像的语义分割。但在上采样解码器特征图与编码器同尺度特征图的融合中，两个网络存在一些区别。其中FCN使用的是<strong>加</strong>操作，UNet使用的是<strong>拼接</strong>操作。<br>跳跃链接在恢复全尺度的空间分辨率、让全卷积方法适用于语义分割方面展现出了良好的效果。跳跃链接还被进一步用于残差网络、Dense网络等结构，提升了网络的性能。</p><blockquote><p>U-Net和FCN非常的相似，U-Net比FCN稍晚提出来，但都发表在2015年，和FCN相比，U-Net的第一个特点是完全对称，也就是左边和右边是很类似的，而FCN的decoder相对简单，只用了一个deconvolution的操作，之后并没有跟上卷积结构。第二个区别就是skip connection，FCN用的是加操作（summation），U-Net用的是叠操作（concatenation）。这些都是细节，重点是它们的结构用了一个比较经典的思路，也就是编码和解码（encoder-decoder），早在2006年就被Hinton大神提出来发表在了nature上.</p></blockquote><h3 id="Feature-aggregation"><a href="#Feature-aggregation" class="headerlink" title="Feature aggregation"></a>Feature aggregation</h3><p>聚合多级别的特征的相关研究：</p><ul><li>GridNet:跳跃连接之间缺少上采样层</li><li>FRRN：参数太多</li></ul><h3 id="Deep-vision"><a href="#Deep-vision" class="headerlink" title="Deep vision"></a>Deep vision</h3><ul><li>网络的深度可以作为正则化器;</li><li>深监督层可以提升隐藏层的效果，让中间层学到更有判别性的特征，让网络收敛更快。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/44958351">研习U-Net</a></p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>U-Net++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(8.7-8.13)</title>
    <link href="/2021/08/11/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-7-8-13/"/>
    <url>/2021/08/11/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-8-7-8-13/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业。<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">leetcode<em>85</em>最大矩形</a><br>思路：</p><ul><li>主要的实现思路可以参考84题的单调栈写法。<br>84题：<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution:<br>    def largestRectangleArea(self, height<span class="hljs-variable">s:</span> List[<span class="hljs-keyword">int</span>]) -&gt; in<span class="hljs-variable">t:</span><br>        n = <span class="hljs-built_in">len</span>(heights)<br>        <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span> = [<span class="hljs-number">0</span>] * n, [<span class="hljs-number">0</span>] * n<br><br>        mono_stack = <span class="hljs-keyword">list</span>()<br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">while</span> mono_stack <span class="hljs-built_in">and</span> heights[mono_stack[-<span class="hljs-number">1</span>]] &gt;= heights[i]:<br>                mono_stack.<span class="hljs-keyword">pop</span>()<br>            <span class="hljs-keyword">left</span>[i] = mono_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> mono_stack <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br>            mono_stack.<span class="hljs-keyword">append</span>(i)<br>        <br>        mono_stack = <span class="hljs-keyword">list</span>()<br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">while</span> mono_stack <span class="hljs-built_in">and</span> heights[mono_stack[-<span class="hljs-number">1</span>]] &gt;= heights[i]:<br>                mono_stack.<span class="hljs-keyword">pop</span>()<br>            <span class="hljs-keyword">right</span>[i] = mono_stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> mono_stack <span class="hljs-keyword">else</span> n<br>            mono_stack.<span class="hljs-keyword">append</span>(i)<br>        <br>        ans = <span class="hljs-built_in">max</span>((<span class="hljs-keyword">right</span>[i] - <span class="hljs-keyword">left</span>[i] - <span class="hljs-number">1</span>) * heights[i] <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(n)) <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> ans<br><br></code></pre></td></tr></table></figure>85题：<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Solution:<br>    def maximalRectangle(self, <span class="hljs-built_in">matrix</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">matrix</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">matrix</span>[<span class="hljs-number">0</span>]: <span class="hljs-built_in">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-built_in">row</span> = len(<span class="hljs-built_in">matrix</span>)<br>        <span class="hljs-built_in">col</span> = len(<span class="hljs-built_in">matrix</span>[<span class="hljs-number">0</span>])<br>        <span class="hljs-built_in">height</span> = [<span class="hljs-number">0</span>] * (<span class="hljs-built_in">col</span> + <span class="hljs-number">2</span>)<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">row</span>):<br>            stack = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">col</span> + <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">1</span>&lt;=j&lt;=<span class="hljs-built_in">col</span>: <br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">matrix</span>[i][j-<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;1&quot;</span>:<br>                        <span class="hljs-built_in">height</span>[j] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">height</span>[j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> <span class="hljs-built_in">height</span>[stack[-<span class="hljs-number">1</span>]] &gt; <span class="hljs-built_in">height</span>[j]:<br>                    cur = stack.<span class="hljs-built_in">pop</span>()<br>                    res = <span class="hljs-built_in">max</span>(res, (j - stack[-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)* <span class="hljs-built_in">height</span>[cur])<br>                stack.<span class="hljs-built_in">append</span>(j)<br>        <span class="hljs-built_in">return</span> res<br></code></pre></td></tr></table></figure></li></ul><p><img src="/img/code_sub/85.png" alt="85"></p><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode<em>150</em>逆波兰表达式求值</a><br>思路：</p><ul><li>分析题目，首先是一个比较典型的栈的数据结构;</li><li>依次遍历tokens中的元素，是数字就入栈，是算符就pop栈顶两个元素进行计算，再将结果入栈。</li><li>值得注意的是因为python2和python3除法的区别，在使用python2做除法时要先把被除数转化为float，再把结果转化为int。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalRPN</span>(<span class="hljs-params">self, tokens</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tokens: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        numbers = []<br>        cals = [<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>]<br>        <span class="hljs-keyword">while</span> tokens:<br>            current = tokens.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> current <span class="hljs-keyword">in</span> cals:<br>                num2 = numbers.pop()<br>                num1 = numbers.pop()<br>                <span class="hljs-keyword">if</span> current == <span class="hljs-string">&quot;+&quot;</span>:<br>                    numbers.append(num1+num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;-&quot;</span>:<br>                    numbers.append(num1-num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;*&quot;</span>:<br>                    numbers.append(num1*num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;/&quot;</span>:<br>                    numbers.append(<span class="hljs-built_in">int</span>(num1/<span class="hljs-built_in">float</span>(num2)))<br>            <span class="hljs-keyword">else</span>:<br>                numbers.append(<span class="hljs-built_in">int</span>(current))<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/150.png" alt="150"></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">leetcode<em>225</em>用队列实现栈225</a><br>思路：</p><ul><li>用一个主要的队列queue模拟存储的数据，另一个tmp队列来改变queue的次序（倒序）</li><li>每次push的时候，先把数据全部暂存到tmp中，push数据进queue之后，再把数据全部放回queue，这样数据就是倒序的</li><li>每次pop的时候，只需要输出第一个元素就可以实现pop操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Initialize your data structure here.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.queue = []<br>        self.tmp = []<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Push element x onto stack.</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> self.queue:<br>            self.tmp.append(self.queue.pop(<span class="hljs-number">0</span>))<br>        self.queue = [x]<br>        <span class="hljs-keyword">while</span> self.tmp:<br>            self.queue.append(self.tmp.pop(<span class="hljs-number">0</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Removes the element on top of the stack and returns that element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.queue.pop(<span class="hljs-number">0</span>)<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Get the top element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.queue[<span class="hljs-number">0</span>]<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns whether the stack is empty.</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">if</span> self.queue <span class="hljs-keyword">else</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/225.png" alt="225"></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">leetcode<em>232</em>用栈实现队列</a><br>思路：</p><ul><li>最基本的思路就是用两个栈一个模拟后进先出（栈stack）一个模拟先进先出（队列queue）。</li><li>在push的时候，首先将stack中的栈顶元素依次弹出放入queue，此时queue就是队列的顺序，执行完push再反方向传回stack即可。</li><li>其他操作就可以用栈的标准操作完成。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Initialize your data structure here.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.stack = []<br>        self.queue = []<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Push element x to the back of queue.</span><br><span class="hljs-string">        :type x: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> self.stack:<br>            self.queue.append(self.stack.pop())<br>        self.queue.append(x)<br>        <span class="hljs-keyword">while</span> self.queue:<br>            self.stack.append(self.queue.pop())<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Removes the element from in front of queue and returns that element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.stack.pop()<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Get the front element.</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">empty</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns whether the queue is empty.</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/232.png" alt="232"></p><p><a href="https://leetcode-cn.com/problems/remove-k-digits/">leetcode<em>402</em>移掉 K位数字</a><br>思路：</p><ul><li>要使剩下的数字最小，需要保证靠前的数字尽可能小。</li><li>每个数字进来之前都从后进的开始比较，在k大于0时先弹出后进来的，因此可以用栈来实现。</li><li>Python lstrip() 方法用于截掉字符串左边的空格或指定字符。</li><li>return a or b从左到右计算表达式,返回碰到的第一个真值，如果都是假的值，则返回最后一个假的值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeKdigits</span>(<span class="hljs-params">self, num, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        stack = []<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> num:<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> <span class="hljs-built_in">int</span>(n) &lt; <span class="hljs-built_in">int</span>(stack[-<span class="hljs-number">1</span>]) <span class="hljs-keyword">and</span> k &gt; <span class="hljs-number">0</span>:<br>                stack.pop()<br>                k -= <span class="hljs-number">1</span><br>            stack.append(n)<br>        <br>        stack = stack[:-k] <span class="hljs-keyword">if</span> k <span class="hljs-keyword">else</span> stack<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(stack).lstrip(<span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/402.png" alt="402"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记-Brain Tumor Segmentation with Missing Modalities</title>
    <link href="/2021/08/06/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/06/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Brain-Tumor-Segmentation-with-Missing-Modalities-via-Latent-Multi-source-Correlation-Representation"><a href="#Brain-Tumor-Segmentation-with-Missing-Modalities-via-Latent-Multi-source-Correlation-Representation" class="headerlink" title="Brain Tumor Segmentation with Missing Modalities via Latent Multi-source Correlation Representation"></a>Brain Tumor Segmentation with Missing Modalities via Latent Multi-source Correlation Representation</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul><li>多模态的MR图像可以提供互补的信息用于脑肿瘤的准确分类。</li><li>临床上经常会缺失部分模态。</li><li>考虑到不同模态图像存在很强的关联性，本文提出了一个<strong>相关性表达模块（correlation representation block）</strong>来探索不同模态的潜在关联。</li><li>通过注意力机制将相关性表达进行融合，突出对分割最重要的特征。</li><li>Brats18数据集，实验效果更好，缺失模态时鲁棒性更强。</li></ul><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="多模态MR图像："><a href="#多模态MR图像：" class="headerlink" title="多模态MR图像："></a>多模态MR图像：</h4><ul><li>T1-weighted(T1)</li><li>contrast-enhanced T1-weighted(T1c)</li><li>T2-weighted(T2)</li><li>Fluid Attenuation Inversion Recovery(FLAIR)<br>不同模态可以提供互补的信息，减少信息的不确定性，提高临床诊断和分割的效果。</li></ul><h4 id="脑肿瘤分割相关研究中存在的问题"><a href="#脑肿瘤分割相关研究中存在的问题" class="headerlink" title="脑肿瘤分割相关研究中存在的问题"></a>脑肿瘤分割相关研究中存在的问题</h4><ul><li>耗时、昂贵</li><li><strong>需要完整的多模态数据集，但临床上通常会有缺失</strong></li><li>处理缺失模态的相关研究：<ul><li>对不同模态子集都训练模型（复杂，耗时）</li><li>生成缺失的图像（需要额外的网络，分割效果受到生成图像质量的影响）</li><li><strong>将可用的模态进行融合，再投影到用于分割的空间。</strong></li></ul></li><li>用缺失的多模态数据进行分割主要的<strong>挑战</strong>：如何从任何可能的模态子集学习一个融合之后的特征表达，并获取鲁棒性强的分割。</li></ul><h4 id="本文的主要贡献："><a href="#本文的主要贡献：" class="headerlink" title="本文的主要贡献："></a>本文的主要贡献：</h4><ul><li>相关性表达模块（correlation representation block， CR）</li><li>基于注意力机制的相关性表达融合方法</li><li>首个可以从缺失的多模态图像中描述相关性表达的多模态脑肿瘤分割网络</li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><img src="/img/papers/LMCR1.png" alt="网络结构"></p><h4 id="modeling-the-latent-Multi-source-Correlation"><a href="#modeling-the-latent-Multi-source-Correlation" class="headerlink" title="modeling the latent Multi-source Correlation"></a>modeling the latent Multi-source Correlation</h4><p><img src="/img/papers/LMCR2.png" alt="相关性表达块（CR）"></p><ul><li>MPE Module(Model Parameter Estimation)<br>不同模态图像首先输入不同的编码器，可学习参数$\theta_i$，学习到特定模态的表示$f_i(X_i|\theta_i)$，MPE模块将$f_i$映射到$\tau_i={\alpha_i,\beta_i,\gamma_i,\delta_i}$，每个模态参数不同。</li><li>LCE Module(Linear Correlation Expression)<br>最后通过LCE模块获得最终的CR表示$F_i(X_i|\theta_i)$，公式如下：<br><img src="/img/papers/LMCR3.png" alt="公式"></li></ul><p><strong>因为输入四个模态，最终会学到四个CR值，如果缺失了一个模态，就可以用已有的相关表达来进行恢复，作者用最接近的一个模态来恢复缺失图像，保证网络一直有四个输入。</strong></p><h4 id="Fusion-Strategy"><a href="#Fusion-Strategy" class="headerlink" title="Fusion Strategy"></a>Fusion Strategy</h4><p><img src="/img/papers/LMCR4.png" alt="Fusion Block"><br>思路：根据四个模态的特征表达在分割结果中的贡献进行加权。<br><strong>根据LCE的公式，每个特征表达和另外三个模态都是线性相关的。</strong><br>权重的学习：注意力模块，包括通道注意力（模态）和空间注意力。分别和特征表达$F$相乘，获得注意力表达$F_c$和$F_s$，然后通过相加获取最终的融合特征。一个模态的权重越大，对分割结果的贡献也就越大。</p><h4 id="Network-Architecture-and-Learning-Process"><a href="#Network-Architecture-and-Learning-Process" class="headerlink" title="Network Architecture and Learning Process"></a>Network Architecture and Learning Process</h4><p><img src="/img/papers/LMCR5.png" alt="网络整体的框架"><br>损失函数：<script type="math/tex">L_{total}=L_{dice}+L_1</script>,$L_1$是mean absolute loss。</p><p>在分割不同区域时，可能需要不同的感受野，考虑到普通的UNet感受野有限，不能获取足够的语义特征信息，本文在编码和解码部分使用了<strong>残差块</strong>和<strong>空洞卷积</strong>获取不同尺度的特征。</p><h3 id="Data-and-Implementation-Details"><a href="#Data-and-Implementation-Details" class="headerlink" title="Data and Implementation Details"></a>Data and Implementation Details</h3><p>数据集：BraTS 2018：285病例，四个模态的MR图像，三个分割类（complete tumor， tumor core和enhancing tumor），已经经过预处理（配准，插值，颅骨剥离）</p><p><img src="/img/papers/LMCR6.png" alt="DICE"><br><a href="https://arxiv.org/pdf/2003.08870.pdf">论文原文</a></p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BTS</tag>
      
      <tag>MICCAI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据总结-YARN(2021暑期课程)</title>
    <link href="/2021/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93-Yarn-2021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B/"/>
    <url>/2021/08/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93-Yarn-2021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="资源管理调度框架YARN"><a href="#资源管理调度框架YARN" class="headerlink" title="资源管理调度框架YARN"></a>资源管理调度框架YARN</h2><h3 id="Hadoop框架的改进"><a href="#Hadoop框架的改进" class="headerlink" title="Hadoop框架的改进"></a>Hadoop框架的改进</h3><ul><li>单一名称节点，存在单点失效问题：设计了HDFS HA，提供名称节点热备份机制</li><li>单一命名空间，无法实现资源隔离：设计了HDFS联邦，管理多个命名空间</li><li>资源管理效率低：设计了新的资源管理框架YARN</li></ul><h3 id="MapReduce1-0的缺陷"><a href="#MapReduce1-0的缺陷" class="headerlink" title="MapReduce1.0的缺陷"></a>MapReduce1.0的缺陷</h3><p>MapReduce1.0采用主从架构设计，包括一个JobTraker和若干个TaskTracker，前者负责作业的调度和资源的管理，后者负责执行JobTracker指派的具体任务。这种架构设计具有一些很难克服的缺陷。具体如下：</p><ul><li>只有一个JobTracker，存在单点故障</li><li>JobTracker大包大揽导致任务过重</li><li>容易出现内存溢出</li><li>资源划分不合理</li></ul><h3 id="YARN设计思路"><a href="#YARN设计思路" class="headerlink" title="YARN设计思路"></a>YARN设计思路</h3><p><strong>放权</strong>:把原JobTracker三大功能（资源管理，任务调度，任务监控）进行拆分<br>资源管理：ResourceManager<br>任务调度和任务监控：ApplicationMaster<br>TaskTracker任务：NodeManager</p><h3 id="YARN体系结构"><a href="#YARN体系结构" class="headerlink" title="YARN体系结构"></a>YARN体系结构</h3><p>ResourceManager：</p><ul><li>处理客户端请求</li><li>启动、监控ApplicationMaster，把资源按策略分配给各应用</li><li>监控NodeManager，接受NM的资源汇报信息</li><li>负责集群中所有资源的统一管理和分配<br>ApplicationMaster：</li><li>为应用程序申请资源，并分配给内部任务</li><li>任务调度、监控和容错</li><li>YARN提供MapReduce的ApplicationMaster实现<br>NodeManager：</li><li>单个节点上的资源管理</li><li>处理来自ApplicationMaster、ResourceManager的命令</li><li>监控container生命周期，管理资源使用</li></ul><blockquote><p>Container是YARN中资源的抽象，封装了某节点上一定量的资源（内存，CPU），由AM向RM申请，RM的资源调度器分配给AM，container的运行由AM向资源所在的NM发起。所以存在运行AM和运行各类任务的两类container。</p></blockquote><h3 id="YARN工作流程"><a href="#YARN工作流程" class="headerlink" title="YARN工作流程"></a>YARN工作流程</h3><ul><li>用户编写客户端应用程序，向YARN提交应用程序，提交的内容包括ApplicationMaster程序，启动ApplicationMaster的命令，用户程序等。</li><li>YARN中ResourceManager负责接受和处理来自客户端的请求。接到客户端应用程序的请求后，ResourceManager里面的调度器会为应用程序分配一个<strong>Container</strong>，同时ResourceManager的应用程序管理器会与该容器所在NodeManager通信，为该应用程序在该容器中启动一个ApplicationMaster。</li><li>ApplicationMaster被创建后，首先向RM注册，从而使得用户通过RM来直接查看应用程序的运行状态。4-7步是具体的应用程序执行步骤。</li><li>AM采用轮询的方式通过RPC协议向RM申请资源。</li><li>RM以容器的形式向提出申请的AM分配资源，一旦AM申请到资源后，就会与该容器所在的NM通信，要求他启动任务。</li><li>当AM要求容器启动任务时，他会为任务设置好运行环境（包括环境变量，JAR包，二进制程序等），然后将任务启动命令写到一个脚本中，最后通过在容器中运行该脚本来启动任务。</li><li>各个任务通过某个RPC协议向AM汇报状态和进度，让AM随时掌握各个任务的运行状态，从而可以在任务失败时重启任务。</li><li>应用程序完成后，AM向RM的应用程序管理器注销关闭自己，AM因故失败，RM中的应用程序管理器会检测到失败的情形，将其重新启动，直到所有任务执行完毕。</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><blockquote><p>为什么会产生 yarn,它解决了什么问题，有什么优势？</p></blockquote><p>1）Yarn最主要的功能就是解决运行的用户程序与yarn框架完全解耦。<br>2）Yarn上可以运行各种类型的分布式运算程序（mapreduce只是其中的一种），比如mapreduce、storm程序，spark程序……</p><blockquote><p>MapReduce 2.0 容错性</p></blockquote><p>1）MRAppMaster容错性<br>一旦运行失败，由YARN的ResourceManager负责重新启动，最多重启次数可由用户设置，默认是2次。一旦超过最高重启次数，则作业运行失败。<br>2）Map Task/Reduce<br>Task Task周期性向MRAppMaster汇报心跳；一旦Task挂掉，则MRAppMaster将为之重新申请资源，并运行之。最多重新运行次数可由用户设置，默认4次。</p><blockquote><p>简述hadoop1与hadoop2 的架构异同</p></blockquote><p>1）加入了yarn解决了资源调度的问题。<br>2）加入了对zookeeper的支持实现比较可靠的高可用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/98492393">大数据Hadoop面试题（四）——YARN</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>YARN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据总结-HDFS(2021暑期课程)</title>
    <link href="/2021/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93%EF%BC%882021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%EF%BC%89/"/>
    <url>/2021/08/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93%EF%BC%882021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="HDFS概述"><a href="#HDFS概述" class="headerlink" title="HDFS概述"></a>HDFS概述</h3><ul><li>HDFS集群分为两大角色：NameNode、DataNode<ul><li>NameNode负责管理整个文件系统的元数据</li><li>DataNode 负责管理用户的文件数据块</li></ul></li><li>文件会按照固定的大小（blocksize）切成若干块后分布式存储在若干台datanode上</li><li>每一个文件块可以有多个副本，并存放在不同的datanode上</li><li>Datanode会定期向Namenode汇报自身所保存的文件block信息，而namenode则会负责保持文件的副本数量</li><li>HDFS的内部工作机制对客户端保持透明，客户端请求访问HDFS都是通过向namenode申请来进行</li></ul><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>大文件存储，支持TB-PB级的数据量</li><li>高容错，运行在商用硬件上，而商业硬件并不可靠</li><li>高吞吐量：为大量数据访问的应用提供高吞吐量支持</li></ul><h3 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h3><ul><li>大文件存储</li><li>流式数据访问</li></ul><h3 id="不适合的场景"><a href="#不适合的场景" class="headerlink" title="不适合的场景"></a>不适合的场景</h3><ul><li>存储大量小文件</li><li>随机读取，低延迟读取</li></ul><h3 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h3><ul><li>Client:<br>（1）文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行存储；<br>（2）与NameNode交互，获取文件的位置信息；<br>（3）与DataNode交互，读取或者写入数据；<br>（4）Client提供一些命令来管理HDFS，比如启动或者关闭HDFS；<br>（5）Client可以通过一些命令来访问HDFS；</li><li>NameNode:<br>（1）管理HDFS的名称空间；<br>（2）管理数据块（Block）映射信息；<br>（3）配置副本策略；<br>（4）处理客户端读写请求。</li><li>DataNode:<br>（1）存储实际的数据块；<br>（2）执行数据块的读/写操作。</li><li>SecondaryNameNode:<br>（1）辅助NameNode，分担其工作量；<br>（2）定期合并Fsimage和Edits，并推送给NameNode；<br>（3）在紧急情况下，可辅助恢复NameNode。</li></ul><h3 id="HDFS架构优势"><a href="#HDFS架构优势" class="headerlink" title="HDFS架构优势"></a>HDFS架构优势</h3><ul><li>降低NameNode工作负载（NameNode不处理数据）</li><li>并行读写任务，充分利用带宽（NameNode将任务分配给DataNode,可以并行处理读写任务）</li></ul><h3 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h3><ul><li>HDFS中数据读写的最小单位（128M）</li><li>块大小的选择<ul><li>目标：最小化寻址开销，降到1%一下</li><li>块太小：寻址时间占比过高</li><li>块太大：Map数太少，作业变慢</li></ul></li><li>副本：默认副本数3<ul><li>第一个放在客户端所在节点</li><li>第二个放在同机架不同节点</li><li>嗲三个放在不同机架的另外一个节点</li></ul></li></ul><h3 id="HDFS读数据"><a href="#HDFS读数据" class="headerlink" title="HDFS读数据"></a>HDFS读数据</h3><blockquote><p>客户端将要读取的文件路径发送给namenode，namenode获取文件的元信息（主要是block的存放位置信息）返回给客户端，客户端根据返回的信息找到相应datanode逐个获取文件的block并在客户端本地进行数据追加合并从而获得整个文件</p></blockquote><ul><li>跟namenode通信查询元数据，找到文件块所在的datanode服务器</li><li>挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流</li><li>datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）</li><li>客户端以packet为单位接收，现在本地缓存，然后写入目标文件</li></ul><h3 id="HDFS写数据"><a href="#HDFS写数据" class="headerlink" title="HDFS写数据"></a>HDFS写数据</h3><blockquote><p>客户端要向HDFS写数据，首先要跟namenode通信以确认可以写文件并获得接收文件block的datanode，然后，客户端按顺序将文件逐个block传递给相应datanode，并由接收到block的datanode负责向其他datanode复制block的副本</p></blockquote><ul><li>根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在</li><li>namenode返回是否可以上传</li><li>client请求第一个 block该传输到哪些datanode服务器上</li><li>namenode返回3个datanode服务器ABC</li><li>client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端</li><li>client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答</li><li>当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。</li></ul><h3 id="NameNode机制"><a href="#NameNode机制" class="headerlink" title="NameNode机制"></a>NameNode机制</h3><h4 id="NameNode职责"><a href="#NameNode职责" class="headerlink" title="NameNode职责"></a>NameNode职责</h4><ul><li>负责客户端请求的响应</li><li>元数据的管理（查询，修改）</li><li>维护文件系统树及整棵树内所有的文件和目录</li></ul><p>NameNode维护两个文件，一个是fsimage，一个是editlog。</p><ul><li>编辑日志文件Editslog ：保存了所有对hdfs中文件的操作信息</li><li>命名空间镜像文件FsImage：是内存元数据在本地磁盘的映射，用于维护管理文件系统树，即元数据(metadata)</li></ul><h4 id="详细工作机制"><a href="#详细工作机制" class="headerlink" title="详细工作机制"></a>详细工作机制</h4><ul><li>NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息。然后，NameNode会在内存中执行元数据的增删改的操作。  </li><li>由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。SecondaryNameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。  </li><li>SecondaryNameNode首先会询问NameNode是否需要CheckPoint（触发CheckPoint需要满足两个条件中的任意一个，定时时间到和Edits中数据写满了）。直接带回NameNode是否检查结果。SecondaryNameNode执行CheckPoint操作，首先会让NameNode滚动Edits并生成一个空的edits.inprogress，滚动Edits的目的是给Edits打个标记，以后所有新的操作都写入edits.inprogress，其他未合并的Edits和Fsimage会拷贝到SecondaryNameNode的本地，然后将拷贝的Edits和Fsimage加载到内存中进行合并，生成fsimage.chkpoint，然后将fsimage.chkpoint拷贝给NameNode，重命名为Fsimage后替换掉原来的Fsimage。NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可，因为合并过的Edits中的元数据信息已经被记录在Fsimage中。  </li></ul><h3 id="DataNode机制"><a href="#DataNode机制" class="headerlink" title="DataNode机制"></a>DataNode机制</h3><h4 id="DataNode职责"><a href="#DataNode职责" class="headerlink" title="DataNode职责"></a>DataNode职责</h4><ul><li>存储管理用户的文件块数据<blockquote><p>定期向namenode汇报自身所持有的block信息（通过心跳信息上报）</p></blockquote></li><li>将信息上报给NameNode<blockquote><p>Datanode掉线判断时限参数:datanode进程死亡或者网络故障造成datanode无法与namenode通信，namenode不会立即把该节点判定为死亡，要经过一段时间，这段时间暂称作超时时长。HDFS默认的超时时长为10分钟+30秒。如果定义超时时间为timeout</p></blockquote></li></ul><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul><li>HDFS对外接口</li><li>从NameNode获取文件信息</li><li>连接DataNode读写数据</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><blockquote><p>HDFS如果存储大量小文件对NameNode的影响？  </p></blockquote><p>HDFS不适合大量小文件的存储，因namenode将文件系统的元数据存放在内存中，因此存储的文件数目受限于 namenode的内存大小。HDFS中每个文件、目录、数据块占用150Bytes。如果存放的文件数目过多的话会占用很大的内存。每个文件需要占用master机器一定内存，管理文件过多，内存占用过多，会使集群运行变慢。</p><blockquote><p>主NameNode挂掉，辅助NameNode能恢复文件吗？</p></blockquote><p>在主namenode发生故障时（假设没有及时备份数据），可以从SecondaryNameNode恢复数据。</p><blockquote><p>SecondaryNameNode的目的是什么？</p></blockquote><p>他的目的使帮助NameNode合并编辑日志，减少NameNode 启动时间</p><blockquote><p>NameNode与SecondaryNameNode 的区别与联系？</p></blockquote><p>区别：<br>NameNode负责管理整个文件系统的元数据，以及每一个路径（文件）所对应的数据块信息。  SecondaryNameNode主要用于定期合并命名空间镜像和命名空间镜像的编辑日志。<br>联系：<br>SecondaryNameNode中保存了一份和namenode一致的镜像文件（fsimage）和编辑日志（edits）。<br>在主namenode发生故障时（假设没有及时备份数据），可以从SecondaryNameNode恢复数据。</p><blockquote></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/164852653">NameNode和SecondaryNameNode工作机制</a><br><a href="https://zhuanlan.zhihu.com/p/97711717">大数据Hadoop面试题（二）——HDFS</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>HDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化基础总结(2021暑期课程)</title>
    <link href="/2021/08/04/%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%EF%BC%882021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%EF%BC%89/"/>
    <url>/2021/08/04/%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%EF%BC%882021%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>目标函数：$\Vert A\theta-y\Vert^2_2$<br>正规方程推导：$\theta=(A^TA)^{-1}A^Ty$<br>损失函数（均方误差）：<br><img src="/images/pasted-7.png" alt="损失函数"><br>代码实现：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-built_in">import</span> numpy as np<br>from sklearn <span class="hljs-built_in">import</span> metrics<br>from sklearn.datasets <span class="hljs-built_in">import</span> load_boston<br><br><span class="hljs-keyword">if</span> <span class="hljs-attr">__name__</span> == &#x27;__main__&#x27;:<br>    <span class="hljs-attr">boston</span> = load_boston()<br>    data, <span class="hljs-attr">target</span> = load_boston(<span class="hljs-attr">return_X_y=True)</span>  <span class="hljs-comment"># 读取数据</span><br><br>    <span class="hljs-attr">train_x</span> = data[:<span class="hljs-number">406</span>]<br>    <span class="hljs-attr">train_y</span> = target[:<span class="hljs-number">406</span>]  <span class="hljs-comment"># 前406个数据用于训练</span><br>    <span class="hljs-attr">test_x</span> = data[<span class="hljs-number">406</span>:]<br>    <span class="hljs-attr">test_y</span> = target[<span class="hljs-number">406</span>:]  <span class="hljs-comment"># 剩余数据用于测试</span><br><br>    <span class="hljs-attr">train_x</span> = np.concatenate((np.ones((train_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)), train_x), <span class="hljs-attr">axis=1)</span>  <span class="hljs-comment"># 在矩阵左边增加一列1来处理常数</span><br>    <span class="hljs-attr">test_x</span> = np.concatenate((np.ones((test_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)), test_x), <span class="hljs-attr">axis=1)</span><br><br>    <span class="hljs-attr">tmp0</span> = np.dot(train_x.T, train_x)<br>    <span class="hljs-attr">tmp1</span> = np.linalg.inv(tmp0)<br>    <span class="hljs-attr">tmp2</span> = np.dot(tmp1, train_x.T)<br>    <span class="hljs-attr">theta</span> = np.dot(tmp2, train_y)  <span class="hljs-comment"># 正规方程求解参数</span><br><br>    <span class="hljs-attr">pred_y</span> = np.dot(test_x, theta)  <span class="hljs-comment"># 预测值</span><br><br>    <span class="hljs-attr">loss</span> = (<span class="hljs-number">1</span> / len(pred_y)) * np.sum((pred_y - test_y) ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># 均方误差损失函数</span><br><br>    print(<span class="hljs-string">&quot;Linear Regression MSE:&quot;</span>, metrics.mean_squared_error(test_y, pred_y))<br>    print(f&#x27;myMSE: &#123;loss&#125;&#x27;)<br></code></pre></td></tr></table></figure><h2 id="正则化的作用"><a href="#正则化的作用" class="headerlink" title="正则化的作用"></a>正则化的作用</h2><p><strong>上界限定</strong><br><a href="https://zhuanlan.zhihu.com/p/38309692">机器学习中 L1 和 L2 正则化的直观解释</a></p><h2 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h2><p>岭回归是带二范数惩罚的最小二乘回归。</p><p>目标函数：$\Vert A\theta-y\Vert^2_2+\lambda\Vert\theta\Vert_2^2$<br>正规方程推导：$\theta=(A^TA+\lambda I)^{-1}A^Ty$<br>代码实现：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">if</span> <span class="hljs-attr">__name__</span> == &#x27;__main__&#x27;:<br>    <span class="hljs-attr">lambda_ridge</span> = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 岭回归的参数</span><br>    <span class="hljs-attr">boston</span> = load_boston()<br>    data, <span class="hljs-attr">target</span> = load_boston(<span class="hljs-attr">return_X_y=True)</span>  <span class="hljs-comment"># 读取数据</span><br><br>    <span class="hljs-attr">train_x</span> = data[:<span class="hljs-number">406</span>]<br>    <span class="hljs-attr">train_y</span> = target[:<span class="hljs-number">406</span>]  <span class="hljs-comment"># 前406个数据用于训练</span><br>    <span class="hljs-attr">test_x</span> = data[<span class="hljs-number">406</span>:]<br>    <span class="hljs-attr">test_y</span> = target[<span class="hljs-number">406</span>:]  <span class="hljs-comment"># 剩余数据用于测试</span><br><br>    <span class="hljs-attr">train_x</span> = np.concatenate((np.ones((train_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)), train_x), <span class="hljs-attr">axis=1)</span>  <span class="hljs-comment"># 在矩阵左边增加一列1来处理常数</span><br>    <span class="hljs-attr">test_x</span> = np.concatenate((np.ones((test_x.shape[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>)), test_x), <span class="hljs-attr">axis=1)</span><br><br>    <span class="hljs-attr">tmp0</span> = np.dot(train_x.T, train_x)<br>    <span class="hljs-attr">tmp1</span> = np.linalg.inv(tmp0 + lambda_ridge * np.eye(train_x.shape[<span class="hljs-number">1</span>]))<br>    <span class="hljs-attr">tmp2</span> = np.dot(tmp1, train_x.T)<br>    <span class="hljs-attr">theta</span> = np.dot(tmp2, train_y)  <span class="hljs-comment"># 正规方程求解参数</span><br><br>    <span class="hljs-attr">pred_y</span> = np.dot(test_x, theta)  <span class="hljs-comment"># 预测值</span><br><br>    <span class="hljs-attr">loss</span> = (<span class="hljs-number">1</span> / len(pred_y)) * np.sum((pred_y - test_y) ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># 均方误差损失函数</span><br><br>    print(<span class="hljs-string">&quot;Linear Regression MSE:&quot;</span>, metrics.mean_squared_error(test_y, pred_y))<br>    print(f&#x27;myMSE: &#123;loss&#125;&#x27;)<br></code></pre></td></tr></table></figure><h2 id="LASSO回归"><a href="#LASSO回归" class="headerlink" title="LASSO回归"></a>LASSO回归</h2><p>目标函数：$\Vert A\theta-y\Vert^2_2+\lambda\Vert\theta\Vert_1$</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>实验一：最小化$\frac{1}{2} (10x_1^2+x_2^2)$</p><p>目标函数：$\frac{1}{2} (10x_1^2+x_2^2)$</p><p>代码实现：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs maxima">import numpy as <span class="hljs-built_in">np</span><br>import matplotlib.pyplot as plt<br><br><br>def f(x):<br>    A = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-number">10.0</span>, <span class="hljs-number">0.0</span>], [<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>]])<br>    <span class="hljs-built_in">return</span> <span class="hljs-number">0.5</span> * <span class="hljs-built_in">np</span>.dot(x, A).dot(x.T)<br><br><br>def grad(x):<br>    A = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-number">10.0</span>, <span class="hljs-number">0.0</span>], [<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>]])<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">np</span>.dot(x, A)<br><br><br><span class="hljs-keyword">if</span> __name__ == &#x27;__main__&#x27;:<br>    x = <span class="hljs-built_in">np</span>.<span class="hljs-built_in">array</span>([[<span class="hljs-number">2.0</span>, <span class="hljs-number">20.0</span>]])<br>    costs = []<br>    epoch = <span class="hljs-number">300</span><br>    alpha = <span class="hljs-built_in">beta</span> = <span class="hljs-number">0.5</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>        <span class="hljs-keyword">step</span> = <span class="hljs-number">1.0</span><br>        gradient = grad(x)<br>        <span class="hljs-keyword">while</span> f(x - <span class="hljs-keyword">step</span> * gradient) &gt; f(x) - alpha * <span class="hljs-keyword">step</span> * <span class="hljs-built_in">np</span>.linalg.norm(gradient ** <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">step</span> *= <span class="hljs-built_in">beta</span><br>        x -= <span class="hljs-keyword">step</span> * gradient<br>        loss = f(x)<br>        costs.<span class="hljs-built_in">append</span>(loss[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-built_in">print</span>(f&#x27;x:&#123;x&#125;,y:&#123;f(x)&#125;&#x27;)<br><br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, len(costs) + <span class="hljs-number">1</span>), costs, c=&#x27;red&#x27;)<br>    plt.<span class="hljs-built_in">show</span>()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>优化基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(7.31-8.6)</title>
    <link href="/2021/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-31-8-6/"/>
    <url>/2021/08/02/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-31-8-6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业。<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">leetcode_219_存在重复元素</a><br>思路：</p><ul><li>可以用一个字典保存nums中每个数字的下标，即key值为数值，value为出现下标的列表;</li><li>得出字典后，遍历字典的value，用distance函数遍历计算相邻的索引之差，如果小于等于k就返回True，遍历结束返回False</li><li>这种方法可以通过，但是复杂度太高，所以第二种方法用滑动窗口来实现。</li><li>用一个set来维护当前k个数字并不断向右滑动，当前数字存在于set中则返回True，这种方法效率要高一点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance</span>(<span class="hljs-params">nums</span>):</span><br>            res = <span class="hljs-number">10</span>**<span class="hljs-number">9</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>                res = <span class="hljs-built_in">min</span>(res, nums[i+<span class="hljs-number">1</span>]-nums[i])<br>                <span class="hljs-keyword">if</span> res &lt;= k:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> dic:<br>                dic[nums[i]].append(i)<br>            <span class="hljs-keyword">else</span>:<br>                dic[nums[i]] = [i]<br>        <br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dic[key]) &gt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> distance(dic[key]):<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第二种方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        current = <span class="hljs-built_in">set</span>()<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> current:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            current.add(nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current) &gt; k:<br>                current.remove(nums[i-k])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/219.png" alt="219"></p><p><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">leetcode_643_子数组最大平均数 I</a><br>思路：</p><ul><li>第一种思路，用动态规划，dp[i]保存最后一个数字为nums[i]的结果。</li><li>dp[i] = max(dp[i-1], sum(nums[i-k+1:i+1]))</li><li>动态规划方法超时，尝试用滑动窗口。</li><li>滑动窗口不会超时，但其实感觉和动态规划差不多，只是不用dp数组保存中间结果，而是用current和last保存当前和上一个状态就可以了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 动态规划（超时）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaxAverage</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: float</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [-<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * <span class="hljs-built_in">len</span>(nums)<br>        dp[k-<span class="hljs-number">1</span>] = <span class="hljs-built_in">sum</span>(nums[:k])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], <span class="hljs-built_in">sum</span>(nums[i-k+<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>] / <span class="hljs-built_in">float</span>(k)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 滑动窗口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaxAverage</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: float</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-built_in">sum</span>(nums[:k])<br>        last = res<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, <span class="hljs-built_in">len</span>(nums)):<br>            current = last + nums[i] - nums[i-k]<br>            res = <span class="hljs-built_in">max</span>(res, current)<br>            last = current<br>        <span class="hljs-keyword">return</span> res / <span class="hljs-built_in">float</span>(k)<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/643.png" alt="643"></p><p><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">leetcode_1004_最大连续1的个数 III</a><br>思路：</p><ul><li>这道题也是标准的滑动窗口问题，主要的思想就是同时从左边出发，然后右端点移动到第一次不满足条件的位置，而左端点则移动到再一次满足条件的位置。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def longestOnes(self, nums, <span class="hljs-keyword">k</span>):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> num<span class="hljs-variable">s:</span> List[<span class="hljs-keyword">int</span>]<br>        :<span class="hljs-built_in">type</span> <span class="hljs-keyword">k</span>: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br><br>        <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">right</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">res</span> = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">right</span> &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">k</span> = <span class="hljs-keyword">k</span> - <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> nums[<span class="hljs-keyword">right</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">k</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">k</span> &gt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">res</span> = <span class="hljs-built_in">max</span>(<span class="hljs-keyword">res</span>, <span class="hljs-keyword">right</span>-<span class="hljs-keyword">left</span>+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> nums[<span class="hljs-keyword">left</span>] == <span class="hljs-number">1</span> <span class="hljs-built_in">and</span> <span class="hljs-keyword">left</span> &lt;= righ<span class="hljs-variable">t:</span><br>                    <span class="hljs-keyword">left</span> += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">left</span> += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">k</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">right</span> += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/1004.png" alt="1004"></p><p><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">leetcode_1838_最高频元素的频数</a><br>思路：</p><ul><li>同样用滑动窗口实现，思路也跟前面类似，但这道题前面修改提交了多次都超时了，主要问题包括：要用一个sums来维护当前窗口内的和，否则每次计算sum(nums[left:right])存在太多重复计算会超时;right不满足条件后，left+1之后继续循环貌似也会超时，也要加上判断，直到满足条件再继续循环。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def maxFrequency(self, nums, <span class="hljs-keyword">k</span>):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> num<span class="hljs-variable">s:</span> List[<span class="hljs-keyword">int</span>]<br>        :<span class="hljs-built_in">type</span> <span class="hljs-keyword">k</span>: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        nums.<span class="hljs-keyword">sort</span>()<br>        ans = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">right</span> = <span class="hljs-number">1</span><br>        sums = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">right</span> &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">c</span> = nums[<span class="hljs-keyword">right</span>] * (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span>) - sums - <span class="hljs-keyword">k</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">c</span> &lt;= <span class="hljs-number">0</span>:<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-keyword">right</span>-<span class="hljs-keyword">left</span>+<span class="hljs-number">1</span>)<br>                sums += nums[<span class="hljs-keyword">right</span>]  <br>                <span class="hljs-keyword">right</span> += <span class="hljs-number">1</span>       <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">c</span> &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">c</span> -= nums[<span class="hljs-keyword">right</span>]-nums[<span class="hljs-keyword">left</span>]<br>                    sums -= nums[<span class="hljs-keyword">left</span>]<br>                    <span class="hljs-keyword">left</span> += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/1838.png" alt="1838"></p><p><a href="https://leetcode-cn.com/problems/substrings-of-size-three-with-distinct-characters/">leetcode_1876_长度为三且各字符不同的子字符串</a><br>思路：</p><ul><li>从左往右依次判断长度为3的子字符串是否是“好子字符串”</li><li>用set来判断重复，如果不含重复元素set长度应该也为3</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countGoodSubstrings</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">2</span>):<br>            res = res + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(s[i:i+<span class="hljs-number">3</span>])) == <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> res<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/1876.png" alt="1876"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单源最短路径算法</title>
    <link href="/2021/08/02/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <url>/2021/08/02/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra算法的基本思路和例题<br> <span id="more"></span><br> <img src="/images/pasted-6.png" alt="Dijkstra算法伪代码"></p><p>1、算法初始，将选择的源点$s$放进集合$S$中；<br>2、无自环的源点$s$到自己的最短路径为$0$；<br>3、当顶点$$v_{i}$$不在集合$S$中时（此时集合$S$中仍只有源点$s$），开始进入循环；<br>4、将源点$s$与点$$v_i$$之间的权值赋给$$dist[s,v_i]$$。由于是有向图，所以当源点$s$不指向任何其他集合 $S$外的顶点时，$$dist[s,v_i]=\infty$$。可以理解为此时从源点$s$出发，暂时是达到不了$$v_i$$的。不过后来随着集合$S$的扩充，从源点$s$出发一定能到达所有的顶点。一会我们讲解例子时会出现这种情况。此时第一个$$for$$循环结束。<br>5、如果集合$V-S$不是空集，则进入循环；<br>6、选出经过第一个$$for$$循环之后的，在集合$$V-S$$中的，且相对于集合$S$的最短路径中距离最短的那个顶点$$v_j$$;<br>7、将这个顶点$$s_j$$并入集合$S$，从而达到扩充集合$S$的目的；<br>8、将顶点$$v_i$$并入集合$S$之后可能会对其他顶点相对于集合$S$的最短路的长度会有影响，所以进入内$$for$$循环对有影响的进行更新；<br>9、 即如果从源点$s$到我们在第$6$步选出的顶点$$v_j$$的相对于集合$S$的最短路径的长度再加上顶点$$v_j$$到顶点$$v_i$$之间的距离$$w_{i,j}$$还要小于源点$s$到顶点$$v_i$$的相对于集合$S$的最短路径的长度还要短的话；<br>10、则将源点$s$到顶点$$v_i$$的相对于集合$S$的最短路径更新成源点$s$到我们在第$6$步选出的顶点$$v_j$$的相对于集合$S$的最短路径再加上顶点$$v_j$$到顶点$$v_i$$之间的权值$$w_{i,j}$$。</p><p><a href="https://leetcode-cn.com/problems/network-delay-time/submissions/">leetcode例题</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">networkDelayTime</span>(<span class="hljs-params">self, times, n, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type times: List[List[int]]</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        g = [[<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y, time <span class="hljs-keyword">in</span> times:<br>            g[x - <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] = time<br><br>        dist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)] * n<br>        dist[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        used = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            x = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y, u <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(used):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> u <span class="hljs-keyword">and</span> (x == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dist[y] &lt; dist[x]):<br>                    x = y<br>            used[x] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">for</span> y, time <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(g[x]):<br>                dist[y] = <span class="hljs-built_in">min</span>(dist[y], dist[x] + time)<br><br>        ans = <span class="hljs-built_in">max</span>(dist)<br>        <span class="hljs-keyword">return</span> ans <span class="hljs-keyword">if</span> ans &lt; <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/129373740">参考</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>单源最短路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSTM网络</title>
    <link href="/2021/07/30/LSTM%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/07/30/LSTM%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>经典LSTM网络<br> <span id="more"></span></p><h2 id="序列数据"><a href="#序列数据" class="headerlink" title="序列数据"></a>序列数据</h2><ul><li>语音识别</li><li>音乐生成</li><li>情感分类</li><li>DNA序列分析</li><li>机器翻译</li><li>视频动作识别</li><li>命名实体识别</li></ul><h2 id="为什么不用普通神经网络"><a href="#为什么不用普通神经网络" class="headerlink" title="为什么不用普通神经网络"></a>为什么不用普通神经网络</h2><p>输入输出的长度可能不同（对NLP而言）。<br>不同位置学习到的特征无法共享。</p><h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p><img src="/images/pasted-1.png" alt="RNN"></p><p>RNN显著的魅力是将以前的信息连接到当前任务的这种思路，例如使用先前的视频帧可以有助于对当前帧的理解。</p><p><img src="/images/pasted-2.png" alt="“长依赖的问题”"></p><p>随着距离的增加，RNN无法有效的利用历史信息。</p><h2 id="LSTM网络"><a href="#LSTM网络" class="headerlink" title="LSTM网络"></a>LSTM网络</h2><p><img src="/images/pasted-3.png" alt="LSTM"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1F4411y7BA?from=search&amp;seid=10673917924570551105">吴恩达深度学习课程</a><br><a href="https://www.jianshu.com/p/4b4701beba92">如何简单的理解LSTM——其实没有那么复杂</a></p>]]></content>
    
    
    <categories>
      
      <category>经典网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经典网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多模态脑肿瘤分割</title>
    <link href="/2021/07/28/%E5%A4%9A%E6%A8%A1%E6%80%81%E8%84%91%E8%82%BF%E7%98%A4%E5%88%86%E5%89%B2/"/>
    <url>/2021/07/28/%E5%A4%9A%E6%A8%A1%E6%80%81%E8%84%91%E8%82%BF%E7%98%A4%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>多模态脑肿瘤分割基本知识的学习。<br> <span id="more"></span> </p></blockquote><h2 id="基本背景"><a href="#基本背景" class="headerlink" title="基本背景"></a>基本背景</h2><blockquote><p>Magnetic Resonance Imaging can provide complementary information due to its dependence on variable acquisition parameters, such as T1-weighted(T1), contrast-enhanced T1-weighted(T1c), T2-weighted(T2) and Fluid Attenuation Inversion Recovery(FLAIR) images.<br>Different Sequences can provide complmentary information to analyze different subregions of gliomas.</p></blockquote><p>MRI实质上是将强磁场作用于人体组织，使氢原子自旋趋于同向，之后释放磁场，自旋方向再次趋于随机。测量从自旋有序到完全无序的时间即弛豫时间。以此判断组织类型成分（质子密度）。T1,T2分别是两种不同信号的弛豫时间。简单直接的说，t1wi对脂肪显示较好，t2wi对水显示较好，所以t2wi对异常的肿物显示较好。<strong>不同模态可以提供互补信息，优化图像分析效果。</strong></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><ul><li>数据准备:<ul><li>数据维度选择</li><li>数据预处理</li><li>数据增强</li></ul></li><li>网络结构设计<ul><li>CNN-based</li><li>FCN-based</li><li>Resnet</li><li>DenseNet</li></ul></li><li>融合策略<ul><li>Input-level</li><li>Layer-level</li><li>Decision-level</li></ul></li><li>数据后处理<ul><li>形态学方法</li><li>条件随机场</li></ul></li></ul><h3 id="分割的评价指标"><a href="#分割的评价指标" class="headerlink" title="分割的评价指标"></a>分割的评价指标</h3><ul><li>Dice<br>$$Dice = \frac{2TP}{FP+2TP+FN}$$</li><li>IOU<br>$$IOU = \frac{TP}{FP+TP+FN}$$</li><li>PPV<br>$$PPV = \frac{TP}{TP+FP}$$</li><li>Sensetivity<br>$$Sensitivity = \frac{TP}{TP+FN}$$</li></ul><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><a href="https://www.smir.ch/BRATS/Start2015#pageBottom">Brats2015</a></p><ul><li>标注：<br>1 for necrosis<br>2 for edema<br>3 for non-enhancing tumor<br>4 for enhancing tumor<br>0 for everything else</li><li>MR image尺寸：$155\times240\times240$</li><li>220 subjects HGG， 54 subjects LGG</li></ul><h2 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h2><p><a href="https://ieeexplore.ieee.org/document/8981027">LSTM Multi-modal UNet for Brain Tumor Segmentation</a><br>(待补充)</p><h2 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h2><p>数据预处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brats15DataLoader</span>(<span class="hljs-params">Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data_dir, conf=<span class="hljs-string">&#x27;../config/train15.conf&#x27;</span>, train=<span class="hljs-literal">True</span></span>):</span><br>        img_lists = []  <span class="hljs-comment"># 数据名称集合</span><br>        train_config = <span class="hljs-built_in">open</span>(conf).readlines()<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_config:<br>            img_lists.append(os.path.join(data_dir, data.strip(<span class="hljs-string">&#x27;\n&#x27;</span>)))<br><br>        print(<span class="hljs-string">&#x27;\n&#x27;</span> + <span class="hljs-string">&#x27;~&#x27;</span> * <span class="hljs-number">50</span>)<br>        print(<span class="hljs-string">&#x27;******** Loading data from disk ********&#x27;</span>)<br>        self.data = []  <span class="hljs-comment"># 输出的二维图像数据列表（n, 4, 240, 240）</span><br>        self.freq = np.zeros(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 比例</span><br>        self.zero_vol = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">240</span>, <span class="hljs-number">240</span>))  <br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> subject <span class="hljs-keyword">in</span> img_lists:<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">&#x27;loading subject %d&#x27;</span> %count)<br>            volume, label = Brats15DataLoader.get_subject(subject)   <span class="hljs-comment"># 4 * 155 * 240 * 240,  155 * 240 * 240, ndarray</span><br>            volume = norm_vol(volume)<br><br>            self.freq += self.get_freq(label)<br>            <span class="hljs-keyword">if</span> train <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>                length = volume.shape[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 155</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>                    name = subject + <span class="hljs-string">&#x27;=slice&#x27;</span> + <span class="hljs-built_in">str</span>(i)<br>                    <span class="hljs-keyword">if</span> (volume[:, i, :, :] == self.zero_vol).<span class="hljs-built_in">all</span>():  <span class="hljs-comment"># when training, ignore zero data</span><br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self.data.append([volume[:, i, :, :], label[i, :, :], name])<br>            <span class="hljs-keyword">else</span>:<br>                volume = np.transpose(volume, (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>                self.data.append([volume, label, subject])<br><br>        self.freq = self.freq / np.<span class="hljs-built_in">sum</span>(self.freq)<br>        self.weight = np.median(self.freq) / self.freq  <span class="hljs-comment"># 权重</span><br>        print(<span class="hljs-string">&#x27;********  Finish loading data  ********&#x27;</span>)<br>        print(<span class="hljs-string">&#x27;********  Weight for all classes  ********&#x27;</span>)<br>        print(self.weight)<br>        <span class="hljs-keyword">if</span> train <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>            print(<span class="hljs-string">&#x27;********  Total number of 2D images is &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.data)) + <span class="hljs-string">&#x27; **********&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&#x27;********  Total number of subject is &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.data)) + <span class="hljs-string">&#x27; **********&#x27;</span>)<br><br>        print(<span class="hljs-string">&#x27;~&#x27;</span> * <span class="hljs-number">50</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index</span>):</span><br>        <span class="hljs-comment"># ********** get file dir **********</span><br>        [image, label, name] = self.data[index]  <span class="hljs-comment"># get whole data for one subject</span><br>        <span class="hljs-comment"># ********** change data type from numpy to torch.Tensor **********</span><br>        image = torch.from_numpy(image).<span class="hljs-built_in">float</span>()  <span class="hljs-comment"># Float Tensor 4, 240, 240</span><br>        label = torch.from_numpy(label).<span class="hljs-built_in">float</span>()    <span class="hljs-comment"># Float Tensor 240, 240</span><br>        <span class="hljs-keyword">return</span> image, label, name<br></code></pre></td></tr></table></figure><p>训练函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs css">def run():<br>    score_max = -<span class="hljs-number">1.0</span><br>    best_epoch = <span class="hljs-number">0</span><br>    weight = torch.<span class="hljs-built_in">from_numpy</span>(train_data.weight).<span class="hljs-built_in">float</span>()    # weight for all class<br>    weight = <span class="hljs-built_in">to_var</span>(weight)                                 #<br><br>    optimizer = optim.<span class="hljs-built_in">Adam</span>(params=net.<span class="hljs-built_in">parameters</span>(), lr=learning_rate, betas=(<span class="hljs-number">0.9</span>, <span class="hljs-number">0.999</span>))<br>    criterion = nn.<span class="hljs-built_in">CrossEntropyLoss</span>(weight=weight)<br><br>    for epoch in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, epochs + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;epoch....................................&#x27;</span> + <span class="hljs-built_in">str</span>(epoch))<br>        train_loss = []<br>        # *************** train model ***************<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;train ....&#x27;</span>)<br>        net.<span class="hljs-built_in">train</span>()<br>        for step, (image, label, index) in <span class="hljs-built_in">enumerate</span>(train_dataset):  # batch<br>            image = <span class="hljs-built_in">to_var</span>(image)    # <span class="hljs-number">4</span>D tensor   bz * <span class="hljs-number">4</span>(modal) * <span class="hljs-number">240</span> * <span class="hljs-number">240</span><br>            label = <span class="hljs-built_in">to_var</span>(label)    # <span class="hljs-number">3</span>D tensor   bz * <span class="hljs-number">240</span> * <span class="hljs-number">240</span> (value <span class="hljs-number">0</span>-<span class="hljs-number">4</span>)<br><br>            optimizer.<span class="hljs-built_in">zero_grad</span>()       #<br>            predicts = <span class="hljs-built_in">net</span>(image)    # <span class="hljs-number">4</span>D tensor   bz * <span class="hljs-number">5</span>(class) * <span class="hljs-number">240</span> * <span class="hljs-number">240</span><br>            loss_train = <span class="hljs-built_in">criterion</span>(predicts, label.<span class="hljs-built_in">long</span>())<br>            train_loss.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">float</span>(loss_train))<br>            loss_train.<span class="hljs-built_in">backward</span>()<br>            optimizer.<span class="hljs-built_in">step</span>()<br><br>            # ****** save sample image for each epoch ******<br>            if step % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;..step ....%d&#x27;</span> % step)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;....loss....%f&#x27;</span> %loss_train)<br>                predicts = <span class="hljs-built_in">one_hot_reverse</span>(predicts)  # <span class="hljs-number">3</span>D long Tensor  bz * <span class="hljs-number">240</span> * <span class="hljs-number">240</span> (val <span class="hljs-number">0</span>-<span class="hljs-number">4</span>)<br>                <span class="hljs-built_in">save_train_images</span>(image, predicts, label, index, epoch, save_dir=save_dir)<br><br>        # ***************** calculate valid loss *****************<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;valid ....&#x27;</span>)<br>        current_score, valid_loss = <span class="hljs-built_in">evaluation</span>(net, valid_dataset, criterion, save_dir=None)<br><br>        # **************** save loss for one batch ****************<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;train_epoch_loss &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>(train_loss) / (<span class="hljs-built_in">len</span>(train_loss) * <span class="hljs-number">1.0</span>)) )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;valid_epoch_loss &#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>(valid_loss) / (<span class="hljs-built_in">len</span>(valid_loss) * <span class="hljs-number">1.0</span>)) )<br><br>        # **************** save model ****************<br>        if current_score &gt; score_max:  # 验证集表现更好则保存当前模型<br>            best_epoch = epoch<br>            torch.<span class="hljs-built_in">save</span>(net.<span class="hljs-built_in">state_dict</span>(),<br>                       os.path.<span class="hljs-built_in">join</span>(save_dir , <span class="hljs-string">&#x27;best_epoch.pth&#x27;</span>))<br>            score_max = current_score<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;valid_meanIoU_max &#x27;</span> + <span class="hljs-built_in">str</span>(score_max))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Current Best epoch is %d&#x27;</span> % best_epoch)<br><br>        if epoch == epochs:  # 训练结束<br>            torch.<span class="hljs-built_in">save</span>(net.<span class="hljs-built_in">state_dict</span>(),<br>                       os.path.<span class="hljs-built_in">join</span>(save_dir, <span class="hljs-string">&#x27;final_epoch.pth&#x27;</span>))<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Best epoch is %d&#x27;</span> % best_epoch)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;done!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>网络实现：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs nix">class LSTM_MMUnet(nn.Module):<br>    def __init__(self, <span class="hljs-attr">input_nc=1,</span> <span class="hljs-attr">output_nc=5,</span> <span class="hljs-attr">ngf=32,</span> <span class="hljs-attr">temporal=3):</span><br>        super(LSTM_MMUnet, self).__init__()<br>        self.<span class="hljs-attr">temporal</span> = temporal<br>        self.<span class="hljs-attr">mmunet</span> = MMUnet(input_nc, output_nc, ngf)<br>        self.<span class="hljs-attr">lstm0</span> = LSTM0(<span class="hljs-attr">in_c=output_nc</span> , <span class="hljs-attr">ngf=ngf)</span><br>        self.<span class="hljs-attr">lstm</span> = LSTM(<span class="hljs-attr">in_c=output_nc</span> , <span class="hljs-attr">ngf=ngf)</span><br><br>        self.<span class="hljs-attr">mmout</span> = nn.Conv2d(ngf, output_nc, <span class="hljs-attr">kernel_size=3,</span> <span class="hljs-attr">stride=1,</span> <span class="hljs-attr">padding=1)</span><br>        self.<span class="hljs-attr">out</span> = nn.Conv2d(ngf, output_nc, <span class="hljs-attr">kernel_size=3,</span> <span class="hljs-attr">stride=1,</span> <span class="hljs-attr">padding=1)</span><br><br>    def forward(self, x):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        :param x:  5D tensor    bz * temporal * 4 * 240 * 240</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-attr">output</span> = []<br>        <span class="hljs-attr">mm_output</span> = []<br>        <span class="hljs-attr">cell</span> = None<br>        <span class="hljs-attr">hide</span> = None<br>        for t <span class="hljs-keyword">in</span> range(self.temporal):<br>            <span class="hljs-attr">im_t</span> = x[:, t, :, :, :]                <span class="hljs-comment"># bz * 4 * 240 * 240</span><br>            <span class="hljs-attr">mm_last</span> = self.mmunet(im_t)              <span class="hljs-comment"># bz * 32 * 240 * 240</span><br>            <span class="hljs-attr">out_t</span> = self.mmout(mm_last)              <span class="hljs-comment"># bz * 5 * 240 * 240</span><br>            mm_output.append(out_t)<br>            <span class="hljs-attr">lstm_in</span> = torch.cat((out_t, mm_last), <span class="hljs-attr">dim=1)</span> <span class="hljs-comment"># bz * 37 * 240 * 240</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-attr">t</span> == <span class="hljs-number">0</span>:<br>                cell, <span class="hljs-attr">hide</span> = self.lstm0(lstm_in)   <span class="hljs-comment"># bz * ngf(32) * 240 * 240</span><br>            <span class="hljs-keyword">else</span>:<br>                cell, <span class="hljs-attr">hide</span> = self.lstm(lstm_in, cell, hide)<br><br>            <span class="hljs-attr">out_t</span> = self.out(hide)<br>            output.append(out_t)<br><br>        return torch.stack(mm_output, <span class="hljs-attr">dim=1),</span> torch.stack(output, <span class="hljs-attr">dim=1)</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/25493370/answer/30886921">T1WI和T2WI的实际上是对什么的加权？</a><br><a href="https://arxiv.org/abs/2004.10664v1">A review: Deep learning for medical image segmentation using multi-modality fusion</a><br><a href="https://zhuanlan.zhihu.com/p/117435908">分割常用评价指标Dice、Hausdorff_95、IOU、PPV等</a></p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
      <tag>论文阅读</tag>
      
      <tag>研究方向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(7.24-7.30)</title>
    <link href="/2021/07/28/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-24-7-30/"/>
    <url>/2021/07/28/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-24-7-30/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/3sum/">leetcode_15_三数之和</a><br>思路：</p><ul><li>要保证结果不重复，就要第二重循环枚举到的元素不小于当前第一重循环枚举到的元素，第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。保证三元组以从小到大的顺序被枚举到。</li><li>对每一重循环而言，相邻两次枚举的元素也不能相同。</li><li>因为a+b=-c,所以第二和三重循环具有并列关系，可以用双指针进行简化。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def threeSum(self, nums):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> num<span class="hljs-variable">s:</span> List[<span class="hljs-keyword">int</span>]<br>        :rtype: List[List[<span class="hljs-keyword">int</span>]]<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br><br>        nums.<span class="hljs-keyword">sort</span>()<br>        <span class="hljs-keyword">res</span> = []<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">left</span> in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">left</span> &gt; <span class="hljs-number">0</span> <span class="hljs-built_in">and</span> nums[<span class="hljs-keyword">left</span>] == nums[<span class="hljs-keyword">left</span>-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            target = -nums[<span class="hljs-keyword">left</span>]<br>            <span class="hljs-keyword">right</span> = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> mid in <span class="hljs-built_in">range</span>(<span class="hljs-keyword">left</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                <span class="hljs-keyword">if</span> mid &gt; <span class="hljs-keyword">left</span> + <span class="hljs-number">1</span> <span class="hljs-built_in">and</span> nums[mid] == nums[mid-<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">while</span> nums[mid] + nums[<span class="hljs-keyword">right</span>] &gt; target <span class="hljs-built_in">and</span> <span class="hljs-keyword">right</span> &gt; mid:<br>                    <span class="hljs-keyword">right</span> -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">right</span> &lt;= mid:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> nums[mid] + nums[<span class="hljs-keyword">right</span>] == targe<span class="hljs-variable">t:</span><br>                    <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>([nums[<span class="hljs-keyword">left</span>], nums[mid], nums[<span class="hljs-keyword">right</span>]])<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/15.png" alt="15"></p><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">leetcode_26_删除有序数组中的重复项</a><br>思路：</p><ul><li>用一个变量维护不同元素的个数</li><li>每次遇到不同的元素，就把该元素插入到已有的不同元素的后一位，然后维护的个数+1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        insert = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] != nums[i-<span class="hljs-number">1</span>]:<br>                nums[insert] = nums[i]<br>                insert += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> insert<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/26.png" alt="26"></p><p><a href="https://leetcode-cn.com/problems/remove-element/">leetcode_27_</a><br>思路：</p><ul><li>用一个变量维护当前长度</li><li>遍历数组，每次不是目标值的时候，把当前数字和当前长度+1位置的数值对调，然后当前长度+1</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">removeElement</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">nums</span>, <span class="hljs-symbol">val</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">nums: <span class="hljs-symbol">List</span></span>[<span class="hljs-symbol">int</span>]<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">val: <span class="hljs-symbol">int</span></span><br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">int</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">flag</span> = <span class="hljs-symbol">0</span><br>        <span class="hljs-symbol">for</span> <span class="hljs-symbol">i</span> <span class="hljs-symbol">in</span> <span class="hljs-symbol">range</span>(<span class="hljs-symbol">len</span>(<span class="hljs-symbol">nums</span>)):<br>            <span class="hljs-symbol">if</span> <span class="hljs-symbol">nums</span>[<span class="hljs-symbol">i</span>] != <span class="hljs-symbol">val:</span><br>                <span class="hljs-symbol">if</span> <span class="hljs-symbol">flag</span> != <span class="hljs-symbol">i:</span><br>                    <span class="hljs-symbol">nums</span>[<span class="hljs-symbol">i</span>], <span class="hljs-symbol">nums</span>[<span class="hljs-symbol">flag</span>] = <span class="hljs-symbol">nums</span>[<span class="hljs-symbol">flag</span>], <span class="hljs-symbol">nums</span>[<span class="hljs-symbol">i</span>]<br>                <span class="hljs-symbol">flag</span> += <span class="hljs-symbol">1</span><br>        <span class="hljs-symbol">return</span> <span class="hljs-symbol">flag</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/27.png" alt="27"></p><p><a href="https://leetcode-cn.com/problems/is-subsequence/">leetcode_392_判断子序列</a><br>思路：</p><ul><li>用两个指针分别遍历s和t</li><li>若s是t的子序列，同时遍历的话应该s先遍历完（或者同时遍历完）</li><li>如果不是以上情况退出循环说明s没有遍历完，返回False<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubsequence</span>(<span class="hljs-params">self, s, t</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        flags = <span class="hljs-number">0</span><br>        flagt = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">while</span> flags &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> flagt &lt; <span class="hljs-built_in">len</span>(t):<br>            <span class="hljs-keyword">if</span> s[flags] == t[flagt]:<br>                <span class="hljs-keyword">if</span> flags == <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>                flags += <span class="hljs-number">1</span><br>            flagt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><img src="/img/code_sub/392.png" alt="392"></li></ul><p><a href="https://leetcode-cn.com/problems/string-compression/">leetcode_443_压缩字符串</a><br>思路：</p><ul><li>最麻烦的地方感觉是处理最后一个字符，所以首先在字符串最后加入一个不会混淆的字符来解决</li><li>后续思路比较清晰，一个字符就继续遍历，两个以上就改为数字，超过十个要特殊处理即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compress</span>(<span class="hljs-params">self, chars</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type chars: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chars:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(chars) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        chars.append(<span class="hljs-built_in">chr</span>(<span class="hljs-number">188</span>))<br>        flag = <span class="hljs-number">1</span> <span class="hljs-comment">#遍历位置</span><br>        index = <span class="hljs-number">0</span> <span class="hljs-comment"># 有效位置</span><br>        same_num = <span class="hljs-number">0</span> <span class="hljs-comment"># 当前字符的开始位置</span><br>        <span class="hljs-keyword">while</span> flag &lt; <span class="hljs-built_in">len</span>(chars):<br>            <span class="hljs-keyword">if</span> chars[flag] != chars[flag-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> flag - <span class="hljs-number">1</span> - same_num &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 多个相同字符</span><br>                    chars[index] = chars[same_num]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(flag-same_num)) &gt; <span class="hljs-number">1</span>: <span class="hljs-comment"># 10个以上相同字符</span><br>                        index += <span class="hljs-number">1</span><br>                        tmp = <span class="hljs-built_in">str</span>(flag-same_num)<br>                        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> tmp:<br>                            chars[index] = ch<br>                            index += <span class="hljs-number">1</span><br>                        same_num = flag<br>                    <span class="hljs-keyword">else</span>:<br>                        chars[index+<span class="hljs-number">1</span>] = <span class="hljs-built_in">str</span>(flag-same_num)<br>                        index += <span class="hljs-number">2</span><br>                        same_num = flag<br>                <span class="hljs-keyword">elif</span> flag - <span class="hljs-number">1</span> - same_num == <span class="hljs-number">0</span>: <span class="hljs-comment"># 只有一个字符</span><br>                    chars[index] = chars[same_num]<br>                    index += <span class="hljs-number">1</span><br>                    same_num = flag<br>            flag += <span class="hljs-number">1</span><br><br><br>        <span class="hljs-keyword">return</span> index<br></code></pre></td></tr></table></figure><img src="/img/code_sub/443.png" alt="443"></li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问题笔记</title>
    <link href="/2021/07/23/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/07/23/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一些自己老是忘的小问题。<br> <span id="more"></span> </p></blockquote><h2 id="范数的问题"><a href="#范数的问题" class="headerlink" title="范数的问题"></a>范数的问题</h2><p>向量范数：</p><ul><li>1-范数：$$\Vert x\Vert_1=\sum_{i=1}^{n}|x_i|$$<br>向量元素绝对值之和。</li><li>2-范数：$$\Vert x\Vert_2=\sqrt{\sum_{i=1}^{n}x_i^2}$$<br>Euclid范数（欧几里得范数，常用计算向量长度），即向量元素绝对值的平方和再开方。</li><li>$\infty$-范数：$$\Vert x\Vert_{\infty}=\mathop{max}\limits_{i}|x_i|$$<br>即所有向量元素绝对值中的最大值。</li></ul><p>参考：<a href="https://www.zhihu.com/question/20473040">0 范数、1 范数、2 范数有什么区别？</a></p><h2 id="各种距离的问题"><a href="#各种距离的问题" class="headerlink" title="各种距离的问题"></a>各种距离的问题</h2><p><a href="https://www.zhihu.com/question/27903807?sort=created">欧式空间</a>：欧几里得空间就是在对现实空间的规则抽象和推广（从n&lt;=3推广到有限n维空间）</p><p><img src="/images/pasted-0.png" alt="九种常用距离"></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/350744027">数据科学中常见的9种距离度量方法，内含欧氏距离、切比雪夫距离等</a></p><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><p>创建环境：conda create -n env_name python=3.6</p><p>requirements.txt用来记录需要哪些依赖库。<br>生成: pip freeze &gt; requirements.txt<br>导入: pip install -r requirements.txt</p><h2 id="CNN的理解"><a href="#CNN的理解" class="headerlink" title="CNN的理解"></a>CNN的理解</h2><p>卷积核的层数等于输入通道数。<br>卷积核的个数等于输出通道数。</p><h2 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h2><p>定义：感受野被定义为卷积神经网络特征所能看到输入图像的区域，换句话说特征输出受感受野区域内的像素点的影响。</p><p><img src="/images/pasted-4.png" alt="计算公式"><br>比如下图（该图为了方便，将二维简化为一维），这个三层的神经卷积神经网络，每一层卷积核的kernel size=3,步长stride=1，那么最上层特征所对应的感受野就为如图所示的7x7。<br><img src="/images/pasted-5.png" alt="感受野示例"></p><p><a href="https://arxiv.org/pdf/1701.04128v1.pdf">Understanding the Effective Receptive Field in Deep Convolutional Neural Networks</a><br><a href="https://zhuanlan.zhihu.com/p/40267131">关于感受野的总结</a></p><h2 id="目标函数与损失函数"><a href="#目标函数与损失函数" class="headerlink" title="目标函数与损失函数"></a>目标函数与损失函数</h2><p>目标函数是最终需要优化的函数，其中包括经验损失和结构损失：</p><p>经验损失(loss)就是传说中的损失函数或者代价函数。结构损失(Ω)就是正则项之类的来控制模型复杂程度的函数。</p><p><a href="https://www.zhihu.com/question/52398145/answer/209145104">参考</a></p><h2 id="python常用的函数"><a href="#python常用的函数" class="headerlink" title="python常用的函数"></a>python常用的函数</h2><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter是一个容器，用于跟踪添加相等值的次数。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> *<br><br>counter = Counter(<span class="hljs-string">&#x27;abcdefgg&#x27;</span>)<br>counter<br>counter[<span class="hljs-string">&#x27;a&#x27;</span>]<br>counter.<span class="hljs-keyword">update</span>(<span class="hljs-string">&#x27;aaaaaaaaaaaaaaaa&#x27;</span>)<br>counter<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 1, <span class="hljs-string">&#x27;c&#x27;</span>: 1, <span class="hljs-string">&#x27;d&#x27;</span>: 1, <span class="hljs-string">&#x27;e&#x27;</span>: 1, <span class="hljs-string">&#x27;f&#x27;</span>: 1, <span class="hljs-string">&#x27;g&#x27;</span>: 2&#125;)</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;1</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: 17, <span class="hljs-string">&#x27;b&#x27;</span>: 1, <span class="hljs-string">&#x27;c&#x27;</span>: 1, <span class="hljs-string">&#x27;d&#x27;</span>: 1, <span class="hljs-string">&#x27;e&#x27;</span>: 1, <span class="hljs-string">&#x27;f&#x27;</span>: 1, <span class="hljs-string">&#x27;g&#x27;</span>: 2&#125;)</span><br></code></pre></td></tr></table></figure><p>排序：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">s = sorted(<span class="hljs-name">counter</span>.items(),key=lambda x<span class="hljs-symbol">:x</span>[<span class="hljs-number">0</span>])<br>s<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&gt;&gt;&gt;<span class="hljs-selector-attr">[(<span class="hljs-string">&#x27;a&#x27;</span>, 17), (<span class="hljs-string">&#x27;b&#x27;</span>, 1), (<span class="hljs-string">&#x27;c&#x27;</span>, 1), (<span class="hljs-string">&#x27;d&#x27;</span>, 1), (<span class="hljs-string">&#x27;e&#x27;</span>, 1), (<span class="hljs-string">&#x27;f&#x27;</span>, 1), (<span class="hljs-string">&#x27;g&#x27;</span>, 2)]</span><br></code></pre></td></tr></table></figure><h3 id="deque-—-Double-Ended-Queue"><a href="#deque-—-Double-Ended-Queue" class="headerlink" title="deque — Double-Ended Queue"></a>deque — Double-Ended Queue</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">d</span> = collections.deque(<span class="hljs-string">&#x27;abcdefg&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">deque</span><span class="hljs-params">([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>defaultdict当修改未初始化的key-value时，会用默认值替换，其他功能与dict相同</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>=defaultdict(list)         <span class="hljs-comment"># list&#x27;s default value is []</span><br><span class="hljs-keyword">a</span>[<span class="hljs-string">&quot;first&quot;</span>].append(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>OrderedDict 可以理解为有序的dict，底层源码是通过双向链表来实现，每一个元素为一个map存储key-value。</p><p><a href="https://www.jianshu.com/p/f2a429aa5963">参考</a></p><h2 id="递归和迭代的区别"><a href="#递归和迭代的区别" class="headerlink" title="递归和迭代的区别"></a>递归和迭代的区别</h2><p>递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(7.17-7.23)</title>
    <link href="/2021/07/22/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-17-7-23/"/>
    <url>/2021/07/22/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-17-7-23/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/longest-palindrome/">leetcode_409_最长回文串</a><br>思路：</p><ul><li>回文串长度与每个字母的个数有关，首先用counter进行计数</li><li>每个字母每出现两次，回文串长度就+2（首尾各一个）</li><li>回文串最中间可以是单个字母，所以只要有任意字母个数不是2的倍数，总数就再+1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">longestPalindrome</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">s</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">s: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">int</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">res</span> = <span class="hljs-symbol">0</span><br>        <span class="hljs-symbol">add</span> = <span class="hljs-symbol">0</span><br>        <span class="hljs-symbol">counter</span> = <span class="hljs-symbol">Counter</span>(<span class="hljs-symbol">list</span>(<span class="hljs-symbol">s</span>))<br>        <span class="hljs-symbol">for</span> <span class="hljs-symbol">chrs</span> <span class="hljs-symbol">in</span> <span class="hljs-symbol">counter:</span><br>            <span class="hljs-symbol">if</span> <span class="hljs-symbol">counter</span>[<span class="hljs-symbol">chrs</span>] % <span class="hljs-symbol">2</span> != <span class="hljs-symbol">0:</span><br>                <span class="hljs-symbol">add</span> = <span class="hljs-symbol">1</span><br>            <span class="hljs-symbol">res</span> += (<span class="hljs-symbol">counter</span>[<span class="hljs-symbol">chrs</span>] // <span class="hljs-symbol">2</span>) * <span class="hljs-symbol">2</span><br>        <span class="hljs-symbol">return</span> <span class="hljs-symbol">res</span>+<span class="hljs-symbol">add</span><br></code></pre></td></tr></table></figure><img src="/img/code_sub/409.png" alt="409"></li></ul><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">leetcode_680_验证回文字符串 Ⅱ</a><br>思路：</p><ul><li>通过双指针从头尾向中间遍历</li><li>头尾相同则继续遍历，若第一次出现不同，可以删除一次，此时结果为删除头或者删除尾能构成回文串的结果</li><li>因为要进行一次递归调用，所以用函数实现<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">ss</span>):</span><br>            low = <span class="hljs-number">0</span> <br>            high = <span class="hljs-built_in">len</span>(ss) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(low &lt; high):<br>                <span class="hljs-keyword">if</span> ss[low] != ss[high]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                low += <span class="hljs-number">1</span><br>                high -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span>(left &lt;= right):<br>            <span class="hljs-keyword">if</span> s[left] == s[right]:<br>                left += <span class="hljs-number">1</span><br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> isValid(s[left+<span class="hljs-number">1</span>:right+<span class="hljs-number">1</span>]) <span class="hljs-keyword">or</span> isValid(s[left:right])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><img src="/img/code_sub/680.png" alt="680"></li></ul><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">leetcode_738_单调递增的数字</a><br>思路：</p><ul><li>从高向低遍历数字每个数位，满足递增条件则遍历下一位</li><li>观察数字特点，发现若不满足时，只需要将当前位-1,后面全部变成9即可</li><li>因为当前数字-1，需要回到上一位继续遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monotoneIncreasingDigits</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(n))<br>        length = <span class="hljs-built_in">len</span>(s)<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; length - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> s[i] &lt;= s[i+<span class="hljs-number">1</span>]:<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                s[i] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(s[i])-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, length):<br>                    s[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>                i = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;&quot;</span>.join(s))<br></code></pre></td></tr></table></figure><img src="/img/code_sub/738.png" alt="738"></li></ul><p><a href="https://leetcode-cn.com/problems/partition-labels/">leetcode_763_划分字母区间</a><br>思路：<br>寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。由于每个片段访问结束的标志是访问到字母最后出现的下标，因此对于每个片段，可以保证当前片段中的每个字母都一定在当前片段中，不可能出现在其他片段，可以保证同一个字母只会出现在同一个片段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        last = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            last[<span class="hljs-built_in">ord</span>(ch)-<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] = i<br>        <br>        start, end = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        res = []<br>        <span class="hljs-keyword">for</span> i, ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            end = <span class="hljs-built_in">max</span>(end, last[<span class="hljs-built_in">ord</span>(ch)-<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)])<br>            <span class="hljs-keyword">if</span> end == i:<br>                res.append(end - start + <span class="hljs-number">1</span>)<br>                start = end + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/763.png" alt="763"></p><p><a href="https://leetcode-cn.com/problems/lemonade-change/submissions/">leetcode_860_柠檬水找零</a><br>思路：</p><ul><li>如果给的5块，5块总数+1</li><li>如果不是，那么找零5或者15。首先去掉一个5块。</li><li>如果还要找10块，首先有十块找十块，没有就找两个五块。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lemonadeChange</span>(<span class="hljs-params">self, bills</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bills: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        five = <span class="hljs-number">0</span><br>        ten = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> bills:<br>            pay = bills.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> pay == <span class="hljs-number">5</span>:<br>                five += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> five:<br>                    five -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> pay &gt; <span class="hljs-number">10</span>:<br>                    <span class="hljs-keyword">if</span> ten:<br>                        ten -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">if</span> five &gt; <span class="hljs-number">1</span>:<br>                            five -= <span class="hljs-number">2</span><br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    ten += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><img src="/img/code_sub/860.png" alt="860"></li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(7.10-7.16)</title>
    <link href="/2021/07/16/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-10-7-16/"/>
    <url>/2021/07/16/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-7-10-7-16/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">leetcode_94_二叉树的中序遍历</a><br>思路：</p><ul><li>普通的二叉树遍历，X序遍历就是指的根的位置，比如中序就是把根放中间，用“左根右”的方式遍历;</li><li>可以用递归的方式实现，先遍历左子树，然后输出根的值，然后遍历右子树，前序后续同理，只是顺序不同<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorderTraversal</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inOrder</span>(<span class="hljs-params">root</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span><br>            inOrder(root.left)<br>            res.append(root.val)<br>            inOrder(root.right)<br>        inOrder(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><img src="/img/code_sub/94.png" alt="94"></li></ul><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode_98_验证二叉搜索树</a><br>思路：<br>因为二叉搜索树具有重要的性质，即左子树小于根，右子树大于根，所以本题我的思路就是进行中序遍历，然后判断是否是递增数列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidBST</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inOrder</span>(<span class="hljs-params">root</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>                <span class="hljs-keyword">return</span> <br>            inOrder(root.left)<br>            res.append(root.val)<br>            inOrder(root.right)<br>        inOrder(root)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> res[i]-res[i+<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/98.png" alt="98"></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">leetcode_104_二叉树的最大深度</a><br>思路：<br>用了一种广度优先搜索的方法来实现，依次判断每一层有没有节点，有节点就用队列来保存，然后深度加1,直到队列为空，输出最终的深度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = [root]<br>        depth = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> queue:<br>            depth += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    queue.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    queue.append(node.right)<br><br>        <span class="hljs-keyword">return</span> depth<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/104.png" alt="104"></p><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">leetcode_113_路径总和 II</a><br>思路：<br>这一题首先用深度优先搜索的思路实现：用一个list维护结果，一个list维护当前的路径;当同时满足和为target而且是叶子节点就输出当前的list，否则继续按照深度优先搜索的方法进行搜索，搜索完右节点就进行回溯。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def pathSum(self, root, targetSum):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> roo<span class="hljs-variable">t:</span> TreeNode<br>        :<span class="hljs-built_in">type</span> targetSum: <span class="hljs-keyword">int</span><br>        :rtype: List[List[<span class="hljs-keyword">int</span>]]<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        <span class="hljs-keyword">res</span> = []<br>        current = []<br>        def dfs(root, target):<br>            <span class="hljs-keyword">if</span> not roo<span class="hljs-variable">t:</span><br>                <span class="hljs-keyword">return</span> <br>            current.<span class="hljs-keyword">append</span>(root.val)<br>            target -= root.val<br>            <span class="hljs-keyword">if</span> not root.<span class="hljs-keyword">left</span> <span class="hljs-built_in">and</span> not root.<span class="hljs-keyword">right</span> <span class="hljs-built_in">and</span> target == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(current[:])<br>            dfs(root.<span class="hljs-keyword">left</span>, target)<br>            dfs(root.<span class="hljs-keyword">right</span>, target)<br>            current.<span class="hljs-keyword">pop</span>()<br>        dfs(root, targetSum)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/113.png" alt="113"></p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/">leetcode_235_二叉搜索树的最近公共祖先</a><br>思路：<br>本题的思路也比较简单，就是从root开始遍历，如果有更近的公共祖先，那么pq就应该偏在当前节点的一边，就继续往下遍历，直到一大一小之后输出即可。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def lowestCommonAncestor(self, root, <span class="hljs-keyword">p</span>, q):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> roo<span class="hljs-variable">t:</span> TreeNode<br>        :<span class="hljs-built_in">type</span> <span class="hljs-keyword">p</span>: TreeNode<br>        :<span class="hljs-built_in">type</span> q: TreeNode<br>        :rtype: TreeNode<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        <span class="hljs-keyword">res</span> = root<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">res</span>.val &gt; <span class="hljs-keyword">p</span>.val <span class="hljs-built_in">and</span> <span class="hljs-keyword">res</span>.val &gt; q.va<span class="hljs-variable">l:</span><br>                <span class="hljs-keyword">res</span> = <span class="hljs-keyword">res</span>.<span class="hljs-keyword">left</span><br>            elif <span class="hljs-keyword">res</span>.val &lt; <span class="hljs-keyword">p</span>.val <span class="hljs-built_in">and</span> <span class="hljs-keyword">res</span>.val &lt; q.va<span class="hljs-variable">l:</span><br>                <span class="hljs-keyword">res</span> = <span class="hljs-keyword">res</span>.<span class="hljs-keyword">right</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/235.png" alt="235"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(7.3-7.9)</title>
    <link href="/2021/07/09/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81%EF%BC%887-3-7-9%EF%BC%89/"/>
    <url>/2021/07/09/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81%EF%BC%887-3-7-9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">leetcode_53_最大子序和</a><br>思路：<br>动态规划的题目我比较习惯的三个步骤是：规定dp数组的含义，找出数组元素之间的关系式，找出初始值，用这个思路来解决后面的问题。</p><ul><li>因为问题求解最大子序列，定义dp[i]保存前n项的最大子序</li><li>可以发现dp[i]的值要么是dp[i-1]加上当前的值，要么前面是负数直接舍弃</li><li>定义dp[0]=0</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/53.png" alt="53"></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/">leetcode_121_买卖股票的最佳时机</a><br>思路：</p><ul><li>定义dp[i]保存前i天的最大收益</li><li>用一个数组来记录前i天最小的买的花费，那么dp[i]就是前dp[i-1]和当天价格减去前i-1天最小花费的最大值</li><li>dp[0]=0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prices: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(prices)<br>        min_cost = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(prices)<br>        min_cost[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            min_cost[i] = <span class="hljs-built_in">min</span>(min_cost[i-<span class="hljs-number">1</span>], prices[i])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], prices[i]-min_cost[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><img src="/img/code_sub/121.png" alt="121"></li></ul><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">leetcode_122_买卖股票的最佳时机 II</a><br>思路：<br>这道题的区别在于没有买卖次数限制，所以直接用贪心算法即可，把所有能赚钱的区间都加起来就是答案。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">res</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>    <span class="hljs-keyword">res</span> += <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, prices[i]- prices[i-<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><p>当然也可以用动态规划实现，主要区别在于用二维数组实现，同时保存现在的状态（待买还是待卖）：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp = <span class="hljs-comment">[<span class="hljs-comment">[0]</span> * 2]</span> * len(prices)<br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = 0, -prices<span class="hljs-comment">[0]</span><br>for i in range(len(prices)):<br>    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, prices<span class="hljs-comment">[i]</span>+dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>)<br>    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>-prices<span class="hljs-comment">[i]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>)<br>return max(dp<span class="hljs-comment">[len(prices)-1]</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/122.png" alt="122"></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">leetcode_123_买卖股票的最佳时机 III</a><br>思路：<br>这道题的主要难点在于可以买卖两次，我的思路是设计了五个数组，代表五个状态，代表当天是没有买，买了一次，卖了一次，买了两次，卖了两次，然后依次进行状态转移</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nobuy = <span class="hljs-comment">[0]</span> * len(prices)<br>buy1 = <span class="hljs-comment">[0]</span> * len(prices)<br>sell1 = <span class="hljs-comment">[0]</span> * len(prices)<br>buy2 = <span class="hljs-comment">[0]</span> * len(prices)<br>sell2 = <span class="hljs-comment">[0]</span> * len(prices)<br>buy1<span class="hljs-comment">[0]</span> = -prices<span class="hljs-comment">[0]</span><br>buy2<span class="hljs-comment">[0]</span> = -prices<span class="hljs-comment">[0]</span><br>for i in range(1, len(prices)):<br>    nobuy<span class="hljs-comment">[i]</span> = nobuy<span class="hljs-comment">[i-1]</span><br>    buy1<span class="hljs-comment">[i]</span> = max(buy1<span class="hljs-comment">[i-1]</span>, nobuy<span class="hljs-comment">[i-1]</span>-prices<span class="hljs-comment">[i]</span>)<br>    sell1<span class="hljs-comment">[i]</span> = max(buy1<span class="hljs-comment">[i-1]</span> + prices<span class="hljs-comment">[i]</span>, sell1<span class="hljs-comment">[i-1]</span>)<br>    buy2<span class="hljs-comment">[i]</span> = max(buy2<span class="hljs-comment">[i-1]</span>, sell1<span class="hljs-comment">[i-1]</span>-prices<span class="hljs-comment">[i]</span>)<br>    sell2<span class="hljs-comment">[i]</span> = max(sell2<span class="hljs-comment">[i-1]</span>, buy2<span class="hljs-comment">[i-1]</span>+prices<span class="hljs-comment">[i]</span>)<br>return max(nobuy<span class="hljs-comment">[len(prices)-1]</span>, sell1<span class="hljs-comment">[len(prices)-1]</span>,sell2<span class="hljs-comment">[len(prices)-1]</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/123.png" alt="123"></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">leetcode_188_买卖股票的最佳时机 IV</a><br>思路：<br>有上一题的基础后这一题就比较简单了，直接用一个for循环来处理k就行了。<br>注意到上一题的第一个状态其实没必要，每一次买卖设计两个状态就可以处理所有状态了。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">        if k &lt; 1 or not prices:<br>            return 0<br>        buy = <span class="hljs-comment">[<span class="hljs-comment">[0]</span> * k]</span> * len(prices)<br>        sell = <span class="hljs-comment">[<span class="hljs-comment">[0]</span> * k]</span> * len(prices)<br>        for i in range(k):<br>            buy<span class="hljs-comment">[0]</span><span class="hljs-comment">[i]</span> = -prices<span class="hljs-comment">[0]</span><br>        for i in range(1, len(prices)):<br>            for j in range(k):<br>                buy<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, -prices<span class="hljs-comment">[i]</span>) if j == 0 else max(buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>-prices<span class="hljs-comment">[i]</span>)<br>                sell<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = max(sell<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, buy<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>+prices<span class="hljs-comment">[i]</span>)<br>        return max(max(<span class="hljs-comment">[a for a in buy<span class="hljs-comment">[len(prices)-1]</span>]</span>), max(<span class="hljs-comment">[a for a in sell<span class="hljs-comment">[len(prices)-1]</span>]</span>))<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/188.png" alt="188"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.26-7.3)</title>
    <link href="/2021/07/01/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-26-7-3/"/>
    <url>/2021/07/01/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-26-7-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode_150_逆波兰表达式求值</a><br>思路：</p><ul><li>观察题目中所谓的拟波兰表达式求值方法，在每次遇到算符的时候明显有后进先出的数据结构，因此考虑用栈来实现;</li><li>单独用一个数组实现堆栈功能，维护依次输入的数字，每次遇到算符时取出堆栈顶的数字，根据算符进行计算</li><li>因为python2和python3除法的区别， 在实现除法的时候容易出错，这里用的是python2,普通整数除法的结果只会取整数部分，所以要把除数转化为浮点数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalRPN</span>(<span class="hljs-params">self, tokens</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tokens: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        numbers = []<br>        cals = [<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>]<br>        <span class="hljs-keyword">while</span> tokens:<br>            current = tokens.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> current <span class="hljs-keyword">in</span> cals:<br>                num2 = numbers.pop()<br>                num1 = numbers.pop()<br>                <span class="hljs-keyword">if</span> current == <span class="hljs-string">&quot;+&quot;</span>:<br>                    numbers.append(num1+num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;-&quot;</span>:<br>                    numbers.append(num1-num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;*&quot;</span>:<br>                    numbers.append(num1*num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;/&quot;</span>:<br>                    numbers.append(<span class="hljs-built_in">int</span>(num1/<span class="hljs-built_in">float</span>(num2)))<br>            <span class="hljs-keyword">else</span>:<br>                numbers.append(<span class="hljs-built_in">int</span>(current))<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><img src="/img/code_sub/150.png" alt="150"></li></ul><p><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">leetcode_388_文件的最长绝对路径</a><br>思路：</p><ul><li>用\n来分割文件</li><li>用\t来对深度进行区分</li><li>把带有文件的目录进行整合，然后输出最长的<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def lengthLongestPath(self, <span class="hljs-built_in">input</span>):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> inpu<span class="hljs-variable">t:</span> str<br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">files</span> = <span class="hljs-built_in">input</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        levels = [sfile.<span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;\t&#x27;</span>) <span class="hljs-keyword">for</span> sfile in <span class="hljs-keyword">files</span>]<br>        paths = [sfile.replace(<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> sfile in <span class="hljs-keyword">files</span>]<br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(levels)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.&quot;</span> in paths[i]:<br>                sfile = paths[i]<br>                level = levels[i]<br>                order = i<br>                <span class="hljs-keyword">while</span> order &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> levels[order-<span class="hljs-number">1</span>] == level-<span class="hljs-number">1</span>:<br>                        sfile = paths[order-<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + sfile<br>                        level -= <span class="hljs-number">1</span><br>                    order -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(sfile)<br>        <span class="hljs-keyword">if</span> not re<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>([<span class="hljs-built_in">len</span>(<span class="hljs-keyword">file</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">res</span>])<br></code></pre></td></tr></table></figure><img src="/img/code_sub/388.png" alt="388"></li></ul><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">leetcode_557_反转字符串中的单词</a><br>思路：<br>这道题直接通过空格把单词分离，然后输出逆序单词合并之后的字符串即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        words = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>.join([a[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> words])<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/557.png" alt="557"></p><p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system/">leetcode_609_在系统中查找重复文件</a><br>思路：</p><ul><li>首先通过空格将不同的路径、文件分离，分离后的列表第一个数据是路径，后面是文件</li><li>因为要找到重复文件，还要用路径加文件名、文件内容的形式输出，所以考虑用字典结构来保存，即key值为文件名，value用list保存该文件名包含的路径</li><li>最后输出value长度大于一，即有重复文件的路径加文件名即可<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def findDuplicate(self, paths):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> path<span class="hljs-variable">s:</span> List[str]<br>        :rtype: List[List[str]]<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> path in path<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">files</span> = path.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>            addr = <span class="hljs-keyword">files</span>.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span><br>                content = <span class="hljs-keyword">file</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;txt(&quot;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>                filename = <span class="hljs-keyword">file</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">if</span> content in dic:<br>                    dic[content].<span class="hljs-keyword">append</span>(addr+<span class="hljs-string">&quot;/&quot;</span>+filename)<br>                <span class="hljs-keyword">else</span>:<br>                    dic[content] = [addr+<span class="hljs-string">&quot;/&quot;</span>+filename]<br><br>        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in dic.<span class="hljs-built_in">values</span>() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">file</span>) &gt; <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><img src="/img/code_sub/609.png" alt="609"></li></ul><p><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">leetcode_861_翻转矩阵后的得分</a><br>思路：</p><ul><li>首先要想到翻转的次序改变对不会改变最后的结果</li><li>要让数字总和最大，首先要让第一位都是1</li><li>对后面的数，每一列都可以看成离散的点，每一列让这样的点最多</li><li>最后转化成十进制计算总和即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matrixScore</span>(<span class="hljs-params">self, grid</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>                grid[i] = [<span class="hljs-number">1</span> - num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> grid[i]]<br>        <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            sumj = <span class="hljs-built_in">sum</span>([grid[i][j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))])<br>            <span class="hljs-keyword">if</span> sumj &lt; <span class="hljs-built_in">len</span>(grid)/<span class="hljs-number">2.0</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>                    grid[i][j] = <span class="hljs-number">1</span> - grid[i][j]<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            array = grid[i][::-<span class="hljs-number">1</span>]<br>            current = <span class="hljs-built_in">sum</span>([num*<span class="hljs-number">2</span>**j <span class="hljs-keyword">for</span> j,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array)), array)])<br>            res += current<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><img src="/img/code_sub/861.png" alt="861"></li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.19-6.25)</title>
    <link href="/2021/06/25/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-19-6-25/"/>
    <url>/2021/06/25/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-19-6-25/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">leetcode_804_唯一摩尔斯密码词</a><br>思路：首先字母和摩尔斯编码一一对应，可以用类似哈系表的方法进行转换即可；难点在于去掉重复的翻译，最开始写的方法复杂度都比较高，后来学到python里面可以用set函数来解决，不包含重复数据。</p><blockquote><p>set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniqueMorseRepresentations</span>(<span class="hljs-params">self, words</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type words: List[str]</span><br><span class="hljs-string">    :rtype: int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    Morse = [<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>]<br>    <br>    dicts = &#123;<span class="hljs-string">&quot;&quot;</span>.join(Morse[<span class="hljs-built_in">ord</span>(ch)-<span class="hljs-number">97</span>] <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> word) <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(dicts)<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/804.png" alt="804"></p><p><a href="https://leetcode-cn.com/problems/most-common-word/">leetcode_819_最常见的单词</a><br>思路：</p><ul><li>将句子拆分成单词</li><li>用字典保存出现次数，key是单词，value是次数，即未在字典出现就记一次，字典中存在则value加1</li><li>字典排序，输出第一个key不在banned里面的value</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">class</span> Solution(object):<br>    def mostCommonWord(self, <span class="hljs-built_in">paragraph</span>, banned):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        :type paragraph: str</span><br><span class="hljs-string">        :type banned: List[str]</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-built_in">paragraph</span> += &#x27; &#x27;<br>        <span class="hljs-built_in">words</span> = []<br>        <span class="hljs-literal">result</span> = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(<span class="hljs-built_in">paragraph</span>)):<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">paragraph</span>[i]&gt;=&#x27;a&#x27; <span class="hljs-keyword">and</span> <span class="hljs-built_in">paragraph</span>[i] &lt;= &#x27;z&#x27;) <span class="hljs-keyword">or</span> (<span class="hljs-built_in">paragraph</span>[i]&gt;=&#x27;A&#x27; <span class="hljs-keyword">and</span> <span class="hljs-built_in">paragraph</span>[i] &lt;= &#x27;Z&#x27;):<br>                <span class="hljs-built_in">words</span>.append(<span class="hljs-built_in">paragraph</span>[i].lower())<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">words</span>)<br>                <span class="hljs-built_in">words</span> = []<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">word</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">word</span> <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:<br>                    <span class="hljs-literal">result</span>[<span class="hljs-built_in">word</span>] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">word</span>:<br>                        <span class="hljs-literal">result</span>[<span class="hljs-built_in">word</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> (a,b) <span class="hljs-keyword">in</span> sorted(<span class="hljs-literal">result</span>.items(), key=lambda x: x[<span class="hljs-number">1</span>], <span class="hljs-built_in">reverse</span>=True):<br>            <span class="hljs-keyword">if</span> a.lower() <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> banned:<br><span class="hljs-built_in">                return</span> a.lower()<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/819.png" alt="819"></p><p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">leetcode_842_将数组拆分成斐波那契序列</a><br>思路：</p><ul><li>因为斐波那契数列从第三个数开始都是由前两个书求和得到，所以主体思路就是首先遍历前两个数可能的组成，然后判断剩下的数能否组成正确的数列</li><li>可以进行一定的剪枝优化，比如前两个数字的长度肯定不超过数组长度的1/3</li><li>题目要求的数字大小范围非常容易出错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitIntoFibonacci</span>(<span class="hljs-params">self, num</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        length = <span class="hljs-built_in">len</span>(num)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">3</span>):<br>                <span class="hljs-keyword">if</span> num[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> i&gt;<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> num[i] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> j&gt;<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                num1 = <span class="hljs-built_in">int</span>(num[:i])<br>                num2 = <span class="hljs-built_in">int</span>(num[i:i+j])<br>                <span class="hljs-keyword">if</span> num1 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> num2 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                g1 = num1<br>                g2 = num2<br>                res = [g1, g2]<br>                <span class="hljs-comment"># 前面首先确定前两个数，后面判断是否是正确的数列</span><br>                num3_flag = i+j<br>                <span class="hljs-keyword">if</span> num3_flag &gt; length-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">3</span>):<br>                    <span class="hljs-keyword">if</span> num[num3_flag] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> k&gt;<span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">while</span> num3_flag + k  &lt;= length:<br>                        num3 = <span class="hljs-built_in">int</span>(num[num3_flag:num3_flag+k])<br>                        <span class="hljs-keyword">if</span> num3 != num1 + num2 <span class="hljs-keyword">or</span> num3 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">else</span>:<br>                            res.append(num3)<br>                            <span class="hljs-keyword">if</span> num3_flag+k==length:<br>                                <span class="hljs-keyword">return</span> res<br>                            <span class="hljs-keyword">else</span>:<br>                                num1 = num2<br>                                num2 = num3<br>                                num3_flag += k<br>                res = [g1, g2]<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/842.png" alt="842"></p><p><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/">leetcode_1233_删除子文件夹</a><br>思路：<br>我觉得这道题最核心的思路是首先对文件夹列表进行排序，排序之后对有公共的头的文件夹，短的肯定在长的前面，因此可以依次判断，如果前一个文件夹不是后一个的头，那就肯定不是子文件夹，可以加入结果，并作为新的头，具体如下：</p><ul><li>文件夹列表排序</li><li>依次判断每一个文件夹，是否以上一个文件夹作为开头;</li><li>如果是，则是子文件夹，依序判断下一个;</li><li>如果不是，加入结果列表，更新文件夹头;</li><li>输出结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeSubfolders</span>(<span class="hljs-params">self, folder</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type folder: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        sort_folder = <span class="hljs-built_in">sorted</span>(folder)<br>        res = []<br>        begin = <span class="hljs-string">&#x27;init&#x27;</span><br>        <span class="hljs-keyword">for</span> folders <span class="hljs-keyword">in</span> sort_folder:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> folders.startswith(begin):<br>                begin = folders + <span class="hljs-string">&#x27;/&#x27;</span>  <span class="hljs-comment"># 解决/a/b/c,/a/b/ca判断错误的问题</span><br>                res.append(folders)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/1233.png" alt="1233"></p><p><a href="https://leetcode-cn.com/problems/making-file-names-unique/">leetcode_1487_保证文件名唯一</a><br>思路：</p><ul><li>同样可以用字典实现：key是文件夹名，value是出现次数 </li><li>遍历文件夹名，如果没有出现过，则加入字典，value记为1</li><li>如果已经出现过，则需要加括号，根据出现次数来确定括号内数字，并将新名称加入字典，同时原名称也需要+1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFolderNames</span>(<span class="hljs-params">self, names</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type names: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dic = &#123;&#125;<br>        res = []<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>            <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dic:<br>                dic[name] = <span class="hljs-number">1</span><br>                res.append(name)<br>            <span class="hljs-keyword">else</span>:<br>                curName = name + <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">str</span>(dic[name]) + <span class="hljs-string">&quot;)&quot;</span><br>                <span class="hljs-keyword">while</span> curName <span class="hljs-keyword">in</span> dic:<br>                    dic[name] += <span class="hljs-number">1</span><br>                    curName = name + <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">str</span>(dic[name]) + <span class="hljs-string">&quot;)&quot;</span><br>                dic[curName] = <span class="hljs-number">1</span><br>                dic[name] += <span class="hljs-number">1</span><br>                res.append(curName)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/1487.png" alt="1487"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-12-14章笔记</title>
    <link href="/2021/06/22/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-12-14%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/22/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-12-14%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吴恩达机器学习课程12-14章部分笔记<br> <span id="more"></span> </p></blockquote><h2 id="12-1-12-2-误差分析"><a href="#12-1-12-2-误差分析" class="headerlink" title="12.1-12.2 误差分析"></a>12.1-12.2 误差分析</h2><p><img src="/img/ML_WED_1214/12.2.1.png" alt="推荐的机器学习系统设计方法"></p><ul><li>首先花较短的时间(比如一天时间)非常简单地把整个系统流程实现出来，然后把添加更多数据，更多特征等的学习曲线画出来，这样可以直观的看出每种方法对效果的提升，而不是依靠直觉判断怎么设计系统。</li><li>误差分析：观察验证集上被错误分类的数据有没有什么共同特点，以此来获得优化的灵感</li><li>通过数值估计模型效果好坏<ul><li> 交叉验证使用和不使用某算法的效果</li></ul></li></ul><h2 id="12-3-不对称分类的误差评估"><a href="#12-3-不对称分类的误差评估" class="headerlink" title="12.3 不对称分类的误差评估"></a>12.3 不对称分类的误差评估</h2><p>偏斜类（skewed classes）中需要的评估指标：精确率和召回率 Precision/Recall</p><p>二分类常用的评价指标总结：</p><ul><li>正确率：$$\frac{TP+TN}{TP=FP+TN+FN}$$</li><li>召回率（正例被找出的比例）：$$\frac{TP}{TP+FN}$$</li><li>特异度（反例被找出的比例）：$$\frac{TN}{TN+FP}$$</li><li>精确率（被判断为正例的正确的比例）：$$\frac{TP}{TP+FP}$$</li><li>F1 score（兼顾精确率和召回率）：$$\frac{2}{\frac{1}{Precision}+\frac{1}{Recall}}$$</li><li>AUC：ROC曲线下面积</li></ul><h2 id="12-4-精确率和召回率的权衡"><a href="#12-4-精确率和召回率的权衡" class="headerlink" title="12.4 精确率和召回率的权衡"></a>12.4 精确率和召回率的权衡</h2><p><img src="/img/ML_WED_1214/12.4.1.png" alt="召回率和精确率的权衡"></p><blockquote><p>在实际应用中，根据不同的要求可以设计不同的分类阈值来提高精确率或者召回率，通常一个提高另一个会降低。<br>自动权衡召回率和精确率：F1 Score</p></blockquote><h2 id="12-5-机器学习数据"><a href="#12-5-机器学习数据" class="headerlink" title="12.5 机器学习数据"></a>12.5 机器学习数据</h2><p>获取更多数据可以获得效果良好的模型需要满足以下假设：</p><ul><li>假设数据中包含足够的信息来准确预测结果<ul><li>有效的测试方法是考虑人类专家能否从数据中的信息来准确预测结果</li></ul></li><li>使用具有许多参数的学习算法<ul><li>训练损失可以降到很小</li></ul></li><li>使用很大的训练集（不容易过拟合）<ul><li>测试误差可以接近训练误差</li></ul></li></ul><hr><h2 id="13-1-支持向量机优化目标"><a href="#13-1-支持向量机优化目标" class="headerlink" title="13.1 支持向量机优化目标"></a>13.1 支持向量机优化目标</h2><p><img src="/img/ML_WED_1214/13.1.1.png" alt="从逻辑回归的角度考虑支持向量机"><br>如图，用红色的损失函数代替逻辑回归蓝色的损失函数</p><p><img src="/img/ML_WED_1214/13.1.2.png" alt="支持向量机表示"></p><ul><li>去掉了$\frac{1}{m}$</li><li>用优化$CA+B$代替了逻辑回归优化$A+\lambda B$</li></ul><p><img src="/img/ML_WED_1214/13.1.3.png" alt="SVM损失函数"><br>SVM直接预测y=1或0</p><h2 id="13-2-大间隔优化器"><a href="#13-2-大间隔优化器" class="headerlink" title="13.2 大间隔优化器"></a>13.2 大间隔优化器</h2><p><img src="/img/ML_WED_1214/13.2.2.png" alt="SVM损失函数的安全间距"><br>SVM的决策边界和训练样本的最小距离要比其他方法更远，这个距离称为SVM的间距（Maragin），使SVM具有更好的鲁棒性<br><img src="/img/ML_WED_1214/13.2.3.png" alt="间距"><br><img src="/img/ML_WED_1214/13.2.1.png" alt="参数C的影响"><br>当C设置得非常非常大的时候，SVM会严重受到异常点的影响</p><h2 id="13-4-13-5-核函数"><a href="#13-4-13-5-核函数" class="headerlink" title="13.4-13.5 核函数"></a>13.4-13.5 核函数</h2><blockquote><p>问题描述：我们之前用x的高阶项作为特征，但我们并不知道这些特征是否是需要的，而且同时这种方法计算量也较大，因此是否存在更好的特征设计方法？<br><img src="/img/ML_WED_1214/13.4.1.png" alt="问题描述"></p></blockquote><p>方法：</p><ul><li>手工选择一些点(标记landmark)（$l^{(1)},l^{(2)},l^{(3)}$）</li><li>定义特征$f$为x和标记的相似度，相似度函数就是核函数，如高斯核函数:<br>$$f1=similarity(x,l^{(1)})=e^{-\frac{||x-l^{(1)}||^2}{2\sigma^2}}$$</li></ul><p><img src="/img/ML_WED_1214/13.4.2.png" alt="核函数和相似度"><br>可以看到，当x和选定的l很近时，f的取值接近1,反之接近0</p><p><img src="/img/ML_WED_1214/13.4.3.png" alt="核函数的例子"><br>以l取(3,5)为例，可以画出f的取值图像，如果所示纵坐标就是f的取值，在靠近l的时候取值接近1;可以通过改变$\sigma$的取值调节f的变化速度</p><p><img src="/img/ML_WED_1214/13.4.4.png" alt="决定决策边界"></p><p>如何选择这些标记l：<strong>直接将训练样本作为标记点</strong></p><ul><li>给出训练集$(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\cdots,(x^{(m)},y^{(m)})$</li><li>选择标记点$l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},\cdots,l^{(m)}=x^{(m)}$</li><li>计算相似度：$f_1=similarity(x,l^{(1)})\cdots$,得到特征向量$f^{(i)}=[f_1^{(i)},f_2^{(i)},\cdots,f_m^{(i)}]$</li><li>预测$y=1$,当$\theta^T f\geq 0$</li><li>计算使损失最小的参数\theta</li></ul><p>参数选择：</p><ul><li>$C(=\frac{1}{\lambda})$<ul><li>更大的C：低偏差，高方差（过拟合）</li><li>更小的C:低方差，高偏差（欠拟合）</li></ul></li><li>$ \sigma^2$<ul><li>更大：低方差，高偏差（欠拟合）</li><li>更小：低偏差，高方差（过拟合）<br><img src="/img/ML_WED_1214/13.5.1.png" alt="参数的选择"></li></ul></li></ul><h2 id="14-1-14-2-K-Means算法"><a href="#14-1-14-2-K-Means算法" class="headerlink" title="14.1-14.2 K-Means算法"></a>14.1-14.2 K-Means算法</h2><p>监督学习：有标签，通过损失函数去拟合<br>无监督学习：无标签，让算法找到隐含在数据中的结构</p><p>KMeans算法步骤：</p><ul><li>随机生成两点作为聚类中心</li><li>簇分配：遍历每个样本，根据每个点和聚类中心的距离，分配给更近的中心</li><li>移动聚类中心：将两个聚类中心移动到同类的中心处（没有点的聚类中心直接去掉）</li><li>重复第二步和第三步，直到聚类中心不再改变<br><img src="/img/ML_WED_1214/14.1.1.png" alt="K-Means聚类"><br><img src="/img/ML_WED_1214/14.1.2.png" alt="K-Means算法对分离不佳的簇表现良好"></li></ul><h2 id="14-3-优化目标"><a href="#14-3-优化目标" class="headerlink" title="14.3 优化目标"></a>14.3 优化目标</h2><p><img src="/img/ML_WED_1214/14.3.1.png" alt="优化目标"><br>其中簇分配的步骤通过优化c来最小化损失，移动聚类中心的步骤通过优化$\mu$来最小化损失</p><h2 id="14-4-随机初始化"><a href="#14-4-随机初始化" class="headerlink" title="14.4 随机初始化"></a>14.4 随机初始化</h2><p>随机生成聚类中心的方法：</p><ul><li>保证$K&lt;m$</li><li>随机选取K个训练样本</li><li>设置$\mu_1,\mu_2,\cdots,\mu_K$等于这K个样本</li></ul><p><img src="/img/ML_WED_1214/14.4.1.png" alt="K-Means可能陷入局部极小"><br>解决方法：多次随机初始化，并选取损失值最小的（尤其是K较小的时候更重要，比如$2&lt;k&lt;10$）</p><h2 id="14-5-选取聚类数量"><a href="#14-5-选取聚类数量" class="headerlink" title="14.5 选取聚类数量"></a>14.5 选取聚类数量</h2><p><img src="/img/ML_WED_1214/14.5.1.png" alt="肘部原则"><br>聚类数量选择方法：</p><ul><li>Elbow Method：改变K，即聚类总数，画出损失函数J的图像，选择肘部的值作为聚类数量，但有时图像没有一个明显的“肘部”</li><li>看哪个数量对后续的目的更有效</li><li>经常手动选择</li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.12-6.18)</title>
    <link href="/2021/06/17/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-12-6-18/"/>
    <url>/2021/06/17/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-12-6-18/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <span id="more"></span> </p></blockquote><p><a href="https://leetcode-cn.com/problems/reverse-string/">leetcode_344_反转字符串</a><br>思路:直接用双指针将头尾依次交换即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseString</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: List[str]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify s in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">0</span><br>        high = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(low &lt; high):<br>            s[low], s[high] = s[high], s[low]<br>            low += <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/344.png" alt="344"></p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">leetcode_345_反转字符串中的元音字母</a><br>思路:与344题非常相似,只需要每次反转前加上是否是元音字母的判断;<br>判断都在元音字母中,同时满足左指针低于右指针,再继续反转即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseVowels</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        target = <span class="hljs-string">&#x27;aeiouAEIOU&#x27;</span><br>        low = <span class="hljs-number">0</span><br>        high = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>        list_s = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">while</span>(list_s[low] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> target <span class="hljs-keyword">and</span> low &lt; <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>                low += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(list_s[high] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> target <span class="hljs-keyword">and</span> high &gt;= <span class="hljs-number">0</span>):<br>                high -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> high &lt;= low:<br>                <span class="hljs-keyword">break</span><br>            list_s[low], list_s[high] = list_s[high], list_s[low]<br>            low += <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(list_s)<br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/345.png" alt="345"></p><p><a href="https://leetcode-cn.com/problems/ransom-note/">leetcode_383_赎金信</a><br>思路:同样是字符串操作相关,开始没有想到较好的解决办法,时间复杂度比较高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        target = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(ransomNote))<br>        mag = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(magazine))<br><br>        <span class="hljs-keyword">while</span>(mag <span class="hljs-keyword">and</span> target):<br>            <span class="hljs-keyword">if</span> target[<span class="hljs-number">0</span>] &lt; mag[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> target[<span class="hljs-number">0</span>] == mag[<span class="hljs-number">0</span>]:<br>                mag.pop(<span class="hljs-number">0</span>)<br>                target.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                mag.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> target:<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/383_1.png" alt="383_暴力"><br>看了看题解,比较适合用桶排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># ransom = [0] * 26</span><br>        mag = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(magazine)):<br>            num = <span class="hljs-built_in">ord</span>(magazine[i])-<span class="hljs-number">97</span><br>            mag[num] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ransomNote)):<br>            num = <span class="hljs-built_in">ord</span>(ransomNote[i])-<span class="hljs-number">97</span><br>            mag[num] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> mag[num] &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/383_2.png" alt="383_桶排序"></p><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">leetcode_541_反转字符串II</a><br>思路:直接暴力反转即可,最开始写了不少边界判断,后来发现其实没有必要  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseStr</span>(<span class="hljs-params">self, s, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a), <span class="hljs-number">2</span>*k):<br>            a[i:i+k] = <span class="hljs-built_in">reversed</span>(a[i:i+k])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(a)<br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/541.png" alt="541"></p><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">leetecode_657_机器人能否回原点</a><br>思路:左右(或上下)和为0可以回原点  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgeCircle</span>(<span class="hljs-params">self, moves</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type moves: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        vertical = &#123;<br>            <span class="hljs-string">&#x27;U&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;D&#x27;</span>: -<span class="hljs-number">1</span><br>        &#125;<br>        horizontal = &#123;<br>            <span class="hljs-string">&#x27;L&#x27;</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;R&#x27;</span>: <span class="hljs-number">1</span><br>        &#125;<br>        v = <span class="hljs-number">0</span><br>        h = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(moves)):<br>            <span class="hljs-keyword">if</span> moves[i] <span class="hljs-keyword">in</span> vertical:<br>                v += vertical[moves[i]]<br>            <span class="hljs-keyword">else</span>:<br>                h += horizontal[moves[i]]<br>        <span class="hljs-keyword">if</span> v==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> h==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/657.png" alt="657"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-5、7-10章笔记</title>
    <link href="/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吴恩达机器学习课程5-10章部分笔记<br> <span id="more"></span> </p></blockquote><h2 id="5-1-5-2-多元线性回归"><a href="#5-1-5-2-多元线性回归" class="headerlink" title="5.1-5.2 多元线性回归"></a>5.1-5.2 多元线性回归</h2><p><img src="/img/ML_WED_78910/5.1.1.png" alt="变量表示"><br>$x_{j}^{(i)}$:第i组输入的第j个特征<br><img src="/img/ML_WED_78910/5.1.2.png" alt="多元线性回归的公式表示"><br>多元线性回归的假设函数:<br>$$h_\theta(x)=\theta_0+\theta_1 x_1+\theta_2 x_2+\cdots+\theta_n x_n=\theta^Tx$$</p><p><img src="/img/ML_WED_78910/5.1.3.png" alt="多元线性回归和单变量线性回归梯度下降的比较"><br>单变量线性回归只是多元问题的特殊形式，如图所示两者的梯度下降过程是等价的</p><h2 id="5-3-特征缩放"><a href="#5-3-特征缩放" class="headerlink" title="5.3 特征缩放"></a>5.3 特征缩放</h2><p><img src="/img/ML_WED_78910/5.1.4.png" alt="特征缩放"><br>考虑到不同特征的取值范围差别太大会影响梯度下降的正常工作，可以对不同特性进行缩放，大致落在相似的范围内（比如[-1,1]）</p><p><a href="https://www.zhihu.com/question/20467170">各种缩放方法可以参考知乎上的回答</a></p><p><img src="/img/ML_WED_78910/5.1.5.png" alt="标准化"><br>其中一种方法就是对特征进行均值标准化：<br>$$x:=\frac{x-mean(x)}{max(x)-min(x)}$$</p><h2 id="5-4-多元梯度下降"><a href="#5-4-多元梯度下降" class="headerlink" title="5.4 多元梯度下降"></a>5.4 多元梯度下降</h2><p>多元梯度下降中的问题:</p><ul><li>如何确保梯度下降在正确工作</li><li>如何有效选择学习率$\alpha$</li></ul><p><img src="/img/ML_WED_78910/5.1.6.png" alt="损失值的迭代图"><br>可以通过观察损失函数值随着迭代次数的变化来监控梯度下降工作，并根据损失值的变化特点调节学习率<br><img src="/img/ML_WED_78910/5.1.7.png" alt="学习率太大或太小可能出现的问题"></p><ul><li>学习率太小，收敛非常缓慢 </li><li>学习率太大，损失不会一直保持下降趋势，甚至不会收敛，也可能收敛缓慢</li></ul><h2 id="5-5-特征和多项式回归"><a href="#5-5-特征和多项式回归" class="headerlink" title="5.5 特征和多项式回归"></a>5.5 特征和多项式回归</h2><p><img src="/img/ML_WED_78910/5.5.1.png" alt="设计新的特征"><br>思路：有时候通过定义新的特征可能会得到更好的模型</p><blockquote><p>图中,与将长和宽作为特征进行训练相比,将长乘宽即面积作为新的特征用于线性回归更符合逻辑</p></blockquote><p><img src="/img/ML_WED_78910/5.5.2.png" alt="多项式回归"><br>根据数据特点灵活选用二次、三次项等作为特征，但此时特征缩放也变得更重要</p><hr><h2 id="7-1-分类"><a href="#7-1-分类" class="headerlink" title="7.1 分类"></a>7.1 分类</h2><p><img src="/img/ML_WED_78910/6.1.1.png" alt="分类问题"><br>一般用负类表示没有xxx的那一类（没有肿瘤、不是垃圾邮件etc.）</p><p><img src="/img/ML_WED_78910/6.1.2.png" alt="分类问题的阈值设置"><br>如果用线性回归解决分类问题，函数会很大程度受到离群数据的影响导致拟合效果很差<br><strong>逻辑回归</strong>（就是分类）：$0\leq h_\theta(x)\leq 1$</p><h2 id="7-2-假设表示"><a href="#7-2-假设表示" class="headerlink" title="7.2 假设表示"></a>7.2 假设表示</h2><p><img src="/img/ML_WED_78910/6.2.1.png" alt="逻辑回归模型"><br>比较：<br>线性回归：$h_\theta(x)=\theta^T x$<br>逻辑回归：$h_\theta(x)=g(\theta^T x)$<br>其中$g(z)=\frac{1}{1+e^{-z}}$(sigmoid函数)<br>最终：<br>$$h_\theta(x)=\frac{1}{1+e^{-\theta^T x}}$$用参数$\theta$拟合数据</p><p><img src="/img/ML_WED_78910/6.2.2.png" alt="假设函数输出的解释"><br>$h_\theta(x)$表示对给定的$x$,$y=1$的可能性（概率）</p><h2 id="7-3-决策边界"><a href="#7-3-决策边界" class="headerlink" title="7.3 决策边界"></a>7.3 决策边界</h2><p><img src="/img/ML_WED_78910/6.3.1.png" alt="决策边界"><br>通过训练集拟合参数$\theta$来决定决策边界</p><h2 id="7-4-7-5-代价函数"><a href="#7-4-7-5-代价函数" class="headerlink" title="7.4-7.5 代价函数"></a>7.4-7.5 代价函数</h2><p>如何拟合参数$\theta\rightarrow$代价函数<br><img src="/img/ML_WED_78910/6.4.1.png" alt="损失函数"></p><blockquote><p>问题：使用均方误差作为损失函数是非凸函数，不能保证收敛到全局最小</p></blockquote><p><img src="/img/ML_WED_78910/6.4.2.png" alt="逻辑回归损失函数(y=1)"><br>$y=1$时损失函数的直观理解，当预测$P(y=1|x;\theta)=0$，损失值无限大</p><p><img src="/img/ML_WED_78910/6.4.3.png" alt="逻辑回归损失函数(y=0)"><br>同理，$y=0$时,当预测$P(y=0|x;\theta)=1$，损失值无限大</p><p><img src="/img/ML_WED_78910/6.4.4.png" alt="损失函数优化"><br>将损失函数表示形式进行优化，最后损失函数（BCE）的表示如下：<br>$$J(\theta)=-\frac{1}{m}[\sum_{i=1}^m y^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log(1-h_{\theta}(x^{(i))})]$$</p><p><img src="/img/ML_WED_78910/6.4.5.png" alt="逻辑回归的梯度下降"><br>可以看到逻辑回归的参数更新公式，化简后和现行回归是一样的，只是假设函数有所区别</p><h2 id="7-6-高级优化"><a href="#7-6-高级优化" class="headerlink" title="7.6 高级优化"></a>7.6 高级优化</h2><p><img src="/img/ML_WED_78910/7.6.1.png" alt="高级优化算法"></p><h2 id="7-7-一对多"><a href="#7-7-一对多" class="headerlink" title="7.7 一对多"></a>7.7 一对多</h2><p><img src="/img/ML_WED_78910/6.7.1.png" alt="高级优化算法"><br>将多分类问题转化为多个二分类问题,训练多个假设函数,预测的时候取$h_\theta^{(x)}$最大的作为分类预测结果</p><hr><h2 id="8-1-过拟合问题"><a href="#8-1-过拟合问题" class="headerlink" title="8.1 过拟合问题"></a>8.1 过拟合问题</h2><h3 id="过拟合与欠拟合描述"><a href="#过拟合与欠拟合描述" class="headerlink" title="过拟合与欠拟合描述"></a>过拟合与欠拟合描述</h3><ul><li>欠拟合：数据拟合效果很差，偏差很大  </li><li>过拟合：千方百计地拟合了训练集，无法泛化到新的样本中，方差很大</li><li>泛化：一个假设模型应用到新样本的能力</li></ul><p><img src="/img/ML_WED_78910/7.1.1.png" alt="逻辑回归问题中的过拟合直观表现"></p><h4 id="解决过拟合的方法"><a href="#解决过拟合的方法" class="headerlink" title="解决过拟合的方法"></a>解决过拟合的方法</h4><ul><li>减少特征数量<ul><li>人工选择用于训练的特征  </li><li>模型选择算法，自动选择保留的特征</li></ul></li><li>正则化(Regularization)<ul><li>保留所有特征向量，减少量级</li><li>在有许多特征时表现良好，每一个特征都对预测结果产生一定影响</li></ul></li></ul><h2 id="8-2-正则化与损失函数"><a href="#8-2-正则化与损失函数" class="headerlink" title="8.2 正则化与损失函数"></a>8.2 正则化与损失函数</h2><h3 id="正则化直观理解"><a href="#正则化直观理解" class="headerlink" title="正则化直观理解"></a>正则化直观理解</h3><p><img src="/img/ML_WED_78910/7.2.1.png" alt="正则化直观理解"><br>参数值较小意味着更简单的参数模型，通过对$\theta_3$和$\theta_4$添加惩罚项，让他们接近0,得到一个更简单的模型，接近于二次函数</p><ul><li>更简单的假设</li><li>更不容易过拟合</li></ul><p><img src="/img/ML_WED_78910/7.2.2.png" alt="正则化"><br>在损失函数中添加正则化项，控制在两个目标之间的取舍</p><ul><li>第一项控制模型训练拟合</li><li>第二项使参数尽可能小</li><li>$\lambda$:正则化参数，控制两项之间的平衡关系</li></ul><h2 id="8-3-8-4-带正则化项的回归和分类"><a href="#8-3-8-4-带正则化项的回归和分类" class="headerlink" title="8.3-8.4 带正则化项的回归和分类"></a>8.3-8.4 带正则化项的回归和分类</h2><p><img src="/img/ML_WED_78910/7.3.1.png" alt="带正则化项的回归与分类的损失函数及梯度下降"></p><hr><h2 id="9-神经网络"><a href="#9-神经网络" class="headerlink" title="9 神经网络"></a>9 神经网络</h2><blockquote><p>神经网络被证明在学习复杂的非线性假设上是一种好得多的算法</p></blockquote><p>背景：</p><ul><li>起源：尝试设计模拟人类大脑的算法</li><li>80-90年代得到广泛应用，90s之后流行度降低</li><li>近年由于计算机算力的提升重新复苏</li></ul><h4 id="逻辑单元"><a href="#逻辑单元" class="headerlink" title="逻辑单元"></a>逻辑单元</h4><p><img src="/img/ML_WED_78910/8.1.1.png" alt="神经元"><br>下图表示一个简单的神经网络，由输入层、隐含层和输出层组成<br><img src="/img/ML_WED_78910/8.1.2.png" alt="神经网络"><br>神经网络的计算过程，以$a_1^{(2)}$为例，(2)代表第二层，通过第一层神经元乘以各自到$a_1$的权重并求和，通过激活函数$g$进行激活。<br><img src="/img/ML_WED_78910/8.1.3.png" alt="神经网络计算过程"><br>如下图所示，把$\Theta x$表示为$z$,如$z^{(2)}=\Theta^{(1)}x$，即$z^{(2)}=\Theta^{(1)}a^{(1)}$,可以更简洁地表示前向传播过程<br><img src="/img/ML_WED_78910/8.1.4.png" alt="神经网络前向传播"></p><h2 id="10-1-损失函数"><a href="#10-1-损失函数" class="headerlink" title="10.1 损失函数"></a>10.1 损失函数</h2><p><img src="/img/ML_WED_78910/10.1.1.png" alt="神经网络损失函数"></p><h2 id="10-2-反向传播"><a href="#10-2-反向传播" class="headerlink" title="10.2 反向传播"></a>10.2 反向传播</h2><p><img src="/img/ML_WED_78910/10.2.1.png" alt="正向传播"><br>网络首先进行正向传播计算预测值，然后通过反向传播更新权重</p><p><img src="/img/ML_WED_78910/10.2.2.png" alt="四层神经网络的反向传播"></p><blockquote><p>反向传播从直观上说，首先是对每个结点计算损失$\delta_k^{(l)}$(代表第l层第j个结点的误差)<br>对输出层的单元（layer=4），$\delta_j^{(4)}=a_j^{(4)}-y_j$,或者用向量表达为$\delta^{(4)}=a^{(4)}-y$</p></blockquote><h2 id="10-3-理解反向传播"><a href="#10-3-理解反向传播" class="headerlink" title="10.3 理解反向传播"></a>10.3 理解反向传播</h2><p><img src="/img/ML_WED_78910/10.3.1.png" alt="正向传播的例子"><br><img src="/img/ML_WED_78910/10.3.2.png" alt="反向传播的例子"></p><p><img src="/img/ML_WED_78910/manual.png" alt="反向传播的推导"><br>参考:<br><a href="https://zhuanlan.zhihu.com/p/25416673">https://zhuanlan.zhihu.com/p/25416673</a><br><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap2/c2s4.html">https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap2/c2s4.html</a><br><a href="https://blog.csdn.net/lien0906/article/details/79193103">https://blog.csdn.net/lien0906/article/details/79193103</a> </p><h2 id="10-5-梯度检验"><a href="#10-5-梯度检验" class="headerlink" title="10.5 梯度检验"></a>10.5 梯度检验</h2><blockquote><p>反向传播算法含有许多细节，很容易产生一些细微的bug难以发现，最后误差会比没有误差高出一个量级。<br>解决方法：梯度检验</p></blockquote><ul><li>从数值上求近似导数：计算损失函数在$\theta-\epsilon$和$\theta+\epsilon$的值，其中$\epsilon$取较小的值（如1e-4）</li><li>将$\theta-\epsilon$和$\theta+\epsilon$连起来作为近似斜率</li><li>求近似斜率$\frac{\Delta y}{\Delta x}$</li><li>当近似斜率等于反向传播中得到的斜率，证明反响传播实现是正确的<br><img src="/img/ML_WED_78910/10.5.1.png" alt="扩展到多个参数"><br><img src="/img/ML_WED_78910/10.5.2.png" alt="梯度检验的注意事项"></li></ul><h2 id="10-6-随机初始化"><a href="#10-6-随机初始化" class="headerlink" title="10.6 随机初始化"></a>10.6 随机初始化</h2><p><img src="/img/ML_WED_78910/10.6.1.png" alt="零初始化的问题"><br>常规初始化方法：随机初始化</p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/06/12/6.12-6.18/"/>
    <url>/2021/06/12/6.12-6.18/</url>
    
    <content type="html"><![CDATA[<blockquote><p>二分查找的一些编程例题<br> <!-- more --> </p></blockquote><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/">210613_leetcode278_第一个错误的版本</a><br>二分查找的典型应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = n<br>        <span class="hljs-keyword">while</span>(low &lt; high):<br>            mid = (high - low) // <span class="hljs-number">2</span> + low<br>            <span class="hljs-keyword">if</span> isBadVersion(mid):<br>                high = mid<br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> isBadVersion(mid):<br>                low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> low<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">210614_leetcode374_猜数字大小</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># The guess API is already defined for you.</span><br><span class="hljs-comment"># @param num, your guess</span><br><span class="hljs-comment"># @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="hljs-comment"># def guess(num):</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">guessNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> guess(n):<br>                <span class="hljs-keyword">return</span> n<br>            <span class="hljs-keyword">elif</span> guess(n) &lt; <span class="hljs-number">0</span>:<br>                high = n<br>            <span class="hljs-keyword">else</span>:<br>                low = n<br>            n = (high - low) // <span class="hljs-number">2</span> + low<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">210615_leetcode852_山脉数组的峰顶索引</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def peakIndexInMountainArray(self, arr):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> arr: List[<span class="hljs-keyword">int</span>]<br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span> = <span class="hljs-number">1</span>, n - <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">left</span> &lt; righ<span class="hljs-variable">t:</span><br>            mid = (<span class="hljs-keyword">right</span> -<span class="hljs-keyword">left</span>) // <span class="hljs-number">2</span> + <span class="hljs-keyword">left</span><br>            <span class="hljs-keyword">if</span> (arr[mid]-arr[mid-<span class="hljs-number">1</span>])*(arr[mid+<span class="hljs-number">1</span>]-arr[mid]) &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> mid<br>            elif arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">right</span> = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">left</span> = mid + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.5-6.11)</title>
    <link href="/2021/06/05/6.5-6.11/"/>
    <url>/2021/06/05/6.5-6.11/</url>
    
    <content type="html"><![CDATA[<blockquote><p>每周作业<br> <!-- more --> </p></blockquote><h3 id="每周的代码"><a href="#每周的代码" class="headerlink" title="每周的代码"></a>每周的代码</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">leetcode_13：罗马数字转整数</a><br>思路：</p><ol><li>罗马数字与整数数值存在映射关系，适合用哈希表构造，python用字典来实现。</li><li>观察罗马数字特点，从左到右为递减顺序，只有特殊情况下左边字母小于右边，根据该特点分类计算。<br>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">romanToInt</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        roman = &#123;  <span class="hljs-comment"># 罗马数值哈希表</span><br>            <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>            <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>            <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>            <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span><br>        &#125;<br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 如果存在递增说明适用特殊规则</span><br>            <span class="hljs-keyword">if</span> i&lt;<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> roman[s[i]]&lt;roman[s[i+<span class="hljs-number">1</span>]]:  <br>                result += -roman[s[i]]<br>            <span class="hljs-keyword">else</span>:<br>                result += roman[s[i]]<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">leetcode_14：最小公共前缀</a><br>思路：<br>题目比较简单，直接依次遍历字符串，更新最长公共前缀即可，尝试用二分查找来写<br>代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def longestCommonPrefix(self, strs):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> str<span class="hljs-variable">s:</span> List[str]<br>        :rtype: str<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        def if_same(str_list, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">all</span>(str_list[<span class="hljs-number">0</span>][lef<span class="hljs-variable">t:right</span>]==str_list[i][lef<span class="hljs-variable">t:right</span>] <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str_list)))<br>        <span class="hljs-keyword">if</span> not str<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">right</span> = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> s in strs)<br>        <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">left</span> &lt; righ<span class="hljs-variable">t:</span><br>            # mid = (<span class="hljs-keyword">left</span>+<span class="hljs-keyword">right</span>) // <span class="hljs-number">2</span><br>            mid = (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span> + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> + <span class="hljs-keyword">left</span><br>            <span class="hljs-keyword">if</span> if_same(strs, <span class="hljs-keyword">left</span>, mid):<br>                <span class="hljs-keyword">left</span> = mid<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">right</span> = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][:<span class="hljs-keyword">left</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>选mid的时候写成(left+right)//2会溢出，写成(right - left + 1) // 2 + left可以解决这个问题<br>all函数很方便：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">def <span class="hljs-keyword">all</span>(iterable):<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:  # 判断给定的可迭代参数 iterable 中的所有元素是否都为 <span class="hljs-literal">TRUE</span>，如果是返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span>。<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">leetcode_20：有效的括号</a><br>思路：<br>主要注意必须以正确的顺序闭合，s = “([)]”是不行的，所以对第一个右括号，上一个必须是正确的左括号。如果正确就把两个括号pop之后继续判断。因此用堆栈实现最合适。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        pairs = &#123;<br>            <span class="hljs-string">&quot;)&quot;</span>:<span class="hljs-string">&quot;(&quot;</span>,<br>            <span class="hljs-string">&quot;]&quot;</span>:<span class="hljs-string">&quot;[&quot;</span>,<br>            <span class="hljs-string">&quot;&#125;&quot;</span>:<span class="hljs-string">&quot;&#123;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> pairs:  <span class="hljs-comment"># key</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> pairs[ch]!=stack[-<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    stack.pop()<br>            <span class="hljs-keyword">else</span>:<br>                stack.append(ch)<br>        <span class="hljs-keyword">return</span> stack == []<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode_28：实现strStr()</a><br>思路：<br>字符串匹配问题，首先用暴力搜索试试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> haystack[i:i+<span class="hljs-built_in">len</span>(needle)] == needle:<br>                    <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以提交，但是复杂度太高，再学习了一下用滚动哈希来写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(haystack) &lt; <span class="hljs-built_in">len</span>(needle):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        hash_val = <span class="hljs-number">0</span><br>        target = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(needle):<br>                hash_val = hash_val * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>                target = target * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(needle[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">else</span>:<br>                hash_val = (<br>                    hash_val - (<span class="hljs-built_in">ord</span>(haystack[i - <span class="hljs-built_in">len</span>(needle)]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)) * <span class="hljs-number">26</span> ** (<span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span>)<br>                ) * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> hash_val == target:<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-built_in">len</span>(needle) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> hash_val == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/">leetcode_67：二进制求和</a><br>思路：这道题很容易想到用模拟的方法来写，再学习了一下用位运算的方法来写，是一种很不错的思路。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">addBinary</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">a: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">b: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">str</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">int</span>(<span class="hljs-symbol">a, <span class="hljs-symbol">2</span></span>), <span class="hljs-symbol">int</span>(<span class="hljs-symbol">b, <span class="hljs-symbol">2</span></span>)<br>        <span class="hljs-symbol">while</span> <span class="hljs-symbol">y:</span><br>            <span class="hljs-symbol">answer</span> = <span class="hljs-symbol">x</span> ^ <span class="hljs-symbol">y</span><br>            <span class="hljs-symbol">carry</span> = (<span class="hljs-symbol">x</span> &amp; <span class="hljs-symbol">y</span>) &lt;&lt; <span class="hljs-symbol">1</span><br>            <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">answer, <span class="hljs-symbol">carry</span></span><br>        <span class="hljs-symbol">return</span> <span class="hljs-symbol">bin</span>(<span class="hljs-symbol">x</span>)[<span class="hljs-symbol">2:</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>整体的思路就是先计算无进位的结果，然后通过按位与来模拟进位，通过左移一位来对其，最右边补零，所以结果不受影响。<br>位运算符：<br>&amp;按位与 |按位或 ^按位异或 ～按位取反 &lt;&lt;左移动运算符 &gt;&gt;右移动运算符</p><p>截图：<br><img src="/img/6.11_code_sub/13.png" alt="13"><br><img src="/img/6.11_code_sub/14.png" alt="14"><br><img src="/img/6.11_code_sub/20.png" alt="20"><br><img src="/img/6.11_code_sub/28.png" alt="28"><br><img src="/img/6.11_code_sub/67.png" alt="67"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-1-3章笔记</title>
    <link href="/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/"/>
    <url>/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>吴恩达机器学习课程1-3章部分笔记<br> <!-- more --> </p></blockquote><h2 id="1-1-1-2-什么是机器学习"><a href="#1-1-1-2-什么是机器学习" class="headerlink" title="1.1-1.2 什么是机器学习"></a>1.1-1.2 什么是机器学习</h2><h4 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h4><pre><code>-Grew out of work in AI-New capability for computers</code></pre><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code>-Database mining    Large datasets from growth of automation/web-Applications cant&#39;t program by hand.    NLP,CV,Autonomous helocopter..-Self-customizing programs(私人定制程序)-Understaning human learning(brain, real AI)</code></pre><h4 id="What-is-ML-definitions"><a href="#What-is-ML-definitions" class="headerlink" title="What is ML?(definitions)"></a>What is ML?(definitions)</h4><pre><code>-Field of study that gives computers the ability to learn without being explicitly programmed.(1959)-A computer program is said to learning from experience E with respect to some task T and some performanc e measure P, if its performance on T, as measured by P, improves with experience E(1998).(通过P测定在T上的表现因经验E而提高)</code></pre><h4 id="Example-邮件分类"><a href="#Example-邮件分类" class="headerlink" title="Example: 邮件分类"></a>Example: 邮件分类</h4><p>T:classifying emails<br>E:label emails<br>P:the fraction of emails correctly classified</p><h4 id="ML-algorithms"><a href="#ML-algorithms" class="headerlink" title="ML algorithms:"></a>ML algorithms:</h4><p><strong>supervised learning, unsupervised learning</strong>, reinforcement learning, recommender systems</p><h2 id="1-3-1-4-监督学习和无监督学习"><a href="#1-3-1-4-监督学习和无监督学习" class="headerlink" title="1.3-1.4 监督学习和无监督学习"></a>1.3-1.4 监督学习和无监督学习</h2><h4 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h4><p><strong>“right answers” given</strong></p><h4 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h4><p><strong>same labels or no labels</strong><br>E.g. 同一主题的新闻显示在一起（聚类），特定基因的表达程度（不同的个体归入不同的类）。。。</p><h4 id="cocktail-party-problem"><a href="#cocktail-party-problem" class="headerlink" title="cocktail party problem:"></a>cocktail party problem:</h4><p>当前语音识别技术已经可以以较高精度识别一个人所讲的话，但是当说话的人数为两人或者多人时，语音识别率就会极大的降低，这一难题被称为鸡尾酒会问题。<br>将两个声音分离出来。</p><h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression:"></a>Regression:</h4><p>Predict continuous valued output</p><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification:"></a>Classification:</h4><p>Discrete valued output(0/1)</p><h2 id="2-1-线性回归模型描述"><a href="#2-1-线性回归模型描述" class="headerlink" title="2.1 线性回归模型描述"></a>2.1 线性回归模型描述</h2><p>x-&gt;h(hypothesis)-&gt;y ,i.e. h maps x’s to y’s<br>how do we prepresent h?</p><p>$$h_\theta = \theta_0 + \theta_1x$$</p><p>(单变量)线性回归，y是关于x的线性函数<br><img src="/img/ML_WED_123/2.1.1.png" alt="参数表示"></p><h2 id="2-2-2-4-代价函数"><a href="#2-2-2-4-代价函数" class="headerlink" title="2.2-2.4 代价函数"></a>2.2-2.4 代价函数</h2><p><img src="/img/ML_WED_123/2.2.1.png" alt="损失函数"><br>θ‘s : parameters -&gt; how to choose?<br>Idea: choose θs so that h(x) is close to y for training examles -&gt; minimize <strong>h(x)-y</strong><br>损失函数(cost function)：<br>$$J(\theta_0, \theta_1)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})y^{(i)})^2$$<br><strong>Minimize J</strong><br><strong>找到能使训练集中预测值和真实值的差的平方和最小的θ0和θ1</strong></p><p><img src="/img/ML_WED_123/2.2.2.png" alt="h(x)和J(θ)"><br>对θ的每一个取值，对应左边一条直线，和右边一个点</p><p><img src="/img/ML_WED_123/2.2.3.png" alt="总结"><br><img src="/img/ML_WED_123/2.2.4.png" alt="增加一个参数的损失函数示意图"></p><h2 id="2-5-2-6-梯度下降算法"><a href="#2-5-2-6-梯度下降算法" class="headerlink" title="2.5-2.6 梯度下降算法"></a>2.5-2.6 梯度下降算法</h2><p>梯度下降算法：最小化损失函数J<br><img src="/img/ML_WED_123/2.3.1.png" alt="Problem Setup"></p><p>-把损失函数想像成一座山，每次从下山最快的方向走一小步 -&gt; 收敛至局部最低点<br>-从不同的地方开始下山可能会得到不同的结果<br><img src="/img/ML_WED_123/2.3.2.png" alt="梯度下降算法以及通常是同步更新"><br><img src="/img/ML_WED_123/2.3.3.png" alt="直观理解偏导数项的意义"><br>alpha代表学习率（步长），偏导数代表斜率，决定了更新的方向和速度<br><img src="/img/ML_WED_123/2.3.4.png" alt="选择合适的学习率"><br><img src="/img/ML_WED_123/2.3.5.png" alt="学习率不变也可以收敛到局部最小"><br>接近局部最小点的时候，学习率也会自动变小</p><h2 id="3-线性代数基础"><a href="#3-线性代数基础" class="headerlink" title="3 线性代数基础"></a>3 线性代数基础</h2><p>矩阵(matrix)：<br>$$A=\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4 \<br>5 &amp; 6 &amp; 7 &amp; 8 \<br>9 &amp; 10 &amp; 11 &amp; 12 \<br>\end{bmatrix}$$<br>$A_{ij}$表示第i行第j列，如$A_{22}$: 6<br>（因为还没有解决用hexo搭博客的时候多行公式的渲染问题，所以矩阵显示有点问题）<br>(latex公式里面可以用\cdots\vdots\ddots在矩阵里画省略号)</p><p>向量(vector): nx1的矩阵</p><p>矩阵加法：对应元素相加，只有相同形状的矩阵可以相加<br>矩阵和标量(scalar)的乘法：矩阵每一个元素都进行相应计算<br>矩阵之间的乘法：左行乘右列，得到的矩阵尺寸为左矩阵行数和右矩阵列数<br><img src="/img/ML_WED_123/3.1.1.png" alt="矩阵乘向量"><br><img src="/img/ML_WED_123/3.1.2.png" alt="用矩阵乘法来简化代码"><br>直接通过左行乘右列，所以每一列就是每一个假设函数得到的预测值，非常简便</p><p>其他特性：<br>1.矩阵乘法不服从交换律<br>2.矩阵乘法<strong>服从</strong>结合律<br>3.单位矩阵，表示为$I$或者$I_{n \times n}$，表示对角线上都是1,其余为0，对任意矩阵A，$AI=IA=A$</p><p><strong>逆矩阵</strong><br>如果矩阵A是$m \times m$的矩阵，并且有逆矩阵，那么：$AA^{-1}=A^{-1}A=I$<br>方阵，且行列式不为零才有逆矩阵<br>没有逆矩阵的矩阵可以想象成非常近似于零，称为<strong>奇异矩阵(singular)</strong></p><p>转置矩阵：<br><img src="/img/ML_WED_123/3.1.2.png" alt="转置矩阵"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三维CT切片方法、Python代码实现</title>
    <link href="/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>肺结节良恶性分类问题，一种随机选取角度进行二维切片的方法实现。<br> <span id="more"></span> </p></blockquote><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.researchgate.net/publication/328774789_A_Lightweight_Multi-Section_CNN_for_Lung_Nodule_Classification_and_Malignancy_Estimation">A Lightweight Multi-Section CNN for Lung Nodule Classification and Malignancy Estimation</a><br><a href="https://github.com/PranjalSahu/MultiSectionCNN">源码</a></p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="np-meshgrid"><a href="#np-meshgrid" class="headerlink" title="np.meshgrid"></a>np.meshgrid</h3><p>numpy.meshgrid()——生成网格点坐标矩阵。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">image_size = <span class="hljs-number">5</span><br>(yy, zz) = np<span class="hljs-selector-class">.meshgrid</span>(range(image_size), range(image_size))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;yy=&#x27;</span>, yy)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;zz=&#x27;</span>, zz)</span></span><br><br>plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;x axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;y axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.plot</span>(yy, zz, marker=<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;none&#x27;</span>)<br>plt<span class="hljs-selector-class">.grid</span>()<br>plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">yy= [[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]]<br>zz= [[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br> [1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1]<br> [2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2]<br> [3<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 3 </span>3]<br> [4<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 4 </span>4]]<br></code></pre></td></tr></table></figure><h3 id="scipy-ndimage-map-coordinates"><a href="#scipy-ndimage-map-coordinates" class="headerlink" title="scipy.ndimage.map_coordinates"></a>scipy.ndimage.map_coordinates</h3><p>文档：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    # 将输入数组通过插值映射到新的坐标。<br>    Map the <span class="hljs-built_in">input</span> array <span class="hljs-keyword">to</span> <span class="hljs-keyword">new</span> coordinates by interpolation.<br>    # 坐标数组用来寻找输出里每一个点在输入中对应的坐标，这些位置输入的坐标值通过设定的阶数的插值得出。<br>    The array of coordinates <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">find</span>, <span class="hljs-keyword">for</span> each point in the output,<br>    the corresponding coordinates in the <span class="hljs-built_in">input</span>. The value of the <span class="hljs-built_in">input</span> at<br>    those coordinates <span class="hljs-keyword">is</span> determined by spline interpolation of the<br>    requested order.<br>    #<br>    The shape of the output <span class="hljs-keyword">is</span> derived from that of the coordinate<br>    array by dropping the <span class="hljs-keyword">first</span> axis. The <span class="hljs-built_in">values</span> of the array along<br>    the <span class="hljs-keyword">first</span> axis are the coordinates in the <span class="hljs-built_in">input</span> array at which the<br>    output value <span class="hljs-keyword">is</span> found.<br><br>    Parameters<br>    ----------<br>    %(<span class="hljs-built_in">input</span>)s<br>    coordinates : array_like<br>        The coordinates at which `<span class="hljs-built_in">input</span>` <span class="hljs-keyword">is</span> evaluated.<br>    %(output)s<br>    order : <span class="hljs-keyword">int</span>, optional<br>        The order of the spline interpolation, default <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>.<br>        The order <span class="hljs-built_in">has</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> in the <span class="hljs-built_in">range</span> <span class="hljs-number">0</span>-<span class="hljs-number">5</span>.<br>    %(<span class="hljs-keyword">mode</span>)s<br>    %(cval)s<br>    %(prefilter)s<br><br>    Returns<br>    -------<br>    map_coordinates : ndarray<br>        The result of transforming the <span class="hljs-built_in">input</span>. The shape of the output <span class="hljs-keyword">is</span><br>        derived from that of `coordinates` by dropping the <span class="hljs-keyword">first</span> axis.<br><br>    See Also<br>    --------<br>    spline_filter, geometric_transform, scipy.interpolate<br><br>    Examples<br>    --------<br>    &gt;&gt;&gt; from scipy import ndimage<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span> = np.arange(<span class="hljs-number">12</span>.).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span><br>    array([[  <span class="hljs-number">0</span>.,   <span class="hljs-number">1</span>.,   <span class="hljs-number">2</span>.],<br>           [  <span class="hljs-number">3</span>.,   <span class="hljs-number">4</span>.,   <span class="hljs-number">5</span>.],<br>           [  <span class="hljs-number">6</span>.,   <span class="hljs-number">7</span>.,   <span class="hljs-number">8</span>.],<br>           [  <span class="hljs-number">9</span>.,  <span class="hljs-number">10</span>.,  <span class="hljs-number">11</span>.]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, [[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>]], order=<span class="hljs-number">1</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">7</span>.])<br><br>    Above, the interpolated value of <span class="hljs-keyword">a</span>[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>] gives output[<span class="hljs-number">0</span>], <span class="hljs-keyword">while</span><br>    <span class="hljs-keyword">a</span>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> output[<span class="hljs-number">1</span>].<br><br>    &gt;&gt;&gt; inds = np.array([[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=-<span class="hljs-number">33.3</span>)<br>    array([  <span class="hljs-number">2</span>. , -<span class="hljs-number">33.3</span>])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, <span class="hljs-keyword">mode</span>=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">8</span>.])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=<span class="hljs-number">0</span>, output=bool)<br>    array([ True, False], dtype=bool)<br><br>    <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/home/joe/MyBlog/themes/fluid/source/img/meshgrid.png"> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lllxxq141592654/article/details/81532855">meshgrid</a></p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>搜索算法的一些例题<br> <span id="more"></span> </p></blockquote><h2 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h2><p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><h3 id="树的深度优先搜索"><a href="#树的深度优先搜索" class="headerlink" title="树的深度优先搜索"></a>树的深度优先搜索</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h2 id="BFS（Breadth-First-Search）广度优先搜索"><a href="#BFS（Breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（Breadth First Search）广度优先搜索"></a>BFS（Breadth First Search）广度优先搜索</h2><p>###树的广度优先搜索</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def BFS(root):<br>    if not root:<br>        return<br>    queue = [root]<br>    while queue:<br>        <span class="hljs-literal">current</span> = queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h3><p>（leetcode 111题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = [root]<br>        minDep = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                    <span class="hljs-keyword">return</span> minDep<br>                <span class="hljs-keyword">if</span> node.left:<br>                    level.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    level.append(node.right)<br>            queue = level<br>            minDep += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划问题<br> <span id="more"></span> </p></blockquote><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>分治：最优子结构<br>动规：最优子结构、重叠子问题<br>贪心：最优子结构、重叠子问题、贪心选择性质</p><p>分治：为了解决一个问题，把它分解成若干个与此问题相似的子问题。<br>这样的“能分解”的性质就叫做最优子结构（又称无后效性）。很多问题都可以满足这个性质。</p><p>动态规划：动态规划是分治的特例。采用分治思想得到的子问题“不一定需要再次求解”，因为之前可能已经计算过相同的子问题了。这样的性质叫做重叠子问题。</p><p>贪心：贪心比动态规划更特殊，它还需要问题满足另一个性质——贪心选择性质。每次都可以把原问题分解为一个子问题。<br>动态规划是一种特殊的分治，而贪心是一种特殊的动态规划。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>递归形式：改分治。先进行判断。如果这个子问题已经处理过，那就直接把数组里储存了的值输出；否则就“计算结果”，最后储存答案。<br>递推形式：找出一种可行的拓扑序列。<br>两者在时间复杂度上没什么区别，而递归形式代码一般比较容易实现。具体区别请见：为什么线性动态规划类问题通常使用递推求解子问题，而不使用记忆化递归。<br>事实上动态规划最关键的是上文提到的“计算结果”，即列一个数学方程，这个方程被称为状态转移方程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>**第一步骤：定义数组元素的含义<br>第二步骤：找出数组元素之间的关系式<br>第三步骤：找出初始值<br>**</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>（leetcode70题）经典爬楼梯：<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n  <span class="hljs-comment"># 定义数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 定义初始状态</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]  <span class="hljs-comment"># 状态转移</span><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>（leetcode746题）最小代价爬楼梯：<br>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。<br>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。<br>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        prev = <span class="hljs-number">0</span> <br>        cur = <span class="hljs-number">0</span>   <span class="hljs-comment"># 把dp[i]设为第i阶为天台</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(cost)+<span class="hljs-number">1</span>):<br>            prev, cur = cur, <span class="hljs-built_in">min</span>(prev+cost[i-<span class="hljs-number">2</span>], cur+cost[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="子串、子序列、子数组"><a href="#子串、子序列、子数组" class="headerlink" title="子串、子序列、子数组"></a>子串、子序列、子数组</h3><p>最大子段和（leetcode53题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>最长公共子序列（leetcode1143题）：<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1, text2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type text1: str</span><br><span class="hljs-string">        :type text2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意顺序</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>最长重复子数组（leetcode718题）：<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLength</span>(<span class="hljs-params">self, nums1, nums2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)]<br>        maxr = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                    maxr = <span class="hljs-built_in">max</span>(maxr, dp[i][j])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> maxr<br></code></pre></td></tr></table></figure><h3 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h3><p>（leetcode264题）<br>给你一个整数 n ，请你找出并返回第 n 个 丑数 。<br>丑数 就是只包含质因数 2、3 和/或 5 的正整数。<br>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def nthUglyNumber(self, n):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> n: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        p2 = p3 =p5 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">min</span>(<span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>, <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>, <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>:<br>                p2 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>:<br>                p3 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>:<br>                p5 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">dp</span>[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><p>I. (leetcode198题)<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>II. (leetcode 213题)<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">robRange</span>(<span class="hljs-params">nums</span>):</span><br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(robRange(nums[:-<span class="hljs-number">1</span>]), robRange(nums[<span class="hljs-number">1</span>:]))  <span class="hljs-comment"># 先分解为两个单排问题</span><br><br></code></pre></td></tr></table></figure><p>III. </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/topic/19660018/hot">动态规划概念</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念和算法</title>
    <link href="/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>树的基本概念和一些典型例题<br> <span id="more"></span> </p></blockquote><p><img src="/img/tree.jpg" alt=" " title="二叉树"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>满二叉树</strong>：顾名思义<br><strong>完全二叉树</strong>：满二叉树从最后一个结点开始删除</p><p><strong>二叉搜索树</strong>（二叉查找树）：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大，递归定义。<br>    二叉搜索树中序遍历从小到大排序<br>正常情况下时间复杂度： O(logn)<br>最差：O(n)<br>避免最差情况：使用<strong>平衡二叉树</strong>（AVL）</p><p><strong>平衡二叉树</strong>：平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。<strong>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)</strong><br><strong>平衡因子</strong>：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。（左减右）<br><strong>最小失衡子树</strong>：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。<br>平衡二叉树的失衡调整主要是通过<strong>旋转</strong>最小失衡子树来实现的。根据旋转的方向有两种处理方式，**左旋 **与 <strong>右旋</strong> 。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><p>节点的<strong>度</strong>就是这个节点的孩子数量，例如有左右孩子的节点，它的度为2，如果只有左孩子或者只有右孩子的节点，它的度就是1，叶节点就是度为0的节点</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = x<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>树的建立：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">if</span> <span class="hljs-type">__name</span><span class="hljs-type">__</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;__main__&quot;</span><span class="hljs-operator">:</span><br>    <span class="hljs-built_in">D</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">D</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">E</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">E</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">F</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">F</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">C</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">C</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">None</span><span class="hljs-operator">,</span> <span class="hljs-variable">F</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">B</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">A</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">A</span><br></code></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root</span>):</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable">root</span>:</span><br><span class="hljs-function">        <span class="hljs-variable">return</span></span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">root.val</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.left</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.right</span>)</span><br></code></pre></td></tr></table></figure><p>深度优先：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><p>广度优先（leetcode101题）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim"># Definition <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> binary tree node.<br># class TreeNode(object):<br>#     def __init__(self, val=<span class="hljs-number">0</span>, <span class="hljs-keyword">left</span>=None, <span class="hljs-keyword">right</span>=None):<br>#         self.val = val<br>#         self.<span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span><br>#         self.<span class="hljs-keyword">right</span> = <span class="hljs-keyword">right</span><br>class Solution(object):<br>    def levelOrder(self, root):<br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">if</span> not roo<span class="hljs-variable">t:</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                level.<span class="hljs-keyword">append</span>(queue[<span class="hljs-number">0</span>].val)<br>                current = queue.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> current.lef<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">left</span>)<br>                <span class="hljs-keyword">if</span> current.righ<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">right</span>)<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(level)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>数组中第K个最大元素（leecode215题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_heap</span>(<span class="hljs-params">i, nums, length</span>):</span>  <span class="hljs-comment"># 构建最大堆</span><br>            left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子树</span><br>            right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子树</span><br>            max_index = i  <span class="hljs-comment"># 最大结点下标</span><br>            <span class="hljs-keyword">if</span> left &lt; length <span class="hljs-keyword">and</span> nums[i] &lt; nums[left]:<br>                max_index = left<br>            <span class="hljs-keyword">if</span> right &lt; length <span class="hljs-keyword">and</span> nums[max_index] &lt; nums[right]:<br>                max_index = right<br>            <span class="hljs-keyword">if</span> max_index != i:<br>                nums[i], nums[max_index] = nums[max_index], nums[i]<br>                build_heap(max_index, nums, length)  <span class="hljs-comment"># 如果经过了调换，对调换的子结点继续构建堆</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            build_heap(i, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            nums[<span class="hljs-number">0</span>], nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>] = nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]<br>            result = nums.pop()<br>            build_heap(<span class="hljs-number">0</span>, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://zhuanlan.zhihu.com/p/106828968">基本概念</a><br><a href="https://zhuanlan.zhihu.com/p/56066942">平衡二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>排序算法python实现总结<br> <span id="more"></span> </p></blockquote><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">bubble_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 外层冒泡轮数</span><br>        for <span class="hljs-keyword">j </span>in range(length<span class="hljs-number">-1</span>-i):  <span class="hljs-comment"># 里层依次比较，最大（最小）沉底</span><br>            if arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j+1]:</span><br><span class="hljs-keyword"> </span>               arr[<span class="hljs-keyword">j], </span>arr[<span class="hljs-keyword">j+1] </span>= arr[<span class="hljs-keyword">j+1], </span>arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>   return arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):  <span class="hljs-comment"># 循环轮数</span><br>        <span class="hljs-built_in">min</span> = arr[i]<br>        mini = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, length):<br>            <span class="hljs-keyword">if</span> arr[j] &lt; <span class="hljs-built_in">min</span>:<br>                <span class="hljs-built_in">min</span> = arr[j]<br>                mini = j<br>        arr[i], arr[mini] = arr[mini], arr[i]  <span class="hljs-comment"># 将最小的数和第i个数交换</span><br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insertion_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 循环轮数</span><br>        value = arr[i]<br>        <span class="hljs-keyword">j </span>= i<br>        while <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span>:<br>            if value &lt; arr[<span class="hljs-keyword">j-1]: </span> <span class="hljs-comment">#每次将第i个数插入有序数组中正确位置</span><br>                arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j-1]</span><br><span class="hljs-keyword"> </span>               <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br><span class="hljs-symbol">            else:</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword"> </span>       arr[<span class="hljs-keyword">j] </span>= value<br>    return arr<br></code></pre></td></tr></table></figure><p>插入排序实现方法类比扑克牌摸牌。<br>时间复杂度为<strong>O(n2)。</strong></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shells_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    gap = <span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">while</span> gap &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, length):  <span class="hljs-comment"># 从第二个数开始选择插入</span><br>            value = arr[i]<br>            j = i<br>            <span class="hljs-keyword">while</span> j - gap &gt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 前面还有数</span><br>                <span class="hljs-keyword">if</span> value &lt; arr[j-gap]:<br>                    arr[j] = arr[j-gap]  <span class="hljs-comment"># 当前数更小，则前移</span><br>                    j -= gap<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 否则为正确位置，插入</span><br>            arr[j] = value<br>        <span class="hljs-keyword">if</span> gap == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        gap = <span class="hljs-built_in">int</span>(gap/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>希尔排序也称作“缩小增量排序”，<strong>是插入排序的一种更高效的改进版本。</strong><br>根据增量进行跳跃的插入排序，然后缩小增量，最后进行增量为1的插入排序。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>python实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> merge(arr<span class="hljs-number">1</span>, arr<span class="hljs-number">2</span>):  # 治<br>    <span class="hljs-attribute">arr</span> =<span class="hljs-meta"> []</span><br>    <span class="hljs-attribute">node1</span>, node<span class="hljs-number">2</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> node<span class="hljs-number">1</span> &lt; len(arr<span class="hljs-number">1</span>) and node<span class="hljs-number">2</span> &lt; len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>] &lt; arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>]:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>])<br>            <span class="hljs-attribute">node1</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>])<br>            <span class="hljs-attribute">node2</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">1</span> == len(arr<span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>:])<br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">2</span> == len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>:])<br>    <span class="hljs-attribute">return</span> arr<br><br><br><span class="hljs-attribute">def</span> merge_sort(arr):  # 分<br>    <span class="hljs-attribute">length</span> = len(arr)<br>    <span class="hljs-attribute">if</span> length == <span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> arr<br><br>    <span class="hljs-attribute">left</span> = merge_sort(arr[:int(length/<span class="hljs-number">2</span>)])<br>    <span class="hljs-attribute">right</span> = merge_sort(arr[int(length/<span class="hljs-number">2</span>):])<br>    <span class="hljs-attribute">return</span> merge(left, right)<br></code></pre></td></tr></table></figure><p>分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>python实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">def quick_sort(arr):<br>    length <span class="hljs-operator">=</span> len(arr)<br>    if length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>]  # 取基准元素<br>    <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  # 左指针<br>    <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> length<span class="hljs-number">-1</span>  # 右指针<br>    ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span>  # 左右指针交替移动，先从右指针移动<br>    while <span class="hljs-keyword">left</span> <span class="hljs-operator">!=</span> <span class="hljs-keyword">right</span>:<br>        if ifright:<br>            if arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">right</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            if arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">left</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> quick_sort(arr[:<span class="hljs-keyword">left</span>])<span class="hljs-operator">+</span>[<span class="hljs-keyword">value</span>]<span class="hljs-operator">+</span>quick_sort(arr[(<span class="hljs-keyword">left</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>):])<br></code></pre></td></tr></table></figure><p>快速排序的思想：<br>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）<br>2.将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置<br>3.对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>):<br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左叶子</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右叶子</span><br>    max_index = i  <span class="hljs-comment"># 最大元素下标</span><br>    <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[left] &gt;= nums[i]:<br>        max_index = left<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-literal">right</span>] &gt; nums[max_index]:<br>        max_index = <span class="hljs-literal">right</span><br>    <span class="hljs-keyword">if</span> max_index != i:  <span class="hljs-comment"># 如果需要交换，先进行交换，然后对交换后的叶子构建堆</span><br>        nums[i], nums[max_index] = nums[max_index], nums[i]<br>        bulid_big_heap(nums, max_index, <span class="hljs-built_in">length</span>)<br><br>def heap_sort(nums):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(nums)<br>    sorted = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span><span class="hljs-comment"> // 2 - 1, -1, -1):  # 从最后一个非叶子结点开始构建堆</span><br>        bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):  <span class="hljs-comment"># 输出堆顶元素</span><br>        nums[<span class="hljs-number">0</span>], nums[j] = nums[j], nums[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 与最后一个元素交换</span><br>        sorted.insert(<span class="hljs-number">0</span>, nums.pop())  <span class="hljs-comment"># 输出</span><br>        bulid_big_heap(nums, <span class="hljs-number">0</span>, j)  <span class="hljs-comment"># 从堆顶开始重新构建堆</span><br>    <span class="hljs-literal">return</span> sorted<br></code></pre></td></tr></table></figure><p>堆排序的过程梳理：</p><ol><li>把数组构建成完全二叉树</li><li>从最后一个非叶子结点开始构建堆</li><li>输出堆顶元素，重建构建成堆</li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def count_sort(arr):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(arr)<br>    max_num = arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>):<br>        max_num = <span class="hljs-built_in">max</span>(max_num, arr[i])<br>    count_arr = [<span class="hljs-number">0</span>] * (max_num+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>):<br>        count_arr[arr[i]] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">result</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">while</span> count_arr[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">result</span>.append(i)<br>            count_arr[i] -= <span class="hljs-number">1</span><br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p>计数排序思路：找出最大值; 计数; 取出<br>适合取值范围相差不大的数组</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect">十大排序算法</a><br><a href="https://zhuanlan.zhihu.com/p/63202860">快速排序</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>算法的一些基本问题<br> <span id="more"></span> </p></blockquote><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。<br>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</p><p>严谨的进行算法的时间复杂度：「 大O符号表示法 」，即 T(n) = O(f(n))。<br>其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。<br><strong>一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。</strong></p><p>O(1): 无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)<br>O(n): for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。<br>O(n²) : 当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>O(logn): 在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。<br>O(nlogn): 将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p><h2 id="基本算法思想"><a href="#基本算法思想" class="headerlink" title="基本算法思想"></a>基本算法思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</strong><br>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。<br>1.找到如何将大问题分解为小问题的规律<br>2.通过规律写出递推公式<br>3.通过递归公式的临界点推敲出终止条件<br>4.将递推公式和终止条件翻译成代码</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。<br>步骤：<br>定义数组元素的含义;<br>找出数组元素之间的关系式;<br>找出初始值。</p><h3 id="动态规划和递归的区别"><a href="#动态规划和递归的区别" class="headerlink" title="动态规划和递归的区别"></a>动态规划和递归的区别</h3><p>用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。<br>1.动态规划法试图只解决每个子问题一次<br>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。<br>爬台阶（递归）自顶向下:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>爬台阶（动态规划）自底向上：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>int f(<span class="hljs-type">int</span> n) &#123;<br> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> <span class="hljs-number">3</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br> <span class="hljs-number">4</span>    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， <span class="hljs-keyword">temp</span> 保存当前状态的数据<br> <span class="hljs-number">5</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br> <span class="hljs-number">6</span>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">7</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br> <span class="hljs-number">8</span>        <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">9</span>        a = b;<br><span class="hljs-number">10</span>        b = <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">11</span>    &#125;<br><span class="hljs-number">12</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">13</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法，根据字面意思解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/23148377/answer/907915556">程序员必须掌握哪些算法</a><br><a href="https://www.cxyxiaowu.com/852.html">贪心算法</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485228&idx=1&sn=9f48aee51dcb2b98b56b1827cc658439&chksm=fa0e68adcd79e1bbcd0183ef30a79ede4e46c5835ce05ee6644169c3cc9454073019ccd85d3d&scene=21#wechat_redirect">分治算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动调参工具optuna</title>
    <link href="/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/"/>
    <url>/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/</url>
    
    <content type="html"><![CDATA[<blockquote><p>optuna使用记录。<br> <span id="more"></span> </p></blockquote><p><a href="https://github.com/optuna/optuna">optuna</a>是一个为机器学习设计的自动超参数优化软件框架。它有一个命令式的、按运行方式定义的用户API，用Optuna编写的代码具有很高的模块化，Optuna的用户可以动态地为超参数构建搜索空间。</p><h2 id="optuna基本概念"><a href="#optuna基本概念" class="headerlink" title="optuna基本概念"></a>optuna基本概念</h2><p>study：根据目标函数的优化Session,由一系列的trial组成。<br>trial：根据目标函数作出一次执行。<br><strong>study的学习目标就是根据多次trial得到的结果发现其中最优的超参数。</strong></p><h2 id="optuna常用搜索方式"><a href="#optuna常用搜索方式" class="headerlink" title="optuna常用搜索方式"></a>optuna常用搜索方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 选择型搜索方式【从MomentumSGD和Adam二者中选】</span><br>trail.suggest_categorical(<span class="hljs-string">&#x27;optimizer&#x27;</span>,[<span class="hljs-string">&#x27;MomentumSGD&#x27;</span>,<span class="hljs-string">&#x27;Adam&#x27;</span>])<br><span class="hljs-comment"># 整型搜索方式【从1～3范围内的int选择】</span><br>trail.suggest_int(<span class="hljs-string">&#x27;num_layers&#x27;</span>,1,3)<br><span class="hljs-comment"># 浮点型搜索方式【从0.0～1.0范围内float选择】</span><br>trial.suggest_float(<span class="hljs-string">&#x27;momentum&#x27;</span>, 0.0, 1.0)<br><span class="hljs-comment"># 连续均匀采样搜索方式 【从0～1.0之间的浮点数进行均匀采样】</span><br>trail.suggest_uniform(<span class="hljs-string">&#x27;dropout_rate&#x27;</span>,0.0,1.0)<br><span class="hljs-comment"># 对数均匀采样方式 【从log(1e-5)~log(1e-2)均匀分布中采样结果再取e的自然指数】</span><br>trail.suggest_loguniform(<span class="hljs-string">&#x27;learning_rate,1e-5,1e-2&#x27;</span>)<br><span class="hljs-comment"># 离散均匀采样方式 【以0.1为步长拆分0～1后的离散均匀分布中采样】</span><br>**trail.suggest_discrete_uniform(<span class="hljs-string">&#x27;drop_path_rate&#x27;</span>,0.0,1.0,0.1)<br></code></pre></td></tr></table></figure><p>具体可以查看一下<a href="https://github.com/optuna/optuna/blob/master/optuna/trial/_trial.py">文档</a></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先导入包，重设随机种子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import optuna<br><span class="hljs-function"><span class="hljs-title">reset_rand</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>定义目标函数，返回需要最大化（最小化）的目标</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def objective(trial):<br>    def model_opt():<br>        lr = trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;lr&#x27;</span>, 1e-3, 1e-2, 1e-3)<br>        model = network()<br>        optimizer = Adam(model.parameters(), lr)<br>        return model, optimizer<br><br>    acc = kFoldTraining(wd,<br>                        int(trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;batch_size&#x27;</span>, 32, 256, 32)),<br>                        epoch,<br>                        <span class="hljs-attribute">model_optimizer</span>=model_opt,<br>                        <span class="hljs-attribute">loss</span>=nn.CrossEntropyLoss(),<br>                        <span class="hljs-attribute">device</span>=<span class="hljs-string">&#x27;cuda:0&#x27;</span>,<br>                        <span class="hljs-attribute">deterministic</span>=<span class="hljs-literal">True</span>,<br>                        <span class="hljs-attribute">parallel</span>=<span class="hljs-literal">False</span><br>                        )<br>    return acc<br></code></pre></td></tr></table></figure><p>最后在主函数中调用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>study = optuna.create_study(<span class="hljs-attribute">direction</span>=<span class="hljs-string">&quot;maximize&quot;</span>, <span class="hljs-attribute">pruner</span>=optuna.pruners.HyperbandPruner())<br>study.optimize(objective, <span class="hljs-attribute">n_trials</span>=50)  # 调参的次数 <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Number of finished trials: &quot;</span>, len(study.trials))<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Best trial:&quot;</span>)<br>trial = study.best_trial<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Value: &quot;</span>, trial.value)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Params: &quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.params.items():<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.format(key, value))<br>df = study.trials_dataframe(attrs=(<span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;params&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>))<br>df.to_csv(keys[<span class="hljs-string">&#x27;result&#x27;</span>] + <span class="hljs-string">&#x27;/dataframe.csv&#x27;</span>, <span class="hljs-attribute">index</span>=<span class="hljs-literal">False</span>)<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/384519338/answer/1206812752">有没有什么可以节省大量时间的 Deep Learning 效率神器？</a><br><a href="https://zhuanlan.zhihu.com/p/259993570">Optuna — 超参自动化调整利器 学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建过程记录</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录简单的hexo个人博客搭建过程。<br> <span id="more"></span> </p></blockquote><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install git-core<br></code></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh<br></code></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvm install stable<br></code></pre></td></tr></table></figure><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>建立博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p>文件夹名称可以自己随意取，这三句命令的作用是初始化 Hexo </p><p>再次输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>作用是生成静态文件，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>作用是启动服务器。这时候就可以用浏览器打开网址： <a href="http://localhost:4000/">http://localhost:4000/</a> 来进行预览了。</p><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p>注册帐号，创建repo等操作就省略了，具体可参考其他博客（比如参考里面的）</p><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>如果已有public-key可以先删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add -D<br>$ rm -r ~/.ssh<br></code></pre></td></tr></table></figure><p>生成一个github用的SSH-Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@your.com” -f ~/.ssh/github-rsa</span><br></code></pre></td></tr></table></figure><p>添加私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa<br><span class="hljs-comment"># 可以通过 ssh-add -l 来确私钥列表</span><br>$ ssh-add -l<br><span class="hljs-comment"># 可以通过 ssh-add -D 来清空私钥列表</span><br>$ ssh-add -D<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 ~/.ssh 目录下新建一个config文件</span><br>$ touch config<br></code></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github</span><br>Host github.com<br>    HostName github.com<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/github_rsa<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>输出You’ve successfully authenticated, but GitHub does not provide shell access.就表示成功的连上github了</p><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br><span class="hljs-comment"># 本地预览</span><br>$ hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure><p>如果hexo d之后出现 ERROR Deployer not found: git，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>即可</p><p>上传时报错：incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line at….<br>要把标题里英文冒号改为中文的</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8">hexo fluid配置地址</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/hzq_0111/article/details/78956821">在github上搭建hexo个人博客</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://my.oschina.net/stefanzhlg/blog/529403">git配置多个ssh-key</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04 + Pycharm 配置Pyqt5</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ubuntu16.04 + Pycharm 配置Pyqt5过程记录</p></blockquote><span id="more"></span> <p>安装指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install qt5-default<br>sudo apt-get install qttools5-dev-tools<br>pip install pyqt5 -i https://pypi.douban.com/simple <span class="hljs-comment">#安装pyqt5包</span><br>sudo apt install pyqt5* <span class="hljs-comment">#安装依赖</span><br></code></pre></td></tr></table></figure><p>在Pycharm中进行配置：<br>打开pycharm后点击File - &gt; setting - &gt; Tools - &gt; External Tools, 点击 + 号添加两个文件。<br>（1）第一个是QtDesign用于通过pycharm直接启动QtDesigner，自定义Name（QtDesigner）, Group（Qt5）等参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/designer  <span class="hljs-comment"># 填入Program</span><br><span class="hljs-variable">$FileDir</span>$  <span class="hljs-comment"># 填入Working directory</span><br></code></pre></td></tr></table></figure><p>（2）第二个是将ui文件转换成py文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/usr/bin/python3  <span class="hljs-comment"># 填入Program</span><br>-m PyQt5.uic.pyuic  <span class="hljs-variable">$FileName</span><span class="hljs-variable">$ </span>-o <span class="hljs-variable">$FileNameWithoutExtension</span><span class="hljs-variable">$.</span>py  <span class="hljs-comment"># 填入Arguments</span><br><span class="hljs-variable">$FileDir</span><span class="hljs-variable">$ </span> <span class="hljs-comment"># 填入Working direction</span><br></code></pre></td></tr></table></figure><p>将ui文件转换为py文件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pyuic5 -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>py <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>ui<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/qq_37541097/article/details/80021315">Ubuntu16.04+pycharm+pyqt5安装与配置</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
