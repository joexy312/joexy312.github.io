<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>吴恩达-机器学习-7-10章笔记</title>
    <link href="/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="7-1-过拟合问题"><a href="#7-1-过拟合问题" class="headerlink" title="7.1 过拟合问题"></a>7.1 过拟合问题</h2><h3 id="过拟合与欠拟合描述"><a href="#过拟合与欠拟合描述" class="headerlink" title="过拟合与欠拟合描述"></a>过拟合与欠拟合描述</h3><ul><li>欠拟合：数据拟合效果很差，偏差很大  </li><li>过拟合：千方百计地拟合了训练集，无法泛化到新的样本中，方差很大</li><li>泛化：一个假设模型应用到新样本的能力</li></ul><p><img src="/img/ML_WED_78910/7.1.1.png" alt="逻辑回归问题中的过拟合直观表现"></p><h4 id="解决过拟合的方法"><a href="#解决过拟合的方法" class="headerlink" title="解决过拟合的方法"></a>解决过拟合的方法</h4><ul><li>减少特征数量<ul><li>人工选择用于训练的特征  </li><li>模型选择算法，自动选择保留的特征</li></ul></li><li>正则化(Regularization)<ul><li>保留所有特征向量，减少量级</li><li>在有许多特征时表现良好，每一个特征都对预测结果产生一定影响</li></ul></li></ul><h2 id="7-2-正则化与损失函数"><a href="#7-2-正则化与损失函数" class="headerlink" title="7.2 正则化与损失函数"></a>7.2 正则化与损失函数</h2><h3 id="正则化直观理解"><a href="#正则化直观理解" class="headerlink" title="正则化直观理解"></a>正则化直观理解</h3><p><img src="/img/ML_WED_78910/7.2.1.png" alt="正则化直观理解"><br>参数值较小意味着更简单的参数模型，通过对$\theta_3$和$\theta_4$添加惩罚项，让他们接近0,得到一个更简单的模型，接近于二次函数</p><ul><li>更简单的假设</li><li>更不容易过拟合</li></ul><p><img src="/img/ML_WED_78910/7.2.2.png" alt="正则化"><br>在损失函数中添加正则化项，控制在两个目标之间的取舍</p><ul><li>第一项控制模型训练拟合</li><li>第二项使参数尽可能小</li><li>$\lambda$:正则化参数，控制两项之间的平衡关系</li></ul><h2 id="7-3-7-4-带正则化项的回归和分类"><a href="#7-3-7-4-带正则化项的回归和分类" class="headerlink" title="7.3-7.4 带正则化项的回归和分类"></a>7.3-7.4 带正则化项的回归和分类</h2><p><img src="/img/ML_WED_78910/7.3.1.png" alt="带正则化项的回归与分类的损失函数及梯度下降"></p><hr><h2 id="8-神经网络"><a href="#8-神经网络" class="headerlink" title="8 神经网络"></a>8 神经网络</h2><blockquote><p>神经网络被证明在学习复杂的非线性假设上是一种好得多的算法</p></blockquote><p>背景：</p><ul><li>起源：尝试设计模拟人类大脑的算法</li><li>80-90年代得到广泛应用，90s之后流行度降低</li><li>近年由于计算机算力的提升重新复苏</li></ul><h4 id="逻辑单元"><a href="#逻辑单元" class="headerlink" title="逻辑单元"></a>逻辑单元</h4><p><img src="/img/ML_WED_78910/8.1.1.png" alt="神经元"><br>下图表示一个简单的神经网络，由输入层、隐含层和输出层组成<br><img src="/img/ML_WED_78910/8.1.2.png" alt="神经网络"><br>神经网络的计算过程，以$a_1^{(2)}$为例，(2)代表第二层，通过第一层神经元乘以各自到$a_1$的权重并求和，通过激活函数$g$进行激活。<br><img src="/img/ML_WED_78910/8.1.3.png" alt="神经网络计算过程"><br>如下图所示，把$\Theta x$表示为$z$,如$z^{(2)}=\Theta^{(1)}x$，即$z^{(2)}=\Theta^{(1)}a^{(1)}$,可以更简洁地表示前向传播过程<br><img src="/img/ML_WED_78910/8.1.4.png" alt="神经网络前向传播"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吴恩达</tag>
      
      <tag>周记</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/06/12/6.12-6.18/"/>
    <url>/2021/06/12/6.12-6.18/</url>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/">210613_leetcode278_第一个错误的版本</a><br>二分查找的典型应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = n<br>        <span class="hljs-keyword">while</span>(low &lt; high):<br>            mid = (high - low) // <span class="hljs-number">2</span> + low<br>            <span class="hljs-keyword">if</span> isBadVersion(mid):<br>                high = mid<br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> isBadVersion(mid):<br>                low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> low<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">猜数字大小</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># The guess API is already defined for you.</span><br><span class="hljs-comment"># @param num, your guess</span><br><span class="hljs-comment"># @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="hljs-comment"># def guess(num):</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">guessNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> guess(n):<br>                <span class="hljs-keyword">return</span> n<br>            <span class="hljs-keyword">elif</span> guess(n) &lt; <span class="hljs-number">0</span>:<br>                high = n<br>            <span class="hljs-keyword">else</span>:<br>                low = n<br>            n = (high - low) // <span class="hljs-number">2</span> + low<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.5-6.11)</title>
    <link href="/2021/06/05/6.5-6.11/"/>
    <url>/2021/06/05/6.5-6.11/</url>
    
    <content type="html"><![CDATA[<h3 id="每周的代码"><a href="#每周的代码" class="headerlink" title="每周的代码"></a>每周的代码</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">leetcode_13：罗马数字转整数</a><br>思路：</p><ol><li>罗马数字与整数数值存在映射关系，适合用哈希表构造，python用字典来实现。</li><li>观察罗马数字特点，从左到右为递减顺序，只有特殊情况下左边字母小于右边，根据该特点分类计算。<br>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">romanToInt</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        roman = &#123;  <span class="hljs-comment"># 罗马数值哈希表</span><br>            <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>            <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>            <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>            <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span><br>        &#125;<br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 如果存在递增说明适用特殊规则</span><br>            <span class="hljs-keyword">if</span> i&lt;<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> roman[s[i]]&lt;roman[s[i+<span class="hljs-number">1</span>]]:  <br>                result += -roman[s[i]]<br>            <span class="hljs-keyword">else</span>:<br>                result += roman[s[i]]<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">leetcode_14：最小公共前缀</a><br>思路：<br>题目比较简单，直接依次遍历字符串，更新最长公共前缀即可，尝试用二分查找来写<br>代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def longestCommonPrefix(self, strs):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> str<span class="hljs-variable">s:</span> List[str]<br>        :rtype: str<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        def if_same(str_list, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">all</span>(str_list[<span class="hljs-number">0</span>][lef<span class="hljs-variable">t:right</span>]==str_list[i][lef<span class="hljs-variable">t:right</span>] <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str_list)))<br>        <span class="hljs-keyword">if</span> not str<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">right</span> = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> s in strs)<br>        <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">left</span> &lt; righ<span class="hljs-variable">t:</span><br>            # mid = (<span class="hljs-keyword">left</span>+<span class="hljs-keyword">right</span>) // <span class="hljs-number">2</span><br>            mid = (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span> + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> + <span class="hljs-keyword">left</span><br>            <span class="hljs-keyword">if</span> if_same(strs, <span class="hljs-keyword">left</span>, mid):<br>                <span class="hljs-keyword">left</span> = mid<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">right</span> = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][:<span class="hljs-keyword">left</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>选mid的时候写成(left+right)//2会溢出，写成(right - left + 1) // 2 + left可以解决这个问题<br>all函数很方便：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">def <span class="hljs-keyword">all</span>(iterable):<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:  # 判断给定的可迭代参数 iterable 中的所有元素是否都为 <span class="hljs-literal">TRUE</span>，如果是返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span>。<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">leetcode_20：有效的括号</a><br>思路：<br>主要注意必须以正确的顺序闭合，s = “([)]”是不行的，所以对第一个右括号，上一个必须是正确的左括号。如果正确就把两个括号pop之后继续判断。因此用堆栈实现最合适。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        pairs = &#123;<br>            <span class="hljs-string">&quot;)&quot;</span>:<span class="hljs-string">&quot;(&quot;</span>,<br>            <span class="hljs-string">&quot;]&quot;</span>:<span class="hljs-string">&quot;[&quot;</span>,<br>            <span class="hljs-string">&quot;&#125;&quot;</span>:<span class="hljs-string">&quot;&#123;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> pairs:  <span class="hljs-comment"># key</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> pairs[ch]!=stack[-<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    stack.pop()<br>            <span class="hljs-keyword">else</span>:<br>                stack.append(ch)<br>        <span class="hljs-keyword">return</span> stack == []<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode_28：实现strStr()</a><br>思路：<br>字符串匹配问题，首先用暴力搜索试试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> haystack[i:i+<span class="hljs-built_in">len</span>(needle)] == needle:<br>                    <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以提交，但是复杂度太高，再学习了一下用滚动哈希来写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(haystack) &lt; <span class="hljs-built_in">len</span>(needle):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        hash_val = <span class="hljs-number">0</span><br>        target = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(needle):<br>                hash_val = hash_val * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>                target = target * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(needle[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">else</span>:<br>                hash_val = (<br>                    hash_val - (<span class="hljs-built_in">ord</span>(haystack[i - <span class="hljs-built_in">len</span>(needle)]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)) * <span class="hljs-number">26</span> ** (<span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span>)<br>                ) * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> hash_val == target:<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-built_in">len</span>(needle) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> hash_val == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/">leetcode_67：二进制求和</a><br>思路：这道题很容易想到用模拟的方法来写，再学习了一下用位运算的方法来写，是一种很不错的思路。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">addBinary</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">a: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">b: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">str</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">int</span>(<span class="hljs-symbol">a, <span class="hljs-symbol">2</span></span>), <span class="hljs-symbol">int</span>(<span class="hljs-symbol">b, <span class="hljs-symbol">2</span></span>)<br>        <span class="hljs-symbol">while</span> <span class="hljs-symbol">y:</span><br>            <span class="hljs-symbol">answer</span> = <span class="hljs-symbol">x</span> ^ <span class="hljs-symbol">y</span><br>            <span class="hljs-symbol">carry</span> = (<span class="hljs-symbol">x</span> &amp; <span class="hljs-symbol">y</span>) &lt;&lt; <span class="hljs-symbol">1</span><br>            <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">answer, <span class="hljs-symbol">carry</span></span><br>        <span class="hljs-symbol">return</span> <span class="hljs-symbol">bin</span>(<span class="hljs-symbol">x</span>)[<span class="hljs-symbol">2:</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>整体的思路就是先计算无进位的结果，然后通过按位与来模拟进位，通过左移一位来对其，最右边补零，所以结果不受影响。<br>位运算符：<br>&amp;按位与 |按位或 ^按位异或 ～按位取反 &lt;&lt;左移动运算符 &gt;&gt;右移动运算符</p><p>截图：<br><img src="/img/6.11_code_sub/13.png" alt="13"><br><img src="/img/6.11_code_sub/14.png" alt="14"><br><img src="/img/6.11_code_sub/20.png" alt="20"><br><img src="/img/6.11_code_sub/28.png" alt="28"><br><img src="/img/6.11_code_sub/67.png" alt="67"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>周记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-1-3章笔记</title>
    <link href="/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/"/>
    <url>/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-1-2-什么是机器学习"><a href="#1-1-1-2-什么是机器学习" class="headerlink" title="1.1-1.2 什么是机器学习"></a>1.1-1.2 什么是机器学习</h2><h4 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h4><pre><code>-Grew out of work in AI-New capability for computers</code></pre><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code>-Database mining    Large datasets from growth of automation/web-Applications cant&#39;t program by hand.    NLP,CV,Autonomous helocopter..-Self-customizing programs(私人定制程序)-Understaning human learning(brain, real AI)</code></pre><h4 id="What-is-ML-definitions"><a href="#What-is-ML-definitions" class="headerlink" title="What is ML?(definitions)"></a>What is ML?(definitions)</h4><pre><code>-Field of study that gives computers the ability to learn without being explicitly programmed.(1959)-A computer program is said to learning from experience E with respect to some task T and some performanc e measure P, if its performance on T, as measured by P, improves with experience E(1998).(通过P测定在T上的表现因经验E而提高)</code></pre><h4 id="Example-邮件分类"><a href="#Example-邮件分类" class="headerlink" title="Example: 邮件分类"></a>Example: 邮件分类</h4><p>T:classifying emails<br>E:label emails<br>P:the fraction of emails correctly classified</p><h4 id="ML-algorithms"><a href="#ML-algorithms" class="headerlink" title="ML algorithms:"></a>ML algorithms:</h4><p><strong>supervised learning, unsupervised learning</strong>, reinforcement learning, recommender systems</p><h2 id="1-3-1-4-监督学习和无监督学习"><a href="#1-3-1-4-监督学习和无监督学习" class="headerlink" title="1.3-1.4 监督学习和无监督学习"></a>1.3-1.4 监督学习和无监督学习</h2><h4 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h4><p><strong>“right answers” given</strong></p><h4 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h4><p><strong>same labels or no labels</strong><br>E.g. 同一主题的新闻显示在一起（聚类），特定基因的表达程度（不同的个体归入不同的类）。。。</p><h4 id="cocktail-party-problem"><a href="#cocktail-party-problem" class="headerlink" title="cocktail party problem:"></a>cocktail party problem:</h4><p>当前语音识别技术已经可以以较高精度识别一个人所讲的话，但是当说话的人数为两人或者多人时，语音识别率就会极大的降低，这一难题被称为鸡尾酒会问题。<br>将两个声音分离出来。</p><h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression:"></a>Regression:</h4><p>Predict continuous valued output</p><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification:"></a>Classification:</h4><p>Discrete valued output(0/1)</p><h2 id="2-1-线性回归模型描述"><a href="#2-1-线性回归模型描述" class="headerlink" title="2.1 线性回归模型描述"></a>2.1 线性回归模型描述</h2><p>x-&gt;h(hypothesis)-&gt;y ,i.e. h maps x’s to y’s<br>how do we prepresent h?</p><p>$$h_\theta = \theta_0 + \theta_1x$$</p><p>(单变量)线性回归，y是关于x的线性函数<br><img src="/img/ML_WED_123/2.1.1.png" alt="参数表示"></p><h2 id="2-2-2-4-代价函数"><a href="#2-2-2-4-代价函数" class="headerlink" title="2.2-2.4 代价函数"></a>2.2-2.4 代价函数</h2><p><img src="/img/ML_WED_123/2.2.1.png" alt="损失函数"><br>θ‘s : parameters -&gt; how to choose?<br>Idea: choose θs so that h(x) is close to y for training examles -&gt; minimize <strong>h(x)-y</strong><br>损失函数(cost function)：<br>$$J(\theta_0, \theta_1)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})y^{(i)})^2$$<br><strong>Minimize J</strong><br><strong>找到能使训练集中预测值和真实值的差的平方和最小的θ0和θ1</strong></p><p><img src="/img/ML_WED_123/2.2.2.png" alt="h(x)和J(θ)"><br>对θ的每一个取值，对应左边一条直线，和右边一个点</p><p><img src="/img/ML_WED_123/2.2.3.png" alt="总结"><br><img src="/img/ML_WED_123/2.2.4.png" alt="增加一个参数的损失函数示意图"></p><h2 id="2-5-2-6-梯度下降算法"><a href="#2-5-2-6-梯度下降算法" class="headerlink" title="2.5-2.6 梯度下降算法"></a>2.5-2.6 梯度下降算法</h2><p>梯度下降算法：最小化损失函数J<br><img src="/img/ML_WED_123/2.3.1.png" alt="Problem Setup"></p><p>-把损失函数想像成一座山，每次从下山最快的方向走一小步 -&gt; 收敛至局部最低点<br>-从不同的地方开始下山可能会得到不同的结果<br><img src="/img/ML_WED_123/2.3.2.png" alt="梯度下降算法以及通常是同步更新"><br><img src="/img/ML_WED_123/2.3.3.png" alt="直观理解偏导数项的意义"><br>alpha代表学习率（步长），偏导数代表斜率，决定了更新的方向和速度<br><img src="/img/ML_WED_123/2.3.4.png" alt="选择合适的学习率"><br><img src="/img/ML_WED_123/2.3.5.png" alt="学习率不变也可以收敛到局部最小"><br>接近局部最小点的时候，学习率也会自动变小</p><h2 id="3-线性代数基础"><a href="#3-线性代数基础" class="headerlink" title="3 线性代数基础"></a>3 线性代数基础</h2><p>矩阵(matrix)：<br>$$A=\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4 \<br>5 &amp; 6 &amp; 7 &amp; 8 \<br>9 &amp; 10 &amp; 11 &amp; 12 \<br>\end{bmatrix}$$<br>$A_{ij}$表示第i行第j列，如$A_{22}$: 6<br>（因为还没有解决用hexo搭博客的时候多行公式的渲染问题，所以矩阵显示有点问题）<br>(latex公式里面可以用\cdots\vdots\ddots在矩阵里画省略号)</p><p>向量(vector): nx1的矩阵</p><p>矩阵加法：对应元素相加，只有相同形状的矩阵可以相加<br>矩阵和标量(scalar)的乘法：矩阵每一个元素都进行相应计算<br>矩阵之间的乘法：左行乘右列，得到的矩阵尺寸为左矩阵行数和右矩阵列数<br><img src="/img/ML_WED_123/3.1.1.png" alt="矩阵乘向量"><br><img src="/img/ML_WED_123/3.1.2.png" alt="用矩阵乘法来简化代码"><br>直接通过左行乘右列，所以每一列就是每一个假设函数得到的预测值，非常简便</p><p>其他特性：<br>1.矩阵乘法不服从交换律<br>2.矩阵乘法<strong>服从</strong>结合律<br>3.单位矩阵，表示为$I$或者$I_{n \times n}$，表示对角线上都是1,其余为0，对任意矩阵A，$AI=IA=A$</p><p><strong>逆矩阵</strong><br>如果矩阵A是$m \times m$的矩阵，并且有逆矩阵，那么：$AA^{-1}=A^{-1}A=I$<br>方阵，且行列式不为零才有逆矩阵<br>没有逆矩阵的矩阵可以想象成非常近似于零，称为<strong>奇异矩阵(singular)</strong></p><p>转置矩阵：<br><img src="/img/ML_WED_123/3.1.2.png" alt="转置矩阵"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吴恩达</tag>
      
      <tag>周记</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用网站记录</title>
    <link href="/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
    <url>/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p><a href="https://onedrive.live.com/">onedrive</a><br><a href="https://www.zhihu.com/">知乎</a></p><h2 id="医学图像的网站"><a href="#医学图像的网站" class="headerlink" title="医学图像的网站"></a>医学图像的网站</h2><p><a href="https://www.cancerimagingarchive.net/">TCIA数据集</a><br><a href="http://www.via.cornell.edu/lidc/">LIDC Size Report</a><br><a href="https://wiki.cancerimagingarchive.net/display/Public/LIDC-IDRI">LIDC-IDRI</a><br><a href="https://pylidc.github.io/">Pylidc</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://leetcode-cn.com/">leetcode</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的官方网站</a></p><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图</a><br><a href="https://www.gnome-look.org/browse/cat/">Gnome-look</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/">清华大学开源镜像</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.myhuiban.com/">会伴</a><br><a href="https://www.overleaf.com/">overleaf</a><br><a href="https://sockboom.art/">sockboom</a><br><a href="https://hexo.fluid-dev.com/docs/">fluid文档</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三维CT切片方法、Python代码实现</title>
    <link href="/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.researchgate.net/publication/328774789_A_Lightweight_Multi-Section_CNN_for_Lung_Nodule_Classification_and_Malignancy_Estimation">A Lightweight Multi-Section CNN for Lung Nodule Classification and Malignancy Estimation</a><br><a href="https://github.com/PranjalSahu/MultiSectionCNN">源码</a></p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="np-meshgrid"><a href="#np-meshgrid" class="headerlink" title="np.meshgrid"></a>np.meshgrid</h3><p>numpy.meshgrid()——生成网格点坐标矩阵。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">image_size = <span class="hljs-number">5</span><br>(yy, zz) = np<span class="hljs-selector-class">.meshgrid</span>(range(image_size), range(image_size))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;yy=&#x27;</span>, yy)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;zz=&#x27;</span>, zz)</span></span><br><br>plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;x axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;y axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.plot</span>(yy, zz, marker=<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;none&#x27;</span>)<br>plt<span class="hljs-selector-class">.grid</span>()<br>plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">yy= [[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]]<br>zz= [[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br> [1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1]<br> [2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2]<br> [3<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 3 </span>3]<br> [4<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 4 </span>4]]<br></code></pre></td></tr></table></figure><h3 id="scipy-ndimage-map-coordinates"><a href="#scipy-ndimage-map-coordinates" class="headerlink" title="scipy.ndimage.map_coordinates"></a>scipy.ndimage.map_coordinates</h3><p>文档：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    # 将输入数组通过插值映射到新的坐标。<br>    Map the <span class="hljs-built_in">input</span> array <span class="hljs-keyword">to</span> <span class="hljs-keyword">new</span> coordinates by interpolation.<br>    # 坐标数组用来寻找输出里每一个点在输入中对应的坐标，这些位置输入的坐标值通过设定的阶数的插值得出。<br>    The array of coordinates <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">find</span>, <span class="hljs-keyword">for</span> each point in the output,<br>    the corresponding coordinates in the <span class="hljs-built_in">input</span>. The value of the <span class="hljs-built_in">input</span> at<br>    those coordinates <span class="hljs-keyword">is</span> determined by spline interpolation of the<br>    requested order.<br>    #<br>    The shape of the output <span class="hljs-keyword">is</span> derived from that of the coordinate<br>    array by dropping the <span class="hljs-keyword">first</span> axis. The <span class="hljs-built_in">values</span> of the array along<br>    the <span class="hljs-keyword">first</span> axis are the coordinates in the <span class="hljs-built_in">input</span> array at which the<br>    output value <span class="hljs-keyword">is</span> found.<br><br>    Parameters<br>    ----------<br>    %(<span class="hljs-built_in">input</span>)s<br>    coordinates : array_like<br>        The coordinates at which `<span class="hljs-built_in">input</span>` <span class="hljs-keyword">is</span> evaluated.<br>    %(output)s<br>    order : <span class="hljs-keyword">int</span>, optional<br>        The order of the spline interpolation, default <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>.<br>        The order <span class="hljs-built_in">has</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> in the <span class="hljs-built_in">range</span> <span class="hljs-number">0</span>-<span class="hljs-number">5</span>.<br>    %(<span class="hljs-keyword">mode</span>)s<br>    %(cval)s<br>    %(prefilter)s<br><br>    Returns<br>    -------<br>    map_coordinates : ndarray<br>        The result of transforming the <span class="hljs-built_in">input</span>. The shape of the output <span class="hljs-keyword">is</span><br>        derived from that of `coordinates` by dropping the <span class="hljs-keyword">first</span> axis.<br><br>    See Also<br>    --------<br>    spline_filter, geometric_transform, scipy.interpolate<br><br>    Examples<br>    --------<br>    &gt;&gt;&gt; from scipy import ndimage<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span> = np.arange(<span class="hljs-number">12</span>.).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span><br>    array([[  <span class="hljs-number">0</span>.,   <span class="hljs-number">1</span>.,   <span class="hljs-number">2</span>.],<br>           [  <span class="hljs-number">3</span>.,   <span class="hljs-number">4</span>.,   <span class="hljs-number">5</span>.],<br>           [  <span class="hljs-number">6</span>.,   <span class="hljs-number">7</span>.,   <span class="hljs-number">8</span>.],<br>           [  <span class="hljs-number">9</span>.,  <span class="hljs-number">10</span>.,  <span class="hljs-number">11</span>.]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, [[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>]], order=<span class="hljs-number">1</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">7</span>.])<br><br>    Above, the interpolated value of <span class="hljs-keyword">a</span>[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>] gives output[<span class="hljs-number">0</span>], <span class="hljs-keyword">while</span><br>    <span class="hljs-keyword">a</span>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> output[<span class="hljs-number">1</span>].<br><br>    &gt;&gt;&gt; inds = np.array([[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=-<span class="hljs-number">33.3</span>)<br>    array([  <span class="hljs-number">2</span>. , -<span class="hljs-number">33.3</span>])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, <span class="hljs-keyword">mode</span>=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">8</span>.])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=<span class="hljs-number">0</span>, output=bool)<br>    array([ True, False], dtype=bool)<br><br>    <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/home/joe/MyBlog/themes/fluid/source/img/meshgrid.png"> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lllxxq141592654/article/details/81532855">meshgrid</a></p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h2><p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><h3 id="树的深度优先搜索"><a href="#树的深度优先搜索" class="headerlink" title="树的深度优先搜索"></a>树的深度优先搜索</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h2 id="BFS（Breadth-First-Search）广度优先搜索"><a href="#BFS（Breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（Breadth First Search）广度优先搜索"></a>BFS（Breadth First Search）广度优先搜索</h2><p>###树的广度优先搜索</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def BFS(root):<br>    if not root:<br>        return<br>    queue = [root]<br>    while queue:<br>        <span class="hljs-literal">current</span> = queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h3><p>（leetcode 111题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = [root]<br>        minDep = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                    <span class="hljs-keyword">return</span> minDep<br>                <span class="hljs-keyword">if</span> node.left:<br>                    level.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    level.append(node.right)<br>            queue = level<br>            minDep += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>分治：最优子结构<br>动规：最优子结构、重叠子问题<br>贪心：最优子结构、重叠子问题、贪心选择性质</p><p>分治：为了解决一个问题，把它分解成若干个与此问题相似的子问题。<br>这样的“能分解”的性质就叫做最优子结构（又称无后效性）。很多问题都可以满足这个性质。</p><p>动态规划：动态规划是分治的特例。采用分治思想得到的子问题“不一定需要再次求解”，因为之前可能已经计算过相同的子问题了。这样的性质叫做重叠子问题。</p><p>贪心：贪心比动态规划更特殊，它还需要问题满足另一个性质——贪心选择性质。每次都可以把原问题分解为一个子问题。<br>动态规划是一种特殊的分治，而贪心是一种特殊的动态规划。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>递归形式：改分治。先进行判断。如果这个子问题已经处理过，那就直接把数组里储存了的值输出；否则就“计算结果”，最后储存答案。<br>递推形式：找出一种可行的拓扑序列。<br>两者在时间复杂度上没什么区别，而递归形式代码一般比较容易实现。具体区别请见：为什么线性动态规划类问题通常使用递推求解子问题，而不使用记忆化递归。<br>事实上动态规划最关键的是上文提到的“计算结果”，即列一个数学方程，这个方程被称为状态转移方程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>**第一步骤：定义数组元素的含义<br>第二步骤：找出数组元素之间的关系式<br>第三步骤：找出初始值<br>**</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>（leetcode70题）经典爬楼梯：<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n  <span class="hljs-comment"># 定义数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 定义初始状态</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]  <span class="hljs-comment"># 状态转移</span><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>（leetcode746题）最小代价爬楼梯：<br>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。<br>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。<br>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        prev = <span class="hljs-number">0</span> <br>        cur = <span class="hljs-number">0</span>   <span class="hljs-comment"># 把dp[i]设为第i阶为天台</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(cost)+<span class="hljs-number">1</span>):<br>            prev, cur = cur, <span class="hljs-built_in">min</span>(prev+cost[i-<span class="hljs-number">2</span>], cur+cost[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="子串、子序列、子数组"><a href="#子串、子序列、子数组" class="headerlink" title="子串、子序列、子数组"></a>子串、子序列、子数组</h3><p>最大子段和（leetcode53题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>最长公共子序列（leetcode1143题）：<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1, text2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type text1: str</span><br><span class="hljs-string">        :type text2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意顺序</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>最长重复子数组（leetcode718题）：<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLength</span>(<span class="hljs-params">self, nums1, nums2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)]<br>        maxr = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                    maxr = <span class="hljs-built_in">max</span>(maxr, dp[i][j])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> maxr<br></code></pre></td></tr></table></figure><h3 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h3><p>（leetcode264题）<br>给你一个整数 n ，请你找出并返回第 n 个 丑数 。<br>丑数 就是只包含质因数 2、3 和/或 5 的正整数。<br>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def nthUglyNumber(self, n):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> n: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        p2 = p3 =p5 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">min</span>(<span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>, <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>, <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>:<br>                p2 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>:<br>                p3 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>:<br>                p5 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">dp</span>[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><p>I. (leetcode198题)<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>II. (leetcode 213题)<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">robRange</span>(<span class="hljs-params">nums</span>):</span><br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(robRange(nums[:-<span class="hljs-number">1</span>]), robRange(nums[<span class="hljs-number">1</span>:]))  <span class="hljs-comment"># 先分解为两个单排问题</span><br><br></code></pre></td></tr></table></figure><p>III. </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/topic/19660018/hot">动态规划概念</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念和算法</title>
    <link href="/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/tree.jpg" alt=" " title="二叉树"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>满二叉树</strong>：顾名思义<br><strong>完全二叉树</strong>：满二叉树从最后一个结点开始删除</p><p><strong>二叉搜索树</strong>（二叉查找树）：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大，递归定义。<br>    二叉搜索树中序遍历从小到大排序<br>正常情况下时间复杂度： O(logn)<br>最差：O(n)<br>避免最差情况：使用<strong>平衡二叉树</strong>（AVL）</p><p><strong>平衡二叉树</strong>：平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。<strong>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)</strong><br><strong>平衡因子</strong>：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。（左减右）<br><strong>最小失衡子树</strong>：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。<br>平衡二叉树的失衡调整主要是通过<strong>旋转</strong>最小失衡子树来实现的。根据旋转的方向有两种处理方式，**左旋 **与 <strong>右旋</strong> 。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><p>节点的<strong>度</strong>就是这个节点的孩子数量，例如有左右孩子的节点，它的度为2，如果只有左孩子或者只有右孩子的节点，它的度就是1，叶节点就是度为0的节点</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = x<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>树的建立：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">if</span> <span class="hljs-type">__name</span><span class="hljs-type">__</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;__main__&quot;</span><span class="hljs-operator">:</span><br>    <span class="hljs-built_in">D</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">D</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">E</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">E</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">F</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">F</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">C</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">C</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">None</span><span class="hljs-operator">,</span> <span class="hljs-variable">F</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">B</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">A</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">A</span><br></code></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root</span>):</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable">root</span>:</span><br><span class="hljs-function">        <span class="hljs-variable">return</span></span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">root.val</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.left</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.right</span>)</span><br></code></pre></td></tr></table></figure><p>深度优先：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><p>广度优先（leetcode101题）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim"># Definition <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> binary tree node.<br># class TreeNode(object):<br>#     def __init__(self, val=<span class="hljs-number">0</span>, <span class="hljs-keyword">left</span>=None, <span class="hljs-keyword">right</span>=None):<br>#         self.val = val<br>#         self.<span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span><br>#         self.<span class="hljs-keyword">right</span> = <span class="hljs-keyword">right</span><br>class Solution(object):<br>    def levelOrder(self, root):<br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">if</span> not roo<span class="hljs-variable">t:</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                level.<span class="hljs-keyword">append</span>(queue[<span class="hljs-number">0</span>].val)<br>                current = queue.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> current.lef<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">left</span>)<br>                <span class="hljs-keyword">if</span> current.righ<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">right</span>)<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(level)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>数组中第K个最大元素（leecode215题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_heap</span>(<span class="hljs-params">i, nums, length</span>):</span>  <span class="hljs-comment"># 构建最大堆</span><br>            left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子树</span><br>            right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子树</span><br>            max_index = i  <span class="hljs-comment"># 最大结点下标</span><br>            <span class="hljs-keyword">if</span> left &lt; length <span class="hljs-keyword">and</span> nums[i] &lt; nums[left]:<br>                max_index = left<br>            <span class="hljs-keyword">if</span> right &lt; length <span class="hljs-keyword">and</span> nums[max_index] &lt; nums[right]:<br>                max_index = right<br>            <span class="hljs-keyword">if</span> max_index != i:<br>                nums[i], nums[max_index] = nums[max_index], nums[i]<br>                build_heap(max_index, nums, length)  <span class="hljs-comment"># 如果经过了调换，对调换的子结点继续构建堆</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            build_heap(i, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            nums[<span class="hljs-number">0</span>], nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>] = nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]<br>            result = nums.pop()<br>            build_heap(<span class="hljs-number">0</span>, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://zhuanlan.zhihu.com/p/106828968">基本概念</a><br><a href="https://zhuanlan.zhihu.com/p/56066942">平衡二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">bubble_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 外层冒泡轮数</span><br>        for <span class="hljs-keyword">j </span>in range(length<span class="hljs-number">-1</span>-i):  <span class="hljs-comment"># 里层依次比较，最大（最小）沉底</span><br>            if arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j+1]:</span><br><span class="hljs-keyword"> </span>               arr[<span class="hljs-keyword">j], </span>arr[<span class="hljs-keyword">j+1] </span>= arr[<span class="hljs-keyword">j+1], </span>arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>   return arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):  <span class="hljs-comment"># 循环轮数</span><br>        <span class="hljs-built_in">min</span> = arr[i]<br>        mini = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, length):<br>            <span class="hljs-keyword">if</span> arr[j] &lt; <span class="hljs-built_in">min</span>:<br>                <span class="hljs-built_in">min</span> = arr[j]<br>                mini = j<br>        arr[i], arr[mini] = arr[mini], arr[i]  <span class="hljs-comment"># 将最小的数和第i个数交换</span><br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insertion_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 循环轮数</span><br>        value = arr[i]<br>        <span class="hljs-keyword">j </span>= i<br>        while <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span>:<br>            if value &lt; arr[<span class="hljs-keyword">j-1]: </span> <span class="hljs-comment">#每次将第i个数插入有序数组中正确位置</span><br>                arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j-1]</span><br><span class="hljs-keyword"> </span>               <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br><span class="hljs-symbol">            else:</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword"> </span>       arr[<span class="hljs-keyword">j] </span>= value<br>    return arr<br></code></pre></td></tr></table></figure><p>插入排序实现方法类比扑克牌摸牌。<br>时间复杂度为<strong>O(n2)。</strong></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shells_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    gap = <span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">while</span> gap &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, length):  <span class="hljs-comment"># 从第二个数开始选择插入</span><br>            value = arr[i]<br>            j = i<br>            <span class="hljs-keyword">while</span> j - gap &gt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 前面还有数</span><br>                <span class="hljs-keyword">if</span> value &lt; arr[j-gap]:<br>                    arr[j] = arr[j-gap]  <span class="hljs-comment"># 当前数更小，则前移</span><br>                    j -= gap<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 否则为正确位置，插入</span><br>            arr[j] = value<br>        <span class="hljs-keyword">if</span> gap == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        gap = <span class="hljs-built_in">int</span>(gap/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>希尔排序也称作“缩小增量排序”，<strong>是插入排序的一种更高效的改进版本。</strong><br>根据增量进行跳跃的插入排序，然后缩小增量，最后进行增量为1的插入排序。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>python实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> merge(arr<span class="hljs-number">1</span>, arr<span class="hljs-number">2</span>):  # 治<br>    <span class="hljs-attribute">arr</span> =<span class="hljs-meta"> []</span><br>    <span class="hljs-attribute">node1</span>, node<span class="hljs-number">2</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> node<span class="hljs-number">1</span> &lt; len(arr<span class="hljs-number">1</span>) and node<span class="hljs-number">2</span> &lt; len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>] &lt; arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>]:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>])<br>            <span class="hljs-attribute">node1</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>])<br>            <span class="hljs-attribute">node2</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">1</span> == len(arr<span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>:])<br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">2</span> == len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>:])<br>    <span class="hljs-attribute">return</span> arr<br><br><br><span class="hljs-attribute">def</span> merge_sort(arr):  # 分<br>    <span class="hljs-attribute">length</span> = len(arr)<br>    <span class="hljs-attribute">if</span> length == <span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> arr<br><br>    <span class="hljs-attribute">left</span> = merge_sort(arr[:int(length/<span class="hljs-number">2</span>)])<br>    <span class="hljs-attribute">right</span> = merge_sort(arr[int(length/<span class="hljs-number">2</span>):])<br>    <span class="hljs-attribute">return</span> merge(left, right)<br></code></pre></td></tr></table></figure><p>分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>python实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">def quick_sort(arr):<br>    length <span class="hljs-operator">=</span> len(arr)<br>    if length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>]  # 取基准元素<br>    <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  # 左指针<br>    <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> length<span class="hljs-number">-1</span>  # 右指针<br>    ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span>  # 左右指针交替移动，先从右指针移动<br>    while <span class="hljs-keyword">left</span> <span class="hljs-operator">!=</span> <span class="hljs-keyword">right</span>:<br>        if ifright:<br>            if arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">right</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            if arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">left</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> quick_sort(arr[:<span class="hljs-keyword">left</span>])<span class="hljs-operator">+</span>[<span class="hljs-keyword">value</span>]<span class="hljs-operator">+</span>quick_sort(arr[(<span class="hljs-keyword">left</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>):])<br></code></pre></td></tr></table></figure><p>快速排序的思想：<br>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）<br>2.将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置<br>3.对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>):<br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左叶子</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右叶子</span><br>    max_index = i  <span class="hljs-comment"># 最大元素下标</span><br>    <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[left] &gt;= nums[i]:<br>        max_index = left<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-literal">right</span>] &gt; nums[max_index]:<br>        max_index = <span class="hljs-literal">right</span><br>    <span class="hljs-keyword">if</span> max_index != i:  <span class="hljs-comment"># 如果需要交换，先进行交换，然后对交换后的叶子构建堆</span><br>        nums[i], nums[max_index] = nums[max_index], nums[i]<br>        bulid_big_heap(nums, max_index, <span class="hljs-built_in">length</span>)<br><br>def heap_sort(nums):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(nums)<br>    sorted = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span><span class="hljs-comment"> // 2 - 1, -1, -1):  # 从最后一个非叶子结点开始构建堆</span><br>        bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):  <span class="hljs-comment"># 输出堆顶元素</span><br>        nums[<span class="hljs-number">0</span>], nums[j] = nums[j], nums[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 与最后一个元素交换</span><br>        sorted.insert(<span class="hljs-number">0</span>, nums.pop())  <span class="hljs-comment"># 输出</span><br>        bulid_big_heap(nums, <span class="hljs-number">0</span>, j)  <span class="hljs-comment"># 从堆顶开始重新构建堆</span><br>    <span class="hljs-literal">return</span> sorted<br></code></pre></td></tr></table></figure><p>堆排序的过程梳理：</p><ol><li>把数组构建成完全二叉树</li><li>从最后一个非叶子结点开始构建堆</li><li>输出堆顶元素，重建构建成堆</li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def count_sort(arr):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(arr)<br>    max_num = arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>):<br>        max_num = <span class="hljs-built_in">max</span>(max_num, arr[i])<br>    count_arr = [<span class="hljs-number">0</span>] * (max_num+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>):<br>        count_arr[arr[i]] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">result</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">while</span> count_arr[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">result</span>.append(i)<br>            count_arr[i] -= <span class="hljs-number">1</span><br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p>计数排序思路：找出最大值; 计数; 取出<br>适合取值范围相差不大的数组</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect">十大排序算法</a><br><a href="https://zhuanlan.zhihu.com/p/63202860">快速排序</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。<br>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</p><p>严谨的进行算法的时间复杂度：「 大O符号表示法 」，即 T(n) = O(f(n))。<br>其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。<br><strong>一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。</strong></p><p>O(1): 无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)<br>O(n): for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。<br>O(n²) : 当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>O(logn): 在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。<br>O(nlogn): 将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p><h2 id="基本算法思想"><a href="#基本算法思想" class="headerlink" title="基本算法思想"></a>基本算法思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</strong><br>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。<br>1.找到如何将大问题分解为小问题的规律<br>2.通过规律写出递推公式<br>3.通过递归公式的临界点推敲出终止条件<br>4.将递推公式和终止条件翻译成代码</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。<br>步骤：<br>定义数组元素的含义;<br>找出数组元素之间的关系式;<br>找出初始值。</p><h3 id="动态规划和递归的区别"><a href="#动态规划和递归的区别" class="headerlink" title="动态规划和递归的区别"></a>动态规划和递归的区别</h3><p>用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。<br>1.动态规划法试图只解决每个子问题一次<br>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。<br>爬台阶（递归）自顶向下:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>爬台阶（动态规划）自底向上：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>int f(<span class="hljs-type">int</span> n) &#123;<br> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> <span class="hljs-number">3</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br> <span class="hljs-number">4</span>    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， <span class="hljs-keyword">temp</span> 保存当前状态的数据<br> <span class="hljs-number">5</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br> <span class="hljs-number">6</span>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">7</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br> <span class="hljs-number">8</span>        <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">9</span>        a = b;<br><span class="hljs-number">10</span>        b = <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">11</span>    &#125;<br><span class="hljs-number">12</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">13</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法，根据字面意思解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/23148377/answer/907915556">程序员必须掌握哪些算法</a><br><a href="https://www.cxyxiaowu.com/852.html">贪心算法</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485228&idx=1&sn=9f48aee51dcb2b98b56b1827cc658439&chksm=fa0e68adcd79e1bbcd0183ef30a79ede4e46c5835ce05ee6644169c3cc9454073019ccd85d3d&scene=21#wechat_redirect">分治算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动调参工具optuna</title>
    <link href="/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/"/>
    <url>/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/optuna/optuna">optuna</a>是一个为机器学习设计的自动超参数优化软件框架。它有一个命令式的、按运行方式定义的用户API，用Optuna编写的代码具有很高的模块化，Optuna的用户可以动态地为超参数构建搜索空间。</p><h2 id="optuna基本概念"><a href="#optuna基本概念" class="headerlink" title="optuna基本概念"></a>optuna基本概念</h2><p>study：根据目标函数的优化Session,由一系列的trial组成。<br>trial：根据目标函数作出一次执行。<br><strong>study的学习目标就是根据多次trial得到的结果发现其中最优的超参数。</strong></p><h2 id="optuna常用搜索方式"><a href="#optuna常用搜索方式" class="headerlink" title="optuna常用搜索方式"></a>optuna常用搜索方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 选择型搜索方式【从MomentumSGD和Adam二者中选】</span><br>trail.suggest_categorical(<span class="hljs-string">&#x27;optimizer&#x27;</span>,[<span class="hljs-string">&#x27;MomentumSGD&#x27;</span>,<span class="hljs-string">&#x27;Adam&#x27;</span>])<br><span class="hljs-comment"># 整型搜索方式【从1～3范围内的int选择】</span><br>trail.suggest_int(<span class="hljs-string">&#x27;num_layers&#x27;</span>,1,3)<br><span class="hljs-comment"># 浮点型搜索方式【从0.0～1.0范围内float选择】</span><br>trial.suggest_float(<span class="hljs-string">&#x27;momentum&#x27;</span>, 0.0, 1.0)<br><span class="hljs-comment"># 连续均匀采样搜索方式 【从0～1.0之间的浮点数进行均匀采样】</span><br>trail.suggest_uniform(<span class="hljs-string">&#x27;dropout_rate&#x27;</span>,0.0,1.0)<br><span class="hljs-comment"># 对数均匀采样方式 【从log(1e-5)~log(1e-2)均匀分布中采样结果再取e的自然指数】</span><br>trail.suggest_loguniform(<span class="hljs-string">&#x27;learning_rate,1e-5,1e-2&#x27;</span>)<br><span class="hljs-comment"># 离散均匀采样方式 【以0.1为步长拆分0～1后的离散均匀分布中采样】</span><br>**trail.suggest_discrete_uniform(<span class="hljs-string">&#x27;drop_path_rate&#x27;</span>,0.0,1.0,0.1)<br></code></pre></td></tr></table></figure><p>具体可以查看一下<a href="https://github.com/optuna/optuna/blob/master/optuna/trial/_trial.py">文档</a></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先导入包，重设随机种子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import optuna<br><span class="hljs-function"><span class="hljs-title">reset_rand</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>定义目标函数，返回需要最大化（最小化）的目标</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def objective(trial):<br>    def model_opt():<br>        lr = trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;lr&#x27;</span>, 1e-3, 1e-2, 1e-3)<br>        model = network()<br>        optimizer = Adam(model.parameters(), lr)<br>        return model, optimizer<br><br>    acc = kFoldTraining(wd,<br>                        int(trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;batch_size&#x27;</span>, 32, 256, 32)),<br>                        epoch,<br>                        <span class="hljs-attribute">model_optimizer</span>=model_opt,<br>                        <span class="hljs-attribute">loss</span>=nn.CrossEntropyLoss(),<br>                        <span class="hljs-attribute">device</span>=<span class="hljs-string">&#x27;cuda:0&#x27;</span>,<br>                        <span class="hljs-attribute">deterministic</span>=<span class="hljs-literal">True</span>,<br>                        <span class="hljs-attribute">parallel</span>=<span class="hljs-literal">False</span><br>                        )<br>    return acc<br></code></pre></td></tr></table></figure><p>最后在主函数中调用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>study = optuna.create_study(<span class="hljs-attribute">direction</span>=<span class="hljs-string">&quot;maximize&quot;</span>, <span class="hljs-attribute">pruner</span>=optuna.pruners.HyperbandPruner())<br>study.optimize(objective, <span class="hljs-attribute">n_trials</span>=50)  # 调参的次数 <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Number of finished trials: &quot;</span>, len(study.trials))<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Best trial:&quot;</span>)<br>trial = study.best_trial<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Value: &quot;</span>, trial.value)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Params: &quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.params.items():<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.format(key, value))<br>df = study.trials_dataframe(attrs=(<span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;params&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>))<br>df.to_csv(keys[<span class="hljs-string">&#x27;result&#x27;</span>] + <span class="hljs-string">&#x27;/dataframe.csv&#x27;</span>, <span class="hljs-attribute">index</span>=<span class="hljs-literal">False</span>)<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/384519338/answer/1206812752">有没有什么可以节省大量时间的 Deep Learning 效率神器？</a><br><a href="https://zhuanlan.zhihu.com/p/259993570">Optuna — 超参自动化调整利器 学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建过程记录</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录简单的个人博客搭建过程。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install git-core<br></code></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh<br></code></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvm install stable<br></code></pre></td></tr></table></figure><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>建立博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p>文件夹名称可以自己随意取，这三句命令的作用是初始化 Hexo </p><p>再次输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>作用是生成静态文件，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>作用是启动服务器。这时候就可以用浏览器打开网址： <a href="http://localhost:4000/">http://localhost:4000/</a> 来进行预览了。</p><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p>注册帐号，创建repo等操作就省略了，具体可参考其他博客（比如参考里面的）</p><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>如果已有public-key可以先删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add -D<br>$ rm -r ~/.ssh<br></code></pre></td></tr></table></figure><p>生成一个github用的SSH-Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@your.com” -f ~/.ssh/github-rsa</span><br></code></pre></td></tr></table></figure><p>添加私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa<br><span class="hljs-comment"># 可以通过 ssh-add -l 来确私钥列表</span><br>$ ssh-add -l<br><span class="hljs-comment"># 可以通过 ssh-add -D 来清空私钥列表</span><br>$ ssh-add -D<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 ~/.ssh 目录下新建一个config文件</span><br>$ touch config<br></code></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github</span><br>Host github.com<br>    HostName github.com<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/github_rsa<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>输出You’ve successfully authenticated, but GitHub does not provide shell access.就表示成功的连上github了</p><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br><span class="hljs-comment"># 本地预览</span><br>$ hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure><p>如果hexo d之后出现 ERROR Deployer not found: git，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>即可</p><p>上传时报错：incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line at….<br>要把标题里英文冒号改为中文的</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8">hexo fluid配置地址</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/hzq_0111/article/details/78956821">在github上搭建hexo个人博客</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://my.oschina.net/stefanzhlg/blog/529403">git配置多个ssh-key</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04 + Pycharm 配置Pyqt5</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/</url>
    
    <content type="html"><![CDATA[<p>安装指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install qt5-default<br>sudo apt-get install qttools5-dev-tools<br>pip install pyqt5 -i https://pypi.douban.com/simple <span class="hljs-comment">#安装pyqt5包</span><br>sudo apt install pyqt5* <span class="hljs-comment">#安装依赖</span><br></code></pre></td></tr></table></figure><p>在Pycharm中进行配置：<br>打开pycharm后点击File - &gt; setting - &gt; Tools - &gt; External Tools, 点击 + 号添加两个文件。<br>（1）第一个是QtDesign用于通过pycharm直接启动QtDesigner，自定义Name（QtDesigner）, Group（Qt5）等参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/designer  <span class="hljs-comment"># 填入Program</span><br><span class="hljs-variable">$FileDir</span>$  <span class="hljs-comment"># 填入Working directory</span><br></code></pre></td></tr></table></figure><p>（2）第二个是将ui文件转换成py文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/usr/bin/python3  <span class="hljs-comment"># 填入Program</span><br>-m PyQt5.uic.pyuic  <span class="hljs-variable">$FileName</span><span class="hljs-variable">$ </span>-o <span class="hljs-variable">$FileNameWithoutExtension</span><span class="hljs-variable">$.</span>py  <span class="hljs-comment"># 填入Arguments</span><br><span class="hljs-variable">$FileDir</span><span class="hljs-variable">$ </span> <span class="hljs-comment"># 填入Working direction</span><br></code></pre></td></tr></table></figure><p>将ui文件转换为py文件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pyuic5 -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>py <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>ui<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/qq_37541097/article/details/80021315">Ubuntu16.04+pycharm+pyqt5安装与配置</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
