<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>肺结节分类任务实现</title>
    <link href="/2021/07/02/%E8%82%BA%E7%BB%93%E8%8A%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/07/02/%E8%82%BA%E7%BB%93%E8%8A%82%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>整理了一下实现肺结节分类的大致流程和关键代码，比较了几种方法的效果。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><ul><li>实验选用的LIDC-IDRI数据集，包含1018个病例2635个肺结节。第一步首先需要<strong>筛选肺结节</strong>，并将肺结节从CT图像中<strong>提取</strong>出来：最终有820个肺结节符合标准，将这些肺结节所在的小立方体从CT中提取出来，边长选这些肺结节最大的等效直径作为边长。  ($1018\times512\times512\times512\rightarrow820\times32\times32\times32$)</li><li>用十折交叉验证法来验证分类效果，训练集、验证集、测试集比例为8：1：1。<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">def get_kfold(<span class="hljs-built_in">labels</span>, k):<br>    stFold = StratifiedKFold(k, True)  # <span class="hljs-built_in">divide</span> <span class="hljs-keyword">in</span> to k(<span class="hljs-number">10</span>) set<br>    folds = [<span class="hljs-number">0</span>] * len(<span class="hljs-built_in">labels</span>)<br>    <span class="hljs-keyword">for</span> i, (x, y) <span class="hljs-keyword">in</span> enumerate(stFold.<span class="hljs-built_in">split</span>(<span class="hljs-built_in">labels</span>, <span class="hljs-built_in">labels</span>)):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> y:<br>            folds[item] = i<br>    <span class="hljs-built_in">return</span> folds<br></code></pre></td></tr></table></figure></li><li>实验中简单起见，对肺结节的二维切片进行分类，选取肺结节所在立方体最中心的<strong>切片</strong>作为该肺结节的图像。  ($820\times32\times32\times32\rightarrow820\times32\times32$)<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> self.dim == <span class="hljs-string">&#x27;2d&#x27;</span>:<br>    x, y, z = voxel.shape<br>    <span class="hljs-comment"># plt.imshow(voxel[x // 2, :, :])</span><br>    <span class="hljs-comment"># plt.show()</span><br>    return [voxel[x <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>, :, :], voxel[:, y <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>, :], voxel[:, :, z <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure></li><li>因为数据还是太少，<strong>对训练数据进行增强</strong>，包括比较常规的数据旋转、翻转、增加噪声、以及平移操作,训练数据扩充为原来的6倍，验证和测试数据保持不变。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> view <span class="hljs-keyword">in</span> self.extract_mutiview(voxel):<br>    im = Image.fromarray(view, mode=<span class="hljs-string">&#x27;L&#x27;</span>)<br>    imf = im.transpose(Image.FLIP_LEFT_RIGHT)<br>    <span class="hljs-keyword">yield</span> [im, <span class="hljs-literal">False</span>]<br>    <span class="hljs-keyword">if</span> self.rotate:<br>        temp = [[im.transpose(Image.ROTATE_90), <span class="hljs-literal">False</span>], [im.transpose(Image.ROTATE_180), <span class="hljs-literal">False</span>],<br>                [im.transpose(Image.ROTATE_270), <span class="hljs-literal">False</span>]]<br>        choice = np.random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, replace=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">yield</span> temp[choice[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">yield</span> temp[choice[<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">if</span> self.hflip:<br>        <span class="hljs-keyword">yield</span> [imf, <span class="hljs-literal">False</span>]<br>    <span class="hljs-keyword">if</span> self.blurring:<br>        <span class="hljs-keyword">yield</span> [im.<span class="hljs-built_in">filter</span>(ImageFilter.GaussianBlur(<span class="hljs-number">1</span>)), <span class="hljs-literal">False</span>]<br>    <span class="hljs-keyword">if</span> self.translation:<br>        temp = [im, im.transpose(Image.ROTATE_90), im.transpose(Image.ROTATE_180),<br>                im.transpose(Image.ROTATE_270)]<br>        choice = np.random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">2</span>,<br>            replace=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">yield</span> [temp[choice[<span class="hljs-number">0</span>]], <span class="hljs-literal">True</span>]  <br>     <br></code></pre></td></tr></table></figure><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2>主要比较了以下算法的效果：</li><li>支持向量机(SVM)  <figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">X_train</span>, y_train = trset[<span class="hljs-number">0</span>].view(<span class="hljs-number">656</span>, <span class="hljs-number">-1</span>).numpy(), trset[<span class="hljs-number">1</span>].numpy()<br><span class="hljs-symbol">X_test</span>, y_test = testset[<span class="hljs-number">0</span>].view(<span class="hljs-number">82</span>, <span class="hljs-number">-1</span>).numpy(), testset[<span class="hljs-number">1</span>].numpy()<br><br>param_grid = [<br>    &#123;<span class="hljs-string">&#x27;C&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>], <span class="hljs-string">&#x27;kernel&#x27;</span>: [<span class="hljs-string">&#x27;linear&#x27;</span>]&#125;,<br>    &#123;<span class="hljs-string">&#x27;C&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1000</span>], <span class="hljs-string">&#x27;gamma&#x27;</span>: [<span class="hljs-number">0.001</span>, <span class="hljs-number">0.0001</span>], <span class="hljs-string">&#x27;kernel&#x27;</span>: [<span class="hljs-string">&#x27;rbf&#x27;</span>]&#125;,<br>]<br>svc = svm.<span class="hljs-symbol">SVC</span>()<br>clf = <span class="hljs-symbol">GridSearchCV</span>(svc, param_grid)<br>clf.fit(<span class="hljs-symbol">X_train</span>, y_train.ravel())<br><br>y_pred = clf.predict(<span class="hljs-symbol">X_test</span>)<br><br># print(<span class="hljs-string">&quot;Classification report for - \n&#123;&#125;:\n&#123;&#125;\n&quot;</span>.format(<br>#     clf, metrics.classification_report(y_test, y_pred)))<br><br>acc, precision, recall, specificity, f1, auc = get_all_metrics(y_test.ravel(), y_pred.ravel())<br></code></pre></td></tr></table></figure></li><li>DenseNet121<br>直接用DenseNet121的预训练模型进行实验，综合实验效果的考虑用预训练参数初始化，然后从头训练。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">model = densenet121(pretrained=True)<br><span class="hljs-selector-id">#model</span><span class="hljs-selector-class">.avgpool</span> = nn<span class="hljs-selector-class">.AdaptiveAvgPool2d</span>((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>model<span class="hljs-selector-class">.classifier</span> = nn<span class="hljs-selector-class">.Sequential</span>(<br>    nn<span class="hljs-selector-class">.Linear</span>(model<span class="hljs-selector-class">.classifier</span><span class="hljs-selector-class">.in_features</span>, <span class="hljs-number">1</span>),<br>    nn<span class="hljs-selector-class">.Sigmoid</span>()<br>)<br><br></code></pre></td></tr></table></figure></li><li>ViT(Vision Transformer)<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">ViT</span>(<span class="hljs-title">nn</span>.<span class="hljs-type">Module</span>):</span><br><span class="hljs-class">    def __init__(<span class="hljs-title">self</span>, *, <span class="hljs-title">image_size</span>, <span class="hljs-title">patch_size</span>, <span class="hljs-title">num_classes</span>, <span class="hljs-title">dim</span>, <span class="hljs-title">depth</span>, <span class="hljs-title">heads</span>, <span class="hljs-title">mlp_dim</span>, <span class="hljs-title">pool</span> = &#x27;<span class="hljs-title">cls&#x27;</span>, <span class="hljs-title">channels</span> = 3, <span class="hljs-title">dim_head</span> = 64, <span class="hljs-title">dropout</span> = 0., <span class="hljs-title">emb_dropout</span> = 0.):</span><br><span class="hljs-class">        super().__init__()</span><br><span class="hljs-class">        image_height, image_width = pair(<span class="hljs-title">image_size</span>)</span><br><span class="hljs-class">        patch_height, patch_width = pair(<span class="hljs-title">patch_size</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        assert image_height % patch_height == 0 and image_width % patch_width == 0, &#x27;<span class="hljs-type">Image</span> dimensions must be divisible by the patch size.&#x27;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        num_patches = (<span class="hljs-title">image_height</span> // <span class="hljs-title">patch_height</span>) * (<span class="hljs-title">image_width</span> // <span class="hljs-title">patch_width</span>)</span><br><span class="hljs-class">        patch_dim = channels * patch_height * patch_width</span><br><span class="hljs-class">        assert pool in &#123;&#x27;cls&#x27;, &#x27;mean&#x27;&#125;, &#x27;pool type must be either cls (<span class="hljs-title">cls</span> <span class="hljs-title">token</span>) or mean (<span class="hljs-title">mean</span> <span class="hljs-title">pooling</span>)&#x27;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        self.to_patch_embedding = nn.<span class="hljs-type">Sequential</span>(</span><br><span class="hljs-class">            <span class="hljs-type">Rearrange</span>(&#x27;<span class="hljs-title">b</span> <span class="hljs-title">c</span> (<span class="hljs-title">h</span> <span class="hljs-title">p1</span>) (<span class="hljs-title">w</span> <span class="hljs-title">p2</span>) -&gt; b (<span class="hljs-title">h</span> <span class="hljs-title">w</span>) (<span class="hljs-title">p1</span> <span class="hljs-title">p2</span> <span class="hljs-title">c</span>)&#x27;, p1 = patch_height, p2 = patch_width),</span><br><span class="hljs-class">            nn.<span class="hljs-type">Linear</span>(<span class="hljs-title">patch_dim</span>, <span class="hljs-title">dim</span>),</span><br><span class="hljs-class">        )</span><br><span class="hljs-class"></span><br><span class="hljs-class">        self.pos_embedding = nn.<span class="hljs-type">Parameter</span>(<span class="hljs-title">torch</span>.<span class="hljs-title">randn</span>(1, <span class="hljs-title">num_patches</span> + 1, <span class="hljs-title">dim</span>))</span><br><span class="hljs-class">        self.cls_token = nn.<span class="hljs-type">Parameter</span>(<span class="hljs-title">torch</span>.<span class="hljs-title">randn</span>(1, 1, <span class="hljs-title">dim</span>))</span><br><span class="hljs-class">        self.dropout = nn.<span class="hljs-type">Dropout</span>(<span class="hljs-title">emb_dropout</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        self.transformer = <span class="hljs-type">Transformer</span>(<span class="hljs-title">dim</span>, <span class="hljs-title">depth</span>, <span class="hljs-title">heads</span>, <span class="hljs-title">dim_head</span>, <span class="hljs-title">mlp_dim</span>, <span class="hljs-title">dropout</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        self.pool = pool</span><br><span class="hljs-class">        self.to_latent = nn.<span class="hljs-type">Identity</span>()</span><br><span class="hljs-class"></span><br><span class="hljs-class">        self.mlp_head = nn.<span class="hljs-type">Sequential</span>(</span><br><span class="hljs-class">            <span class="hljs-title">nn</span>.<span class="hljs-type">LayerNorm(dim)</span>,</span><br><span class="hljs-class">            <span class="hljs-title">nn</span>.<span class="hljs-type">Linear</span>(<span class="hljs-title">dim</span>, <span class="hljs-title">num_classes</span>),</span><br><span class="hljs-class">            nn.<span class="hljs-type">Sigmoid</span>()</span><br><span class="hljs-class">        )</span><br><span class="hljs-class"></span><br><span class="hljs-class">    def forward(<span class="hljs-title">self</span>, <span class="hljs-title">img</span>):</span><br><span class="hljs-class">        x = self.to_patch_embedding(<span class="hljs-title">img</span>)</span><br><span class="hljs-class">        b, n, _ = x.shape</span><br><span class="hljs-class"></span><br><span class="hljs-class">        cls_tokens = repeat(<span class="hljs-title">self</span>.<span class="hljs-title">cls_token</span>, &#x27;() n d -&gt; b n d&#x27;, b = b)</span><br><span class="hljs-class">        x = torch.cat((<span class="hljs-title">cls_tokens</span>, <span class="hljs-title">x</span>), dim=1)</span><br><span class="hljs-class">        x += self.pos_embedding[:, :(<span class="hljs-title">n</span> + 1)]</span><br><span class="hljs-class">        x = self.dropout(<span class="hljs-title">x</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        x = self.transformer(<span class="hljs-title">x</span>)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        x = x.mean(<span class="hljs-title">dim</span> = 1) if self.pool == &#x27;mean&#x27; else x[:, 0]</span><br><span class="hljs-class"></span><br><span class="hljs-class">        x = self.to_latent(<span class="hljs-title">x</span>)</span><br><span class="hljs-class">        return self.mlp_head(<span class="hljs-title">x</span>)</span><br></code></pre></td></tr></table></figure><h2 id="算法训练"><a href="#算法训练" class="headerlink" title="算法训练"></a>算法训练</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css">for data, target in self<span class="hljs-selector-class">.trset</span>:<br>    data = data.<span class="hljs-built_in">cuda</span>(self.device)<br>    target = target.<span class="hljs-built_in">cuda</span>(self.device)<br>    self.optimizer.<span class="hljs-built_in">zero_grad</span>()<br>    output = self.<span class="hljs-built_in">model</span>(data)<br>    trn_acc = <span class="hljs-built_in">calc_accuracy</span>(output, target)<br>    trn_loss = self.<span class="hljs-built_in">loss</span>(output, target)<br>    trn_loss.<span class="hljs-built_in">backward</span>()<br>    self.optimizer.<span class="hljs-built_in">step</span>()<br>    trn_loss_all.<span class="hljs-built_in">append</span>(trn_loss.<span class="hljs-built_in">item</span>())<br>    trn_acc_all.<span class="hljs-built_in">append</span>(trn_acc.<span class="hljs-built_in">cpu</span>())<br># --------------------------------------------------------<br>val_pre, val_tar, val_loss = self.<span class="hljs-built_in">predict</span>(self.valset)<br>tst_pre, tst_tar, _ = self.<span class="hljs-built_in">predict</span>(self.testset)<br>val_acc, _, _, _, _, val_auc = <span class="hljs-built_in">get_all_metrics</span>(val_tar, val_pre)<br>tst_acc, tst_precision, tst_recall, tst_specificity, tst_f1, tst_auc = <span class="hljs-built_in">get_all_metrics</span>(tst_tar, tst_pre)<br>trnloss = np.<span class="hljs-built_in">sum</span>(trn_loss_all) / <span class="hljs-built_in">len</span>(trn_loss_all)<br>trnacc = <span class="hljs-built_in">summery</span>(trn_acc_all)<br>self.scheduler.<span class="hljs-built_in">step</span>(val_loss)<br></code></pre></td></tr></table></figure></li><li>首先每次向网络输入一个batchsize大小的数据进行训练;</li><li>计算网络的输出和ground truth之间的训练误差;</li><li>将误差进行反向传播</li><li>根据梯度和选取的优化器来更新权重，这里选用了adam优化器<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">optimizer = <span class="hljs-constructor">Adam(<span class="hljs-params">filter</span>(<span class="hljs-params">lambda</span> <span class="hljs-params">p</span>: <span class="hljs-params">p</span>.<span class="hljs-params">requires_grad</span>, <span class="hljs-params">model</span>.<span class="hljs-params">parameters</span>()</span>), lr=lr)<br></code></pre></td></tr></table></figure></li><li>所有的batch训练完成后，该epoch训练结束，进行分类效果的验证和测试。</li><li>根据验证集的损失设置了学习率衰减来更精细地调参<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">scheduler</span> = lr_scheduler.ReduceLROnPlateau(optimizer, <span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></li><li>设置早停，在验证集上多个epoch损失没有下降就停止训练，一定程度上防止过拟合<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">if</span> <span class="hljs-keyword">count</span> &gt; <span class="hljs-number">15</span>:<br>    <span class="hljs-keyword">print</span>(f<span class="hljs-string">&#x27;stop at epoch &#123;flag + 1&#125;&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure></li><li>最终保存验证集上效果最好的网络作为最终的网络来测试并输出结果</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/img/densenet.png" alt="denseNet"></p><p><img src="/img/svm.png" alt="SVM"></p><p><img src="/img/vit.png" alt="vit"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.26-7.3)</title>
    <link href="/2021/07/01/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-26-7-3/"/>
    <url>/2021/07/01/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-26-7-3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode_150_逆波兰表达式求值</a><br>思路：</p><ul><li>观察题目中所谓的拟波兰表达式求值方法，在每次遇到算符的时候明显有后进先出的数据结构，因此考虑用栈来实现;</li><li>单独用一个数组实现堆栈功能，维护依次输入的数字，每次遇到算符时取出堆栈顶的数字，根据算符进行计算</li><li>因为python2和python3除法的区别， 在实现除法的时候容易出错，这里用的是python2,普通整数除法的结果只会取整数部分，所以要把除数转化为浮点数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalRPN</span>(<span class="hljs-params">self, tokens</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tokens: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        numbers = []<br>        cals = [<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>]<br>        <span class="hljs-keyword">while</span> tokens:<br>            current = tokens.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> current <span class="hljs-keyword">in</span> cals:<br>                num2 = numbers.pop()<br>                num1 = numbers.pop()<br>                <span class="hljs-keyword">if</span> current == <span class="hljs-string">&quot;+&quot;</span>:<br>                    numbers.append(num1+num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;-&quot;</span>:<br>                    numbers.append(num1-num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;*&quot;</span>:<br>                    numbers.append(num1*num2)<br>                <span class="hljs-keyword">elif</span> current == <span class="hljs-string">&quot;/&quot;</span>:<br>                    numbers.append(<span class="hljs-built_in">int</span>(num1/<span class="hljs-built_in">float</span>(num2)))<br>            <span class="hljs-keyword">else</span>:<br>                numbers.append(<span class="hljs-built_in">int</span>(current))<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><img src="/img/code_sub/150.png" alt="150"></li></ul><p><a href="https://leetcode-cn.com/problems/longest-absolute-file-path/">leetcode_388_文件的最长绝对路径</a><br>思路：</p><ul><li>用\n来分割文件</li><li>用\t来对深度进行区分</li><li>把带有文件的目录进行整合，然后输出最长的<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def lengthLongestPath(self, <span class="hljs-built_in">input</span>):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> inpu<span class="hljs-variable">t:</span> str<br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">files</span> = <span class="hljs-built_in">input</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        levels = [sfile.<span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;\t&#x27;</span>) <span class="hljs-keyword">for</span> sfile in <span class="hljs-keyword">files</span>]<br>        paths = [sfile.replace(<span class="hljs-string">&#x27;\t&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> sfile in <span class="hljs-keyword">files</span>]<br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(levels)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;.&quot;</span> in paths[i]:<br>                sfile = paths[i]<br>                level = levels[i]<br>                order = i<br>                <span class="hljs-keyword">while</span> order &gt; <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> levels[order-<span class="hljs-number">1</span>] == level-<span class="hljs-number">1</span>:<br>                        sfile = paths[order-<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + sfile<br>                        level -= <span class="hljs-number">1</span><br>                    order -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(sfile)<br>        <span class="hljs-keyword">if</span> not re<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>([<span class="hljs-built_in">len</span>(<span class="hljs-keyword">file</span>) <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">res</span>])<br></code></pre></td></tr></table></figure><img src="/img/code_sub/388.png" alt="388"></li></ul><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">leetcode_557_反转字符串中的单词</a><br>思路：<br>这道题直接通过空格把单词分离，然后输出逆序单词合并之后的字符串即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        words = s.split(<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>.join([a[::-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> words])<br></code></pre></td></tr></table></figure><p><img src="/img/code_sub/557.png" alt="557"></p><p><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system/">leetcode_609_在系统中查找重复文件</a><br>思路：</p><ul><li>首先通过空格将不同的路径、文件分离，分离后的列表第一个数据是路径，后面是文件</li><li>因为要找到重复文件，还要用路径加文件名、文件内容的形式输出，所以考虑用字典结构来保存，即key值为文件名，value用list保存该文件名包含的路径</li><li>最后输出value长度大于一，即有重复文件的路径加文件名即可<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def findDuplicate(self, paths):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> path<span class="hljs-variable">s:</span> List[str]<br>        :rtype: List[List[str]]<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        dic = &#123;&#125;<br>        <span class="hljs-keyword">for</span> path in path<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">files</span> = path.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot; &quot;</span>)<br>            addr = <span class="hljs-keyword">files</span>.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span><br>                content = <span class="hljs-keyword">file</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;txt(&quot;</span>, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>                filename = <span class="hljs-keyword">file</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;(&quot;</span>)[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">if</span> content in dic:<br>                    dic[content].<span class="hljs-keyword">append</span>(addr+<span class="hljs-string">&quot;/&quot;</span>+filename)<br>                <span class="hljs-keyword">else</span>:<br>                    dic[content] = [addr+<span class="hljs-string">&quot;/&quot;</span>+filename]<br><br>        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">file</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in dic.<span class="hljs-built_in">values</span>() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-keyword">file</span>) &gt; <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><img src="/img/code_sub/609.png" alt="609"></li></ul><p><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">leetcode_861_翻转矩阵后的得分</a><br>思路：</p><ul><li>首先要想到翻转的次序改变对不会改变最后的结果</li><li>要让数字总和最大，首先要让第一位都是1</li><li>对后面的数，每一列都可以看成离散的点，每一列让这样的点最多</li><li>最后转化成十进制计算总和即可<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matrixScore</span>(<span class="hljs-params">self, grid</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>                grid[i] = [<span class="hljs-number">1</span> - num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> grid[i]]<br>        <br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            sumj = <span class="hljs-built_in">sum</span>([grid[i][j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))])<br>            <span class="hljs-keyword">if</span> sumj &lt; <span class="hljs-built_in">len</span>(grid)/<span class="hljs-number">2.0</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>                    grid[i][j] = <span class="hljs-number">1</span> - grid[i][j]<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            array = grid[i][::-<span class="hljs-number">1</span>]<br>            current = <span class="hljs-built_in">sum</span>([num*<span class="hljs-number">2</span>**j <span class="hljs-keyword">for</span> j,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(array)), array)])<br>            res += current<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><img src="/img/code_sub/861.png" alt="861"></li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.19-6.25)</title>
    <link href="/2021/06/25/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-19-6-25/"/>
    <url>/2021/06/25/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-19-6-25/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">leetcode_804_唯一摩尔斯密码词</a><br>思路：首先字母和摩尔斯编码一一对应，可以用类似哈系表的方法进行转换即可；难点在于去掉重复的翻译，最开始写的方法复杂度都比较高，后来学到python里面可以用set函数来解决，不包含重复数据。</p><blockquote><p>set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniqueMorseRepresentations</span>(<span class="hljs-params">self, words</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type words: List[str]</span><br><span class="hljs-string">    :rtype: int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    Morse = [<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>]<br>    <br>    dicts = &#123;<span class="hljs-string">&quot;&quot;</span>.join(Morse[<span class="hljs-built_in">ord</span>(ch)-<span class="hljs-number">97</span>] <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> word) <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(dicts)<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/804.png" alt="804"></p><p><a href="https://leetcode-cn.com/problems/most-common-word/">leetcode_819_最常见的单词</a><br>思路：</p><ul><li>将句子拆分成单词</li><li>用字典保存出现次数，key是单词，value是次数，即未在字典出现就记一次，字典中存在则value加1</li><li>字典排序，输出第一个key不在banned里面的value</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">class</span> Solution(object):<br>    def mostCommonWord(self, <span class="hljs-built_in">paragraph</span>, banned):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">        :type paragraph: str</span><br><span class="hljs-string">        :type banned: List[str]</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;</span><span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-built_in">paragraph</span> += &#x27; &#x27;<br>        <span class="hljs-built_in">words</span> = []<br>        <span class="hljs-literal">result</span> = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(<span class="hljs-built_in">paragraph</span>)):<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">paragraph</span>[i]&gt;=&#x27;a&#x27; <span class="hljs-keyword">and</span> <span class="hljs-built_in">paragraph</span>[i] &lt;= &#x27;z&#x27;) <span class="hljs-keyword">or</span> (<span class="hljs-built_in">paragraph</span>[i]&gt;=&#x27;A&#x27; <span class="hljs-keyword">and</span> <span class="hljs-built_in">paragraph</span>[i] &lt;= &#x27;Z&#x27;):<br>                <span class="hljs-built_in">words</span>.append(<span class="hljs-built_in">paragraph</span>[i].lower())<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">word</span> = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">words</span>)<br>                <span class="hljs-built_in">words</span> = []<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">word</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">word</span> <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:<br>                    <span class="hljs-literal">result</span>[<span class="hljs-built_in">word</span>] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">word</span>:<br>                        <span class="hljs-literal">result</span>[<span class="hljs-built_in">word</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> (a,b) <span class="hljs-keyword">in</span> sorted(<span class="hljs-literal">result</span>.items(), key=lambda x: x[<span class="hljs-number">1</span>], <span class="hljs-built_in">reverse</span>=True):<br>            <span class="hljs-keyword">if</span> a.lower() <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> banned:<br><span class="hljs-built_in">                return</span> a.lower()<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/819.png" alt="819"></p><p><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">leetcode_842_将数组拆分成斐波那契序列</a><br>思路：</p><ul><li>因为斐波那契数列从第三个数开始都是由前两个书求和得到，所以主体思路就是首先遍历前两个数可能的组成，然后判断剩下的数能否组成正确的数列</li><li>可以进行一定的剪枝优化，比如前两个数字的长度肯定不超过数组长度的1/3</li><li>题目要求的数字大小范围非常容易出错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitIntoFibonacci</span>(<span class="hljs-params">self, num</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        length = <span class="hljs-built_in">len</span>(num)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">3</span>):<br>                <span class="hljs-keyword">if</span> num[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> i&gt;<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> num[i] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> j&gt;<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                num1 = <span class="hljs-built_in">int</span>(num[:i])<br>                num2 = <span class="hljs-built_in">int</span>(num[i:i+j])<br>                <span class="hljs-keyword">if</span> num1 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> num2 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                g1 = num1<br>                g2 = num2<br>                res = [g1, g2]<br>                <span class="hljs-comment"># 前面首先确定前两个数，后面判断是否是正确的数列</span><br>                num3_flag = i+j<br>                <span class="hljs-keyword">if</span> num3_flag &gt; length-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, length // <span class="hljs-number">2</span> + <span class="hljs-number">3</span>):<br>                    <span class="hljs-keyword">if</span> num[num3_flag] == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> k&gt;<span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">while</span> num3_flag + k  &lt;= length:<br>                        num3 = <span class="hljs-built_in">int</span>(num[num3_flag:num3_flag+k])<br>                        <span class="hljs-keyword">if</span> num3 != num1 + num2 <span class="hljs-keyword">or</span> num3 &gt; <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">else</span>:<br>                            res.append(num3)<br>                            <span class="hljs-keyword">if</span> num3_flag+k==length:<br>                                <span class="hljs-keyword">return</span> res<br>                            <span class="hljs-keyword">else</span>:<br>                                num1 = num2<br>                                num2 = num3<br>                                num3_flag += k<br>                res = [g1, g2]<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/842.png" alt="842"></p><p><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/">leetcode_1233_删除子文件夹</a><br>思路：<br>我觉得这道题最核心的思路是首先对文件夹列表进行排序，排序之后对有公共的头的文件夹，短的肯定在长的前面，因此可以依次判断，如果前一个文件夹不是后一个的头，那就肯定不是子文件夹，可以加入结果，并作为新的头，具体如下：</p><ul><li>文件夹列表排序</li><li>依次判断每一个文件夹，是否以上一个文件夹作为开头;</li><li>如果是，则是子文件夹，依序判断下一个;</li><li>如果不是，加入结果列表，更新文件夹头;</li><li>输出结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeSubfolders</span>(<span class="hljs-params">self, folder</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type folder: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        sort_folder = <span class="hljs-built_in">sorted</span>(folder)<br>        res = []<br>        begin = <span class="hljs-string">&#x27;init&#x27;</span><br>        <span class="hljs-keyword">for</span> folders <span class="hljs-keyword">in</span> sort_folder:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> folders.startswith(begin):<br>                begin = folders + <span class="hljs-string">&#x27;/&#x27;</span>  <span class="hljs-comment"># 解决/a/b/c,/a/b/ca判断错误的问题</span><br>                res.append(folders)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/1233.png" alt="1233"></p><p><a href="https://leetcode-cn.com/problems/making-file-names-unique/">leetcode_1487_保证文件名唯一</a><br>思路：</p><ul><li>同样可以用字典实现：key是文件夹名，value是出现次数 </li><li>遍历文件夹名，如果没有出现过，则加入字典，value记为1</li><li>如果已经出现过，则需要加括号，根据出现次数来确定括号内数字，并将新名称加入字典，同时原名称也需要+1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFolderNames</span>(<span class="hljs-params">self, names</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type names: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dic = &#123;&#125;<br>        res = []<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>            <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dic:<br>                dic[name] = <span class="hljs-number">1</span><br>                res.append(name)<br>            <span class="hljs-keyword">else</span>:<br>                curName = name + <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">str</span>(dic[name]) + <span class="hljs-string">&quot;)&quot;</span><br>                <span class="hljs-keyword">while</span> curName <span class="hljs-keyword">in</span> dic:<br>                    dic[name] += <span class="hljs-number">1</span><br>                    curName = name + <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">str</span>(dic[name]) + <span class="hljs-string">&quot;)&quot;</span><br>                dic[curName] = <span class="hljs-number">1</span><br>                dic[name] += <span class="hljs-number">1</span><br>                res.append(curName)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><img src="/img/6.25_code_sub/1487.png" alt="1487"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-12-14章笔记</title>
    <link href="/2021/06/22/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-12-14%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/22/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-12-14%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="12-1-12-2-误差分析"><a href="#12-1-12-2-误差分析" class="headerlink" title="12.1-12.2 误差分析"></a>12.1-12.2 误差分析</h2><p><img src="/img/ML_WED_1214/12.2.1.png" alt="推荐的机器学习系统设计方法"></p><ul><li>首先花较短的时间(比如一天时间)非常简单地把整个系统流程实现出来，然后把添加更多数据，更多特征等的学习曲线画出来，这样可以直观的看出每种方法对效果的提升，而不是依靠直觉判断怎么设计系统。</li><li>误差分析：观察验证集上被错误分类的数据有没有什么共同特点，以此来获得优化的灵感</li><li>通过数值估计模型效果好坏<ul><li> 交叉验证使用和不使用某算法的效果</li></ul></li></ul><h2 id="12-3-不对称分类的误差评估"><a href="#12-3-不对称分类的误差评估" class="headerlink" title="12.3 不对称分类的误差评估"></a>12.3 不对称分类的误差评估</h2><p>偏斜类（skewed classes）中需要的评估指标：精确率和召回率 Precision/Recall</p><p>二分类常用的评价指标总结：</p><ul><li>正确率：$$\frac{TP+TN}{TP=FP+TN+FN}$$</li><li>召回率（正例被找出的比例）：$$\frac{TP}{TP+FN}$$</li><li>特异度（反例被找出的比例）：$$\frac{TN}{TN+FP}$$</li><li>精确率（被判断为正例的正确的比例）：$$\frac{TP}{TP+FP}$$</li><li>F1 score（兼顾精确率和召回率）：$$\frac{2}{\frac{1}{Precision}+\frac{1}{Recall}}$$</li><li>AUC：ROC曲线下面积</li></ul><h2 id="12-4-精确率和召回率的权衡"><a href="#12-4-精确率和召回率的权衡" class="headerlink" title="12.4 精确率和召回率的权衡"></a>12.4 精确率和召回率的权衡</h2><p><img src="/img/ML_WED_1214/12.4.1.png" alt="召回率和精确率的权衡"></p><blockquote><p>在实际应用中，根据不同的要求可以设计不同的分类阈值来提高精确率或者召回率，通常一个提高另一个会降低。<br>自动权衡召回率和精确率：F1 Score</p></blockquote><h2 id="12-5-机器学习数据"><a href="#12-5-机器学习数据" class="headerlink" title="12.5 机器学习数据"></a>12.5 机器学习数据</h2><p>获取更多数据可以获得效果良好的模型需要满足以下假设：</p><ul><li>假设数据中包含足够的信息来准确预测结果<ul><li>有效的测试方法是考虑人类专家能否从数据中的信息来准确预测结果</li></ul></li><li>使用具有许多参数的学习算法<ul><li>训练损失可以降到很小</li></ul></li><li>使用很大的训练集（不容易过拟合）<ul><li>测试误差可以接近训练误差</li></ul></li></ul><hr><h2 id="13-1-支持向量机优化目标"><a href="#13-1-支持向量机优化目标" class="headerlink" title="13.1 支持向量机优化目标"></a>13.1 支持向量机优化目标</h2><p><img src="/img/ML_WED_1214/13.1.1.png" alt="从逻辑回归的角度考虑支持向量机"><br>如图，用红色的损失函数代替逻辑回归蓝色的损失函数</p><p><img src="/img/ML_WED_1214/13.1.2.png" alt="支持向量机表示"></p><ul><li>去掉了$\frac{1}{m}$</li><li>用优化$CA+B$代替了逻辑回归优化$A+\lambda B$</li></ul><p><img src="/img/ML_WED_1214/13.1.3.png" alt="SVM损失函数"><br>SVM直接预测y=1或0</p><h2 id="13-2-大间隔优化器"><a href="#13-2-大间隔优化器" class="headerlink" title="13.2 大间隔优化器"></a>13.2 大间隔优化器</h2><p><img src="/img/ML_WED_1214/13.2.2.png" alt="SVM损失函数的安全间距"><br>SVM的决策边界和训练样本的最小距离要比其他方法更远，这个距离称为SVM的间距（Maragin），使SVM具有更好的鲁棒性<br><img src="/img/ML_WED_1214/13.2.3.png" alt="间距"><br><img src="/img/ML_WED_1214/13.2.1.png" alt="参数C的影响"><br>当C设置得非常非常大的时候，SVM会严重受到异常点的影响</p><h2 id="13-4-13-5-核函数"><a href="#13-4-13-5-核函数" class="headerlink" title="13.4-13.5 核函数"></a>13.4-13.5 核函数</h2><blockquote><p>问题描述：我们之前用x的高阶项作为特征，但我们并不知道这些特征是否是需要的，而且同时这种方法计算量也较大，因此是否存在更好的特征设计方法？<br><img src="/img/ML_WED_1214/13.4.1.png" alt="问题描述"></p></blockquote><p>方法：</p><ul><li>手工选择一些点(标记landmark)（$l^{(1)},l^{(2)},l^{(3)}$）</li><li>定义特征$f$为x和标记的相似度，相似度函数就是核函数，如高斯核函数:<br>$$f1=similarity(x,l^{(1)})=e^{-\frac{||x-l^{(1)}||^2}{2\sigma^2}}$$</li></ul><p><img src="/img/ML_WED_1214/13.4.2.png" alt="核函数和相似度"><br>可以看到，当x和选定的l很近时，f的取值接近1,反之接近0</p><p><img src="/img/ML_WED_1214/13.4.3.png" alt="核函数的例子"><br>以l取(3,5)为例，可以画出f的取值图像，如果所示纵坐标就是f的取值，在靠近l的时候取值接近1;可以通过改变$\sigma$的取值调节f的变化速度</p><p><img src="/img/ML_WED_1214/13.4.4.png" alt="决定决策边界"></p><p>如何选择这些标记l：<strong>直接将训练样本作为标记点</strong></p><ul><li>给出训练集$(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\cdots,(x^{(m)},y^{(m)})$</li><li>选择标记点$l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},\cdots,l^{(m)}=x^{(m)}$</li><li>计算相似度：$f_1=similarity(x,l^{(1)})\cdots$,得到特征向量$f^{(i)}=[f_1^{(i)},f_2^{(i)},\cdots,f_m^{(i)}]$</li><li>预测$y=1$,当$\theta^T f\geq 0$</li><li>计算使损失最小的参数\theta</li></ul><p>参数选择：</p><ul><li>$C(=\frac{1}{\lambda})$<ul><li>更大的C：低偏差，高方差（过拟合）</li><li>更小的C:低方差，高偏差（欠拟合）</li></ul></li><li>$ \sigma^2$<ul><li>更大：低方差，高偏差（欠拟合）</li><li>更小：低偏差，高方差（过拟合）<br><img src="/img/ML_WED_1214/13.5.1.png" alt="参数的选择"></li></ul></li></ul><h2 id="14-1-14-2-K-Means算法"><a href="#14-1-14-2-K-Means算法" class="headerlink" title="14.1-14.2 K-Means算法"></a>14.1-14.2 K-Means算法</h2><p>监督学习：有标签，通过损失函数去拟合<br>无监督学习：无标签，让算法找到隐含在数据中的结构</p><p>KMeans算法步骤：</p><ul><li>随机生成两点作为聚类中心</li><li>簇分配：遍历每个样本，根据每个点和聚类中心的距离，分配给更近的中心</li><li>移动聚类中心：将两个聚类中心移动到同类的中心处（没有点的聚类中心直接去掉）</li><li>重复第二步和第三步，直到聚类中心不再改变<br><img src="/img/ML_WED_1214/14.1.1.png" alt="K-Means聚类"><br><img src="/img/ML_WED_1214/14.1.2.png" alt="K-Means算法对分离不佳的簇表现良好"></li></ul><h2 id="14-3-优化目标"><a href="#14-3-优化目标" class="headerlink" title="14.3 优化目标"></a>14.3 优化目标</h2><p><img src="/img/ML_WED_1214/14.3.1.png" alt="优化目标"><br>其中簇分配的步骤通过优化c来最小化损失，移动聚类中心的步骤通过优化$\mu$来最小化损失</p><h2 id="14-4-随机初始化"><a href="#14-4-随机初始化" class="headerlink" title="14.4 随机初始化"></a>14.4 随机初始化</h2><p>随机生成聚类中心的方法：</p><ul><li>保证$K&lt;m$</li><li>随机选取K个训练样本</li><li>设置$\mu_1,\mu_2,\cdots,\mu_K$等于这K个样本</li></ul><p><img src="/img/ML_WED_1214/14.4.1.png" alt="K-Means可能陷入局部极小"><br>解决方法：多次随机初始化，并选取损失值最小的（尤其是K较小的时候更重要，比如$2&lt;k&lt;10$）</p><h2 id="14-5-选取聚类数量"><a href="#14-5-选取聚类数量" class="headerlink" title="14.5 选取聚类数量"></a>14.5 选取聚类数量</h2><p><img src="/img/ML_WED_1214/14.5.1.png" alt="肘部原则"><br>聚类数量选择方法：</p><ul><li>Elbow Method：改变K，即聚类总数，画出损失函数J的图像，选择肘部的值作为聚类数量，但有时图像没有一个明显的“肘部”</li><li>看哪个数量对后续的目的更有效</li><li>经常手动选择</li></ul>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据技术原理与应用-林子雨-笔记</title>
    <link href="/2021/06/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-%E6%9E%97%E5%AD%90%E9%9B%A8-%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8-%E6%9E%97%E5%AD%90%E9%9B%A8-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.icourse163.org/course/XMU-1002335004?from=searchPage">课程地址</a></p><h2 id="第一章-大数据概述"><a href="#第一章-大数据概述" class="headerlink" title="第一章 大数据概述"></a>第一章 大数据概述</h2><h3 id="1-1-大数据时代"><a href="#1-1-大数据时代" class="headerlink" title="1.1 大数据时代"></a>1.1 大数据时代</h3><ul><li>2010年前后，以<strong>云计算</strong>、<strong>大数据</strong>、<strong>物联网</strong>的普及为标志迎来第三次信息化浪潮<br><img src="/img/bigData/1.1.1.png" alt="三次信息化浪潮"></li><li>技术支撑：存储、计算、网络<ul><li>存储设备容量不断增加，个人数据越来越多，企业数据越来越多</li><li>CPU处理能力大幅提升</li><li>网络带宽不断增加</li></ul></li></ul><p><img src="/img/bigData/1.1.2.png" alt="数据产生方式三个阶段"><br>感知式系统阶段：物联网的大规模普及</p><ul><li>物联网底层是感知层，如RFID，摄像头，传感器</li></ul><p><img src="/img/bigData/1.1.3.png" alt="大数据发展历程"></p><h3 id="1-2-大数据概念和影响"><a href="#1-2-大数据概念和影响" class="headerlink" title="1.2 大数据概念和影响"></a>1.2 大数据概念和影响</h3><p><img src="/img/bigData/1.2.1.png" alt="大数据特点"></p><ul><li>大数据摩尔定律</li><li>大数据由结构化和非结构化数据组成<ul><li>大部分数据都是非结构化数据</li></ul></li><li>数据处理快，秒级决策</li><li>价值密度低，商业价值高</li></ul><blockquote><p>大数据的到来使得科学研究出现了第四种范式<br><img src="/img/bigData/1.2.2.png" alt="四种研究范式"></p></blockquote><p>大数据三个方面的影响：</p><ul><li>全样而非抽样</li><li>效率而非精确</li><li>相关而非因果</li></ul><h3 id="1-3-大数据的应用"><a href="#1-3-大数据的应用" class="headerlink" title="1.3 大数据的应用"></a>1.3 大数据的应用</h3><p><img src="/img/bigData/1.3.1.png" alt="大数据的应用"></p><h3 id="1-4-大数据关键技术"><a href="#1-4-大数据关键技术" class="headerlink" title="1.4 大数据关键技术"></a>1.4 大数据关键技术</h3><p>两大核心技术：</p><ul><li>分布式存储<br><img src="/img/bigData/1.4.1.png" alt="分布式处理"></li><li>分布式处理<br><img src="/img/bigData/1.4.2.png" alt="分布式存储"></li></ul><p>大数据技术以谷歌公司技术为代表：</p><ul><li>分布式数据库BigTable</li><li>分布式文件系统GFS</li><li>分布式并行处理技术MapReduce</li></ul><p>不同的计算模式需要使用不同的产品<br><img src="/img/bigData/1.4.3.png" alt="不同的计算模式"></p><h3 id="1-5-云计算"><a href="#1-5-云计算" class="headerlink" title="1.5 云计算"></a>1.5 云计算</h3><p>两大核心问题：分布式存储，分布式处理<br>典型特征：虚拟化，多租户<br>优势:不需要自建IT设施,可以租用云端资源</p><blockquote><p>云计算是通过网络以服务的方式为用户提供非常廉价的IT资源</p></blockquote><p>云计算的三种模式:</p><ul><li>共有云</li><li>私有云</li><li>混合云</li></ul><p><img src="/img/bigData/1.5.1.png" alt="三种云服务"></p><ul><li>IaaS:基础设施即服务,将基础设施(计算资源和存储)作为服务出租</li><li>PaaS:平台即服务,云平台开发环境和接口(Google App Engine)</li><li>SaaS:软件即服务,典型:云财务软件</li></ul><p><img src="/img/bigData/1.5.2.png" alt="云计算关键技术"></p><h3 id="1-5-2-物联网"><a href="#1-5-2-物联网" class="headerlink" title="1.5.2 物联网"></a>1.5.2 物联网</h3><p>物联网（IoT, The Internet of Things），就是物物相连的互联网，是互联网的延伸<br><img src="/img/bigData/1.5.3.png" alt="物联网层次架构"></p><p>物联网的关键技术：</p><ul><li>识别技术<ul><li>条形码唯一标识包裹</li><li>二维码</li><li>RFID（无线射频识别）<ul><li>线圈刷卡时就是切割磁力线产生电流 </li></ul></li></ul></li><li>感知技术</li></ul><p><img src="/img/bigData/1.5.3.png" alt="大数据、物联网、云计算关系"></p><h2 id="第二章-大数据处理架构Hadoop"><a href="#第二章-大数据处理架构Hadoop" class="headerlink" title="第二章 大数据处理架构Hadoop"></a>第二章 大数据处理架构Hadoop</h2><h3 id="2-1-1-Hadoop简介"><a href="#2-1-1-Hadoop简介" class="headerlink" title="2.1.1 Hadoop简介"></a>2.1.1 Hadoop简介</h3><ul><li>Hadoop是Apache软件基金会旗下开源软件</li><li>Hadoop可以支持多种编程语言</li><li>Hadoop两大核心,实现海量数据的分布式存储和分布式处理：<ul><li>HDFS：分布式存储</li><li>MapReduce：分布式处理</li></ul></li></ul><p>谷歌发布了多种大数据技术</p><ul><li>2003年，谷歌发布了分布式文件系统GFS(Google File System)-&gt;HDFS</li><li>2004年，谷歌发布了分布式并行编程框架MapReduce</li></ul><p>Hadoop特点：</p><ul><li>高可靠性</li><li>高效性</li><li>高可扩展性</li><li>高容错性</li><li>成本低：可以采用普通PC机来构成一个集群</li><li>支持多种编程语言<br><img src="/img/bigData/2.1.1.png" alt="Hadoop企业应用结构"></li></ul><h3 id="2-1-2-Hadoop的不同版本"><a href="#2-1-2-Hadoop的不同版本" class="headerlink" title="2.1.2 Hadoop的不同版本"></a>2.1.2 Hadoop的不同版本</h3><p><img src="/img/bigData/2.1.2.png" alt="Hadoop版本"><br>Hadoop1.0的核心：HDFS,MapReduce（数据处理，资源调度）<br>Hadoop2.0的核心：HDFS,MapReduce,Yarn,Others,分解了MapReduce资源调度功能，组成Yarn</p><ul><li>Yarn可以支持Spark，Storm，MapReduce等 等</li><li>HDFS:NN Federation, HA</li></ul><h3 id="2-2-Hadoop项目结构"><a href="#2-2-Hadoop项目结构" class="headerlink" title="2.2 Hadoop项目结构"></a>2.2 Hadoop项目结构</h3><p><img src="/img/bigData/2.2.1.png" alt="Hadoop项目结构"></p><ul><li>HDFS：分布式文件存储</li><li>YARN：计算资源调度</li><li>MapReduce：离线计算</li><li>Tez：把MapReduce作业优化、构建成有向无环图，保证获得最好的处理效果</li><li>Spark：基于内存（MapReduce基于磁盘）</li><li>Hive：Hadoop上的数据仓库，把SQL语句转成MapReduce作业</li><li>Pig：流数据处理，类似SQL查询语言Pig Latin</li><li>Oozie：Hadoop上的工作流管理系统</li><li>ZooKeeper：提供分布式协调一致性服务</li><li>Hbase：分布式数据库</li><li>Flume：日志收集</li><li>Sqoop：数据导入、导出</li><li>Ambari：Hadoop快速部署工具</li></ul><h3 id="2-3-Hadoop安装"><a href="#2-3-Hadoop安装" class="headerlink" title="2.3 Hadoop安装"></a>2.3 Hadoop安装</h3><h3 id="2-4-Hadoop集群的部署和使用"><a href="#2-4-Hadoop集群的部署和使用" class="headerlink" title="2.4 Hadoop集群的部署和使用"></a>2.4 Hadoop集群的部署和使用</h3><p>Hadoop核心：HDFS+MapReduce<br>HDFS：</p><ul><li>一个名称节点（NameNode）：应用首先访问NameNode获得关于数据的节点位置<ul><li>管理各种元数据并提供服务</li><li>NameNode里面有很多元数据都是直接保存在内存当中</li></ul></li><li>若干个数据节点（DataNode）：存储数据</li><li>SecondaryNameNode：冷备份<br>MapReduce:</li><li>JobTraker：对用户作业进行管理</li><li>TaskTracker：不同机器上安装，跟踪和执行分配给自己的作业</li></ul><h2 id="第三章-分布式文件系统HDFS"><a href="#第三章-分布式文件系统HDFS" class="headerlink" title="第三章 分布式文件系统HDFS"></a>第三章 分布式文件系统HDFS</h2><h3 id="3-1-分布式文件系统HDFS简介"><a href="#3-1-分布式文件系统HDFS简介" class="headerlink" title="3.1 分布式文件系统HDFS简介"></a>3.1 分布式文件系统HDFS简介</h3><p>解决核心问题：分布式存储</p><p><img src="/img/bigData/3.1.1.png" alt="计算机集群基本架构"><br><img src="/img/bigData/3.1.2.png" alt="文件系统结构"></p><p>实现目标：</p><ul><li>兼容廉价的硬件设备</li><li>实现流数据读写</li><li>支持大数据集</li><li>支持简单的文件模型</li><li>强大的跨平台兼容性</li></ul><p>局限性：</p><ul><li>不适合低延迟数据访问，实时性不高（HBase具有随机读写特性）</li><li>无法高效存储大量小文件</li><li>不支持多用户写入及任意修改文件</li></ul><h3 id="3-2-HDFS相关概念"><a href="#3-2-HDFS相关概念" class="headerlink" title="3.2 HDFS相关概念"></a>3.2 HDFS相关概念</h3><p>最核心的概念：块</p><ul><li>联系：分摊磁盘读写开销，也就是在大量数据间分摊磁盘寻址的开销</li><li>区别：HDFS的一个块比普通文件系统的块大很多<br>目的：</li><li>支持面向大规模数据存储</li><li>降低分布式节点的寻址开销<br>缺点：</li><li>块过大影响MapReduce的并行效果<br>优点：</li><li>支持大规模文件存储</li><li>简化系统设计</li><li>适合数据备份</li></ul><p>名称节点（NameNode）：主节点，整个HDFS集群的管家，相当于数据目录，存储元数据</p><ul><li>元数据内容：文件是什么，被分成多少快，块和文件怎么映射，每个块存储在哪个服务器上面</li><li>FsImage：保存系统文件树<br><img src="/img/bigData/3.1.3.png" alt="FsImage"></li><li>EditLog：记录对数据的操作</li></ul><p><img src="/img/bigData/3.1.4.png" alt="系统流程"><br>第二名称节点：名称节点的冷备份；解决editlog太大的问题</p><p>数据节点（DataNode）：存储实际数据，保存到本地Linux系统中</p><h3 id="3-3-HDFS的体系结构"><a href="#3-3-HDFS的体系结构" class="headerlink" title="3.3 HDFS的体系结构"></a>3.3 HDFS的体系结构</h3><p><img src="/img/bigData/3.3.1.png" alt="HDFS的体系结构"></p><p>HDFS命名空间：1个，包含目录、文件、块 /+目录名称<br><img src="/img/bigData/3.3.2.png" alt="通信协议"><br>局限性：<br><img src="/img/bigData/3.3.3.png" alt="HDFS的局限性"></p><p>HDFS2.0：热备+名称节点</p><h3 id="3-4-HDFS的存储管理"><a href="#3-4-HDFS的存储管理" class="headerlink" title="3.4 HDFS的存储管理"></a>3.4 HDFS的存储管理</h3><p>冗余数据保存的问题：</p><ul><li>因为容易出故障，每个数据都会冗余保存（如三份）<ul><li>加快数据传输速度</li><li>很容易检查数据错误</li><li>保证数据可靠性<br>数据保存策略</li></ul></li></ul><h2 id="第四章-分布式数据库HBase"><a href="#第四章-分布式数据库HBase" class="headerlink" title="第四章 分布式数据库HBase"></a>第四章 分布式数据库HBase</h2><h3 id="4-1-HBase简介"><a href="#4-1-HBase简介" class="headerlink" title="4.1 HBase简介"></a>4.1 HBase简介</h3><p>BigTable的开源实现</p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.12-6.18)</title>
    <link href="/2021/06/17/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-12-6-18/"/>
    <url>/2021/06/17/%E6%AF%8F%E5%91%A8%E4%BB%A3%E7%A0%81-6-12-6-18/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/reverse-string/">leetcode_344_反转字符串</a><br>思路:直接用双指针将头尾依次交换即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseString</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: List[str]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify s in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">0</span><br>        high = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(low &lt; high):<br>            s[low], s[high] = s[high], s[low]<br>            low += <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/344.png" alt="344"></p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">leetcode_345_反转字符串中的元音字母</a><br>思路:与344题非常相似,只需要每次反转前加上是否是元音字母的判断;<br>判断都在元音字母中,同时满足左指针低于右指针,再继续反转即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseVowels</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        target = <span class="hljs-string">&#x27;aeiouAEIOU&#x27;</span><br>        low = <span class="hljs-number">0</span><br>        high = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>        list_s = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">while</span>(list_s[low] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> target <span class="hljs-keyword">and</span> low &lt; <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>                low += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(list_s[high] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> target <span class="hljs-keyword">and</span> high &gt;= <span class="hljs-number">0</span>):<br>                high -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> high &lt;= low:<br>                <span class="hljs-keyword">break</span><br>            list_s[low], list_s[high] = list_s[high], list_s[low]<br>            low += <span class="hljs-number">1</span><br>            high -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(list_s)<br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/345.png" alt="345"></p><p><a href="https://leetcode-cn.com/problems/ransom-note/">leetcode_383_赎金信</a><br>思路:同样是字符串操作相关,开始没有想到较好的解决办法,时间复杂度比较高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        target = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(ransomNote))<br>        mag = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(magazine))<br><br>        <span class="hljs-keyword">while</span>(mag <span class="hljs-keyword">and</span> target):<br>            <span class="hljs-keyword">if</span> target[<span class="hljs-number">0</span>] &lt; mag[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> target[<span class="hljs-number">0</span>] == mag[<span class="hljs-number">0</span>]:<br>                mag.pop(<span class="hljs-number">0</span>)<br>                target.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">else</span>:<br>                mag.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> target:<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/383_1.png" alt="383_暴力"><br>看了看题解,比较适合用桶排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># ransom = [0] * 26</span><br>        mag = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(magazine)):<br>            num = <span class="hljs-built_in">ord</span>(magazine[i])-<span class="hljs-number">97</span><br>            mag[num] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ransomNote)):<br>            num = <span class="hljs-built_in">ord</span>(ransomNote[i])-<span class="hljs-number">97</span><br>            mag[num] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> mag[num] &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/383_2.png" alt="383_桶排序"></p><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">leetcode_541_反转字符串II</a><br>思路:直接暴力反转即可,最开始写了不少边界判断,后来发现其实没有必要  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseStr</span>(<span class="hljs-params">self, s, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        a = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a), <span class="hljs-number">2</span>*k):<br>            a[i:i+k] = <span class="hljs-built_in">reversed</span>(a[i:i+k])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(a)<br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/541.png" alt="541"></p><p><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">leetecode_657_机器人能否回原点</a><br>思路:左右(或上下)和为0可以回原点  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgeCircle</span>(<span class="hljs-params">self, moves</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type moves: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        vertical = &#123;<br>            <span class="hljs-string">&#x27;U&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;D&#x27;</span>: -<span class="hljs-number">1</span><br>        &#125;<br>        horizontal = &#123;<br>            <span class="hljs-string">&#x27;L&#x27;</span>: -<span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;R&#x27;</span>: <span class="hljs-number">1</span><br>        &#125;<br>        v = <span class="hljs-number">0</span><br>        h = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(moves)):<br>            <span class="hljs-keyword">if</span> moves[i] <span class="hljs-keyword">in</span> vertical:<br>                v += vertical[moves[i]]<br>            <span class="hljs-keyword">else</span>:<br>                h += horizontal[moves[i]]<br>        <span class="hljs-keyword">if</span> v==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> h==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><img src="/img/6.17_code_sub/657.png" alt="657"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-5、7-10章笔记</title>
    <link href="/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/14/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="5-1-5-2-多元线性回归"><a href="#5-1-5-2-多元线性回归" class="headerlink" title="5.1-5.2 多元线性回归"></a>5.1-5.2 多元线性回归</h2><p><img src="/img/ML_WED_78910/5.1.1.png" alt="变量表示"><br>$x_{j}^{(i)}$:第i组输入的第j个特征<br><img src="/img/ML_WED_78910/5.1.2.png" alt="多元线性回归的公式表示"><br>多元线性回归的假设函数:<br>$$h_\theta(x)=\theta_0+\theta_1 x_1+\theta_2 x_2+\cdots+\theta_n x_n=\theta^Tx$$</p><p><img src="/img/ML_WED_78910/5.1.3.png" alt="多元线性回归和单变量线性回归梯度下降的比较"><br>单变量线性回归只是多元问题的特殊形式，如图所示两者的梯度下降过程是等价的</p><h2 id="5-3-特征缩放"><a href="#5-3-特征缩放" class="headerlink" title="5.3 特征缩放"></a>5.3 特征缩放</h2><p><img src="/img/ML_WED_78910/5.1.4.png" alt="特征缩放"><br>考虑到不同特征的取值范围差别太大会影响梯度下降的正常工作，可以对不同特性进行缩放，大致落在相似的范围内（比如[-1,1]）</p><p><a href="https://www.zhihu.com/question/20467170">各种缩放方法可以参考知乎上的回答</a></p><p><img src="/img/ML_WED_78910/5.1.5.png" alt="标准化"><br>其中一种方法就是对特征进行均值标准化：<br>$$x:=\frac{x-mean(x)}{max(x)-min(x)}$$</p><h2 id="5-4-多元梯度下降"><a href="#5-4-多元梯度下降" class="headerlink" title="5.4 多元梯度下降"></a>5.4 多元梯度下降</h2><p>多元梯度下降中的问题:</p><ul><li>如何确保梯度下降在正确工作</li><li>如何有效选择学习率$\alpha$</li></ul><p><img src="/img/ML_WED_78910/5.1.6.png" alt="损失值的迭代图"><br>可以通过观察损失函数值随着迭代次数的变化来监控梯度下降工作，并根据损失值的变化特点调节学习率<br><img src="/img/ML_WED_78910/5.1.7.png" alt="学习率太大或太小可能出现的问题"></p><ul><li>学习率太小，收敛非常缓慢 </li><li>学习率太大，损失不会一直保持下降趋势，甚至不会收敛，也可能收敛缓慢</li></ul><h2 id="5-5-特征和多项式回归"><a href="#5-5-特征和多项式回归" class="headerlink" title="5.5 特征和多项式回归"></a>5.5 特征和多项式回归</h2><p><img src="/img/ML_WED_78910/5.5.1.png" alt="设计新的特征"><br>思路：有时候通过定义新的特征可能会得到更好的模型</p><blockquote><p>图中,与将长和宽作为特征进行训练相比,将长乘宽即面积作为新的特征用于线性回归更符合逻辑</p></blockquote><p><img src="/img/ML_WED_78910/5.5.2.png" alt="多项式回归"><br>根据数据特点灵活选用二次、三次项等作为特征，但此时特征缩放也变得更重要</p><hr><h2 id="7-1-分类"><a href="#7-1-分类" class="headerlink" title="7.1 分类"></a>7.1 分类</h2><p><img src="/img/ML_WED_78910/6.1.1.png" alt="分类问题"><br>一般用负类表示没有xxx的那一类（没有肿瘤、不是垃圾邮件etc.）</p><p><img src="/img/ML_WED_78910/6.1.2.png" alt="分类问题的阈值设置"><br>如果用线性回归解决分类问题，函数会很大程度受到离群数据的影响导致拟合效果很差<br><strong>逻辑回归</strong>（就是分类）：$0\leq h_\theta(x)\leq 1$</p><h2 id="7-2-假设表示"><a href="#7-2-假设表示" class="headerlink" title="7.2 假设表示"></a>7.2 假设表示</h2><p><img src="/img/ML_WED_78910/6.2.1.png" alt="逻辑回归模型"><br>比较：<br>线性回归：$h_\theta(x)=\theta^T x$<br>逻辑回归：$h_\theta(x)=g(\theta^T x)$<br>其中$g(z)=\frac{1}{1+e^{-z}}$(sigmoid函数)<br>最终：<br>$$h_\theta(x)=\frac{1}{1+e^{-\theta^T x}}$$用参数$\theta$拟合数据</p><p><img src="/img/ML_WED_78910/6.2.2.png" alt="假设函数输出的解释"><br>$h_\theta(x)$表示对给定的$x$,$y=1$的可能性（概率）</p><h2 id="7-3-决策边界"><a href="#7-3-决策边界" class="headerlink" title="7.3 决策边界"></a>7.3 决策边界</h2><p><img src="/img/ML_WED_78910/6.3.1.png" alt="决策边界"><br>通过训练集拟合参数$\theta$来决定决策边界</p><h2 id="7-4-7-5-代价函数"><a href="#7-4-7-5-代价函数" class="headerlink" title="7.4-7.5 代价函数"></a>7.4-7.5 代价函数</h2><p>如何拟合参数$\theta\rightarrow$代价函数<br><img src="/img/ML_WED_78910/6.4.1.png" alt="损失函数"></p><blockquote><p>问题：使用均方误差作为损失函数是非凸函数，不能保证收敛到全局最小</p></blockquote><p><img src="/img/ML_WED_78910/6.4.2.png" alt="逻辑回归损失函数(y=1)"><br>$y=1$时损失函数的直观理解，当预测$P(y=1|x;\theta)=0$，损失值无限大</p><p><img src="/img/ML_WED_78910/6.4.3.png" alt="逻辑回归损失函数(y=0)"><br>同理，$y=0$时,当预测$P(y=0|x;\theta)=1$，损失值无限大</p><p><img src="/img/ML_WED_78910/6.4.4.png" alt="损失函数优化"><br>将损失函数表示形式进行优化，最后损失函数（BCE）的表示如下：<br>$$J(\theta)=-\frac{1}{m}[\sum_{i=1}^m y^{(i)}\log h_{\theta}(x^{(i)})+(1-y^{(i)})\log(1-h_{\theta}(x^{(i))})]$$</p><p><img src="/img/ML_WED_78910/6.4.5.png" alt="逻辑回归的梯度下降"><br>可以看到逻辑回归的参数更新公式，化简后和现行回归是一样的，只是假设函数有所区别</p><h2 id="7-6-高级优化"><a href="#7-6-高级优化" class="headerlink" title="7.6 高级优化"></a>7.6 高级优化</h2><p><img src="/img/ML_WED_78910/7.6.1.png" alt="高级优化算法"></p><h2 id="7-7-一对多"><a href="#7-7-一对多" class="headerlink" title="7.7 一对多"></a>7.7 一对多</h2><p><img src="/img/ML_WED_78910/6.7.1.png" alt="高级优化算法"><br>将多分类问题转化为多个二分类问题,训练多个假设函数,预测的时候取$h_\theta^{(x)}$最大的作为分类预测结果</p><hr><h2 id="8-1-过拟合问题"><a href="#8-1-过拟合问题" class="headerlink" title="8.1 过拟合问题"></a>8.1 过拟合问题</h2><h3 id="过拟合与欠拟合描述"><a href="#过拟合与欠拟合描述" class="headerlink" title="过拟合与欠拟合描述"></a>过拟合与欠拟合描述</h3><ul><li>欠拟合：数据拟合效果很差，偏差很大  </li><li>过拟合：千方百计地拟合了训练集，无法泛化到新的样本中，方差很大</li><li>泛化：一个假设模型应用到新样本的能力</li></ul><p><img src="/img/ML_WED_78910/7.1.1.png" alt="逻辑回归问题中的过拟合直观表现"></p><h4 id="解决过拟合的方法"><a href="#解决过拟合的方法" class="headerlink" title="解决过拟合的方法"></a>解决过拟合的方法</h4><ul><li>减少特征数量<ul><li>人工选择用于训练的特征  </li><li>模型选择算法，自动选择保留的特征</li></ul></li><li>正则化(Regularization)<ul><li>保留所有特征向量，减少量级</li><li>在有许多特征时表现良好，每一个特征都对预测结果产生一定影响</li></ul></li></ul><h2 id="8-2-正则化与损失函数"><a href="#8-2-正则化与损失函数" class="headerlink" title="8.2 正则化与损失函数"></a>8.2 正则化与损失函数</h2><h3 id="正则化直观理解"><a href="#正则化直观理解" class="headerlink" title="正则化直观理解"></a>正则化直观理解</h3><p><img src="/img/ML_WED_78910/7.2.1.png" alt="正则化直观理解"><br>参数值较小意味着更简单的参数模型，通过对$\theta_3$和$\theta_4$添加惩罚项，让他们接近0,得到一个更简单的模型，接近于二次函数</p><ul><li>更简单的假设</li><li>更不容易过拟合</li></ul><p><img src="/img/ML_WED_78910/7.2.2.png" alt="正则化"><br>在损失函数中添加正则化项，控制在两个目标之间的取舍</p><ul><li>第一项控制模型训练拟合</li><li>第二项使参数尽可能小</li><li>$\lambda$:正则化参数，控制两项之间的平衡关系</li></ul><h2 id="8-3-8-4-带正则化项的回归和分类"><a href="#8-3-8-4-带正则化项的回归和分类" class="headerlink" title="8.3-8.4 带正则化项的回归和分类"></a>8.3-8.4 带正则化项的回归和分类</h2><p><img src="/img/ML_WED_78910/7.3.1.png" alt="带正则化项的回归与分类的损失函数及梯度下降"></p><hr><h2 id="9-神经网络"><a href="#9-神经网络" class="headerlink" title="9 神经网络"></a>9 神经网络</h2><blockquote><p>神经网络被证明在学习复杂的非线性假设上是一种好得多的算法</p></blockquote><p>背景：</p><ul><li>起源：尝试设计模拟人类大脑的算法</li><li>80-90年代得到广泛应用，90s之后流行度降低</li><li>近年由于计算机算力的提升重新复苏</li></ul><h4 id="逻辑单元"><a href="#逻辑单元" class="headerlink" title="逻辑单元"></a>逻辑单元</h4><p><img src="/img/ML_WED_78910/8.1.1.png" alt="神经元"><br>下图表示一个简单的神经网络，由输入层、隐含层和输出层组成<br><img src="/img/ML_WED_78910/8.1.2.png" alt="神经网络"><br>神经网络的计算过程，以$a_1^{(2)}$为例，(2)代表第二层，通过第一层神经元乘以各自到$a_1$的权重并求和，通过激活函数$g$进行激活。<br><img src="/img/ML_WED_78910/8.1.3.png" alt="神经网络计算过程"><br>如下图所示，把$\Theta x$表示为$z$,如$z^{(2)}=\Theta^{(1)}x$，即$z^{(2)}=\Theta^{(1)}a^{(1)}$,可以更简洁地表示前向传播过程<br><img src="/img/ML_WED_78910/8.1.4.png" alt="神经网络前向传播"></p><h2 id="10-1-损失函数"><a href="#10-1-损失函数" class="headerlink" title="10.1 损失函数"></a>10.1 损失函数</h2><p><img src="/img/ML_WED_78910/10.1.1.png" alt="神经网络损失函数"></p><h2 id="10-2-反向传播"><a href="#10-2-反向传播" class="headerlink" title="10.2 反向传播"></a>10.2 反向传播</h2><p><img src="/img/ML_WED_78910/10.2.1.png" alt="正向传播"><br>网络首先进行正向传播计算预测值，然后通过反向传播更新权重</p><p><img src="/img/ML_WED_78910/10.2.2.png" alt="四层神经网络的反向传播"></p><blockquote><p>反向传播从直观上说，首先是对每个结点计算损失$\delta_k^{(l)}$(代表第l层第j个结点的误差)<br>对输出层的单元（layer=4），$\delta_j^{(4)}=a_j^{(4)}-y_j$,或者用向量表达为$\delta^{(4)}=a^{(4)}-y$</p></blockquote><h2 id="10-3-理解反向传播"><a href="#10-3-理解反向传播" class="headerlink" title="10.3 理解反向传播"></a>10.3 理解反向传播</h2><p><img src="/img/ML_WED_78910/10.3.1.png" alt="正向传播的例子"><br><img src="/img/ML_WED_78910/10.3.2.png" alt="反向传播的例子"></p><p><img src="/img/ML_WED_78910/manual.png" alt="反向传播的推导"><br>参考:<br><a href="https://zhuanlan.zhihu.com/p/25416673">https://zhuanlan.zhihu.com/p/25416673</a><br><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap2/c2s4.html">https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap2/c2s4.html</a><br><a href="https://blog.csdn.net/lien0906/article/details/79193103">https://blog.csdn.net/lien0906/article/details/79193103</a> </p><h2 id="10-5-梯度检验"><a href="#10-5-梯度检验" class="headerlink" title="10.5 梯度检验"></a>10.5 梯度检验</h2><blockquote><p>反向传播算法含有许多细节，很容易产生一些细微的bug难以发现，最后误差会比没有误差高出一个量级。<br>解决方法：梯度检验</p></blockquote><ul><li>从数值上求近似导数：计算损失函数在$\theta-\epsilon$和$\theta+\epsilon$的值，其中$\epsilon$取较小的值（如1e-4）</li><li>将$\theta-\epsilon$和$\theta+\epsilon$连起来作为近似斜率</li><li>求近似斜率$\frac{\Delta y}{\Delta x}$</li><li>当近似斜率等于反向传播中得到的斜率，证明反响传播实现是正确的<br><img src="/img/ML_WED_78910/10.5.1.png" alt="扩展到多个参数"><br><img src="/img/ML_WED_78910/10.5.2.png" alt="梯度检验的注意事项"></li></ul><h2 id="10-6-随机初始化"><a href="#10-6-随机初始化" class="headerlink" title="10.6 随机初始化"></a>10.6 随机初始化</h2><p><img src="/img/ML_WED_78910/10.6.1.png" alt="零初始化的问题"><br>常规初始化方法：随机初始化</p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2021/06/12/6.12-6.18/"/>
    <url>/2021/06/12/6.12-6.18/</url>
    
    <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode-cn.com/problems/first-bad-version/">210613_leetcode278_第一个错误的版本</a><br>二分查找的典型应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = n<br>        <span class="hljs-keyword">while</span>(low &lt; high):<br>            mid = (high - low) // <span class="hljs-number">2</span> + low<br>            <span class="hljs-keyword">if</span> isBadVersion(mid):<br>                high = mid<br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> isBadVersion(mid):<br>                low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> low<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">210614_leetcode374_猜数字大小</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># The guess API is already defined for you.</span><br><span class="hljs-comment"># @param num, your guess</span><br><span class="hljs-comment"># @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span><br><span class="hljs-comment"># def guess(num):</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">guessNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        low = <span class="hljs-number">1</span><br>        high = <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> guess(n):<br>                <span class="hljs-keyword">return</span> n<br>            <span class="hljs-keyword">elif</span> guess(n) &lt; <span class="hljs-number">0</span>:<br>                high = n<br>            <span class="hljs-keyword">else</span>:<br>                low = n<br>            n = (high - low) // <span class="hljs-number">2</span> + low<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">210615_leetcode852_山脉数组的峰顶索引</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def peakIndexInMountainArray(self, arr):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> arr: List[<span class="hljs-keyword">int</span>]<br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        n = <span class="hljs-built_in">len</span>(arr)<br>        <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span> = <span class="hljs-number">1</span>, n - <span class="hljs-number">2</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">left</span> &lt; righ<span class="hljs-variable">t:</span><br>            mid = (<span class="hljs-keyword">right</span> -<span class="hljs-keyword">left</span>) // <span class="hljs-number">2</span> + <span class="hljs-keyword">left</span><br>            <span class="hljs-keyword">if</span> (arr[mid]-arr[mid-<span class="hljs-number">1</span>])*(arr[mid+<span class="hljs-number">1</span>]-arr[mid]) &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> mid<br>            elif arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">right</span> = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">left</span> = mid + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周代码(6.5-6.11)</title>
    <link href="/2021/06/05/6.5-6.11/"/>
    <url>/2021/06/05/6.5-6.11/</url>
    
    <content type="html"><![CDATA[<h3 id="每周的代码"><a href="#每周的代码" class="headerlink" title="每周的代码"></a>每周的代码</h3><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">leetcode_13：罗马数字转整数</a><br>思路：</p><ol><li>罗马数字与整数数值存在映射关系，适合用哈希表构造，python用字典来实现。</li><li>观察罗马数字特点，从左到右为递减顺序，只有特殊情况下左边字母小于右边，根据该特点分类计算。<br>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">romanToInt</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        roman = &#123;  <span class="hljs-comment"># 罗马数值哈希表</span><br>            <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>            <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>            <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>            <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>            <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span><br>        &#125;<br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 如果存在递增说明适用特殊规则</span><br>            <span class="hljs-keyword">if</span> i&lt;<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> roman[s[i]]&lt;roman[s[i+<span class="hljs-number">1</span>]]:  <br>                result += -roman[s[i]]<br>            <span class="hljs-keyword">else</span>:<br>                result += roman[s[i]]<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">leetcode_14：最小公共前缀</a><br>思路：<br>题目比较简单，直接依次遍历字符串，更新最长公共前缀即可，尝试用二分查找来写<br>代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def longestCommonPrefix(self, strs):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> str<span class="hljs-variable">s:</span> List[str]<br>        :rtype: str<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        def if_same(str_list, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">all</span>(str_list[<span class="hljs-number">0</span>][lef<span class="hljs-variable">t:right</span>]==str_list[i][lef<span class="hljs-variable">t:right</span>] <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str_list)))<br>        <span class="hljs-keyword">if</span> not str<span class="hljs-variable">s:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">right</span> = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">for</span> s in strs)<br>        <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">left</span> &lt; righ<span class="hljs-variable">t:</span><br>            # mid = (<span class="hljs-keyword">left</span>+<span class="hljs-keyword">right</span>) // <span class="hljs-number">2</span><br>            mid = (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span> + <span class="hljs-number">1</span>) // <span class="hljs-number">2</span> + <span class="hljs-keyword">left</span><br>            <span class="hljs-keyword">if</span> if_same(strs, <span class="hljs-keyword">left</span>, mid):<br>                <span class="hljs-keyword">left</span> = mid<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">right</span> = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][:<span class="hljs-keyword">left</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>选mid的时候写成(left+right)//2会溢出，写成(right - left + 1) // 2 + left可以解决这个问题<br>all函数很方便：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">def <span class="hljs-keyword">all</span>(iterable):<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterable:  # 判断给定的可迭代参数 iterable 中的所有元素是否都为 <span class="hljs-literal">TRUE</span>，如果是返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span>。<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> element:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">leetcode_20：有效的括号</a><br>思路：<br>主要注意必须以正确的顺序闭合，s = “([)]”是不行的，所以对第一个右括号，上一个必须是正确的左括号。如果正确就把两个括号pop之后继续判断。因此用堆栈实现最合适。<br>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        pairs = &#123;<br>            <span class="hljs-string">&quot;)&quot;</span>:<span class="hljs-string">&quot;(&quot;</span>,<br>            <span class="hljs-string">&quot;]&quot;</span>:<span class="hljs-string">&quot;[&quot;</span>,<br>            <span class="hljs-string">&quot;&#125;&quot;</span>:<span class="hljs-string">&quot;&#123;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> pairs:  <span class="hljs-comment"># key</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> pairs[ch]!=stack[-<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">else</span>:<br>                    stack.pop()<br>            <span class="hljs-keyword">else</span>:<br>                stack.append(ch)<br>        <span class="hljs-keyword">return</span> stack == []<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-strstr/">leetcode_28：实现strStr()</a><br>思路：<br>字符串匹配问题，首先用暴力搜索试试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> haystack[i:i+<span class="hljs-built_in">len</span>(needle)] == needle:<br>                    <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以提交，但是复杂度太高，再学习了一下用滚动哈希来写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> haystack <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(haystack) &lt; <span class="hljs-built_in">len</span>(needle):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> needle:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        hash_val = <span class="hljs-number">0</span><br>        target = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(needle):<br>                hash_val = hash_val * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>                target = target * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(needle[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">else</span>:<br>                hash_val = (<br>                    hash_val - (<span class="hljs-built_in">ord</span>(haystack[i - <span class="hljs-built_in">len</span>(needle)]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)) * <span class="hljs-number">26</span> ** (<span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span>)<br>                ) * <span class="hljs-number">26</span> + (<span class="hljs-built_in">ord</span>(haystack[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(needle) - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> hash_val == target:<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-built_in">len</span>(needle) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> hash_val == target <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/">leetcode_67：二进制求和</a><br>思路：这道题很容易想到用模拟的方法来写，再学习了一下用位运算的方法来写，是一种很不错的思路。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">def</span> <span class="hljs-symbol">addBinary</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span></span>):<br>        &quot;&quot;&quot;<br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">a: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">type</span> <span class="hljs-symbol">b: <span class="hljs-symbol">str</span></span><br>        :<span class="hljs-symbol">rtype: <span class="hljs-symbol">str</span></span><br>        &quot;&quot;&quot;<br>        <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">int</span>(<span class="hljs-symbol">a, <span class="hljs-symbol">2</span></span>), <span class="hljs-symbol">int</span>(<span class="hljs-symbol">b, <span class="hljs-symbol">2</span></span>)<br>        <span class="hljs-symbol">while</span> <span class="hljs-symbol">y:</span><br>            <span class="hljs-symbol">answer</span> = <span class="hljs-symbol">x</span> ^ <span class="hljs-symbol">y</span><br>            <span class="hljs-symbol">carry</span> = (<span class="hljs-symbol">x</span> &amp; <span class="hljs-symbol">y</span>) &lt;&lt; <span class="hljs-symbol">1</span><br>            <span class="hljs-symbol">x, <span class="hljs-symbol">y</span></span> = <span class="hljs-symbol">answer, <span class="hljs-symbol">carry</span></span><br>        <span class="hljs-symbol">return</span> <span class="hljs-symbol">bin</span>(<span class="hljs-symbol">x</span>)[<span class="hljs-symbol">2:</span>]<br></code></pre></td></tr></table></figure><p>记录：<br>整体的思路就是先计算无进位的结果，然后通过按位与来模拟进位，通过左移一位来对其，最右边补零，所以结果不受影响。<br>位运算符：<br>&amp;按位与 |按位或 ^按位异或 ～按位取反 &lt;&lt;左移动运算符 &gt;&gt;右移动运算符</p><p>截图：<br><img src="/img/6.11_code_sub/13.png" alt="13"><br><img src="/img/6.11_code_sub/14.png" alt="14"><br><img src="/img/6.11_code_sub/20.png" alt="20"><br><img src="/img/6.11_code_sub/28.png" alt="28"><br><img src="/img/6.11_code_sub/67.png" alt="67"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>吴恩达-机器学习-1-3章笔记</title>
    <link href="/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/"/>
    <url>/2021/06/05/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01-3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-1-2-什么是机器学习"><a href="#1-1-1-2-什么是机器学习" class="headerlink" title="1.1-1.2 什么是机器学习"></a>1.1-1.2 什么是机器学习</h2><h4 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h4><pre><code>-Grew out of work in AI-New capability for computers</code></pre><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code>-Database mining    Large datasets from growth of automation/web-Applications cant&#39;t program by hand.    NLP,CV,Autonomous helocopter..-Self-customizing programs(私人定制程序)-Understaning human learning(brain, real AI)</code></pre><h4 id="What-is-ML-definitions"><a href="#What-is-ML-definitions" class="headerlink" title="What is ML?(definitions)"></a>What is ML?(definitions)</h4><pre><code>-Field of study that gives computers the ability to learn without being explicitly programmed.(1959)-A computer program is said to learning from experience E with respect to some task T and some performanc e measure P, if its performance on T, as measured by P, improves with experience E(1998).(通过P测定在T上的表现因经验E而提高)</code></pre><h4 id="Example-邮件分类"><a href="#Example-邮件分类" class="headerlink" title="Example: 邮件分类"></a>Example: 邮件分类</h4><p>T:classifying emails<br>E:label emails<br>P:the fraction of emails correctly classified</p><h4 id="ML-algorithms"><a href="#ML-algorithms" class="headerlink" title="ML algorithms:"></a>ML algorithms:</h4><p><strong>supervised learning, unsupervised learning</strong>, reinforcement learning, recommender systems</p><h2 id="1-3-1-4-监督学习和无监督学习"><a href="#1-3-1-4-监督学习和无监督学习" class="headerlink" title="1.3-1.4 监督学习和无监督学习"></a>1.3-1.4 监督学习和无监督学习</h2><h4 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h4><p><strong>“right answers” given</strong></p><h4 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h4><p><strong>same labels or no labels</strong><br>E.g. 同一主题的新闻显示在一起（聚类），特定基因的表达程度（不同的个体归入不同的类）。。。</p><h4 id="cocktail-party-problem"><a href="#cocktail-party-problem" class="headerlink" title="cocktail party problem:"></a>cocktail party problem:</h4><p>当前语音识别技术已经可以以较高精度识别一个人所讲的话，但是当说话的人数为两人或者多人时，语音识别率就会极大的降低，这一难题被称为鸡尾酒会问题。<br>将两个声音分离出来。</p><h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression:"></a>Regression:</h4><p>Predict continuous valued output</p><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification:"></a>Classification:</h4><p>Discrete valued output(0/1)</p><h2 id="2-1-线性回归模型描述"><a href="#2-1-线性回归模型描述" class="headerlink" title="2.1 线性回归模型描述"></a>2.1 线性回归模型描述</h2><p>x-&gt;h(hypothesis)-&gt;y ,i.e. h maps x’s to y’s<br>how do we prepresent h?</p><p>$$h_\theta = \theta_0 + \theta_1x$$</p><p>(单变量)线性回归，y是关于x的线性函数<br><img src="/img/ML_WED_123/2.1.1.png" alt="参数表示"></p><h2 id="2-2-2-4-代价函数"><a href="#2-2-2-4-代价函数" class="headerlink" title="2.2-2.4 代价函数"></a>2.2-2.4 代价函数</h2><p><img src="/img/ML_WED_123/2.2.1.png" alt="损失函数"><br>θ‘s : parameters -&gt; how to choose?<br>Idea: choose θs so that h(x) is close to y for training examles -&gt; minimize <strong>h(x)-y</strong><br>损失函数(cost function)：<br>$$J(\theta_0, \theta_1)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})y^{(i)})^2$$<br><strong>Minimize J</strong><br><strong>找到能使训练集中预测值和真实值的差的平方和最小的θ0和θ1</strong></p><p><img src="/img/ML_WED_123/2.2.2.png" alt="h(x)和J(θ)"><br>对θ的每一个取值，对应左边一条直线，和右边一个点</p><p><img src="/img/ML_WED_123/2.2.3.png" alt="总结"><br><img src="/img/ML_WED_123/2.2.4.png" alt="增加一个参数的损失函数示意图"></p><h2 id="2-5-2-6-梯度下降算法"><a href="#2-5-2-6-梯度下降算法" class="headerlink" title="2.5-2.6 梯度下降算法"></a>2.5-2.6 梯度下降算法</h2><p>梯度下降算法：最小化损失函数J<br><img src="/img/ML_WED_123/2.3.1.png" alt="Problem Setup"></p><p>-把损失函数想像成一座山，每次从下山最快的方向走一小步 -&gt; 收敛至局部最低点<br>-从不同的地方开始下山可能会得到不同的结果<br><img src="/img/ML_WED_123/2.3.2.png" alt="梯度下降算法以及通常是同步更新"><br><img src="/img/ML_WED_123/2.3.3.png" alt="直观理解偏导数项的意义"><br>alpha代表学习率（步长），偏导数代表斜率，决定了更新的方向和速度<br><img src="/img/ML_WED_123/2.3.4.png" alt="选择合适的学习率"><br><img src="/img/ML_WED_123/2.3.5.png" alt="学习率不变也可以收敛到局部最小"><br>接近局部最小点的时候，学习率也会自动变小</p><h2 id="3-线性代数基础"><a href="#3-线性代数基础" class="headerlink" title="3 线性代数基础"></a>3 线性代数基础</h2><p>矩阵(matrix)：<br>$$A=\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 4 \<br>5 &amp; 6 &amp; 7 &amp; 8 \<br>9 &amp; 10 &amp; 11 &amp; 12 \<br>\end{bmatrix}$$<br>$A_{ij}$表示第i行第j列，如$A_{22}$: 6<br>（因为还没有解决用hexo搭博客的时候多行公式的渲染问题，所以矩阵显示有点问题）<br>(latex公式里面可以用\cdots\vdots\ddots在矩阵里画省略号)</p><p>向量(vector): nx1的矩阵</p><p>矩阵加法：对应元素相加，只有相同形状的矩阵可以相加<br>矩阵和标量(scalar)的乘法：矩阵每一个元素都进行相应计算<br>矩阵之间的乘法：左行乘右列，得到的矩阵尺寸为左矩阵行数和右矩阵列数<br><img src="/img/ML_WED_123/3.1.1.png" alt="矩阵乘向量"><br><img src="/img/ML_WED_123/3.1.2.png" alt="用矩阵乘法来简化代码"><br>直接通过左行乘右列，所以每一列就是每一个假设函数得到的预测值，非常简便</p><p>其他特性：<br>1.矩阵乘法不服从交换律<br>2.矩阵乘法<strong>服从</strong>结合律<br>3.单位矩阵，表示为$I$或者$I_{n \times n}$，表示对角线上都是1,其余为0，对任意矩阵A，$AI=IA=A$</p><p><strong>逆矩阵</strong><br>如果矩阵A是$m \times m$的矩阵，并且有逆矩阵，那么：$AA^{-1}=A^{-1}A=I$<br>方阵，且行列式不为零才有逆矩阵<br>没有逆矩阵的矩阵可以想象成非常近似于零，称为<strong>奇异矩阵(singular)</strong></p><p>转置矩阵：<br><img src="/img/ML_WED_123/3.1.2.png" alt="转置矩阵"></p>]]></content>
    
    
    <categories>
      
      <category>周记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>周记</tag>
      
      <tag>吴恩达</tag>
      
      <tag>笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用网站记录</title>
    <link href="/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
    <url>/2021/05/15/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><p><a href="https://onedrive.live.com/">onedrive</a><br><a href="https://www.zhihu.com/">知乎</a></p><h2 id="医学图像的网站"><a href="#医学图像的网站" class="headerlink" title="医学图像的网站"></a>医学图像的网站</h2><p><a href="https://www.cancerimagingarchive.net/">TCIA数据集</a><br><a href="http://www.via.cornell.edu/lidc/">LIDC Size Report</a><br><a href="https://wiki.cancerimagingarchive.net/display/Public/LIDC-IDRI">LIDC-IDRI</a><br><a href="https://pylidc.github.io/">Pylidc</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://leetcode-cn.com/">leetcode</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的官方网站</a></p><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图</a><br><a href="https://www.gnome-look.org/browse/cat/">Gnome-look</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/">清华大学开源镜像</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.myhuiban.com/">会伴</a><br><a href="https://www.overleaf.com/">overleaf</a><br><a href="https://sockboom.art/">sockboom</a><br><a href="https://hexo.fluid-dev.com/docs/">fluid文档</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三维CT切片方法、Python代码实现</title>
    <link href="/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E4%B8%89%E7%BB%B4CT%E5%88%87%E7%89%87%E6%96%B9%E6%B3%95%E3%80%81Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><a href="https://www.researchgate.net/publication/328774789_A_Lightweight_Multi-Section_CNN_for_Lung_Nodule_Classification_and_Malignancy_Estimation">A Lightweight Multi-Section CNN for Lung Nodule Classification and Malignancy Estimation</a><br><a href="https://github.com/PranjalSahu/MultiSectionCNN">源码</a></p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="np-meshgrid"><a href="#np-meshgrid" class="headerlink" title="np.meshgrid"></a>np.meshgrid</h3><p>numpy.meshgrid()——生成网格点坐标矩阵。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">image_size = <span class="hljs-number">5</span><br>(yy, zz) = np<span class="hljs-selector-class">.meshgrid</span>(range(image_size), range(image_size))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;yy=&#x27;</span>, yy)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;zz=&#x27;</span>, zz)</span></span><br><br>plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;x axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;y axis&#x27;</span>)<br>plt<span class="hljs-selector-class">.plot</span>(yy, zz, marker=<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;none&#x27;</span>)<br>plt<span class="hljs-selector-class">.grid</span>()<br>plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">yy= [[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]<br> [0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4]]<br>zz= [[0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0]<br> [1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1]<br> [2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2]<br> [3<span class="hljs-number"> 3 </span>3<span class="hljs-number"> 3 </span>3]<br> [4<span class="hljs-number"> 4 </span>4<span class="hljs-number"> 4 </span>4]]<br></code></pre></td></tr></table></figure><h3 id="scipy-ndimage-map-coordinates"><a href="#scipy-ndimage-map-coordinates" class="headerlink" title="scipy.ndimage.map_coordinates"></a>scipy.ndimage.map_coordinates</h3><p>文档：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>    # 将输入数组通过插值映射到新的坐标。<br>    Map the <span class="hljs-built_in">input</span> array <span class="hljs-keyword">to</span> <span class="hljs-keyword">new</span> coordinates by interpolation.<br>    # 坐标数组用来寻找输出里每一个点在输入中对应的坐标，这些位置输入的坐标值通过设定的阶数的插值得出。<br>    The array of coordinates <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">find</span>, <span class="hljs-keyword">for</span> each point in the output,<br>    the corresponding coordinates in the <span class="hljs-built_in">input</span>. The value of the <span class="hljs-built_in">input</span> at<br>    those coordinates <span class="hljs-keyword">is</span> determined by spline interpolation of the<br>    requested order.<br>    #<br>    The shape of the output <span class="hljs-keyword">is</span> derived from that of the coordinate<br>    array by dropping the <span class="hljs-keyword">first</span> axis. The <span class="hljs-built_in">values</span> of the array along<br>    the <span class="hljs-keyword">first</span> axis are the coordinates in the <span class="hljs-built_in">input</span> array at which the<br>    output value <span class="hljs-keyword">is</span> found.<br><br>    Parameters<br>    ----------<br>    %(<span class="hljs-built_in">input</span>)s<br>    coordinates : array_like<br>        The coordinates at which `<span class="hljs-built_in">input</span>` <span class="hljs-keyword">is</span> evaluated.<br>    %(output)s<br>    order : <span class="hljs-keyword">int</span>, optional<br>        The order of the spline interpolation, default <span class="hljs-keyword">is</span> <span class="hljs-number">3</span>.<br>        The order <span class="hljs-built_in">has</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> in the <span class="hljs-built_in">range</span> <span class="hljs-number">0</span>-<span class="hljs-number">5</span>.<br>    %(<span class="hljs-keyword">mode</span>)s<br>    %(cval)s<br>    %(prefilter)s<br><br>    Returns<br>    -------<br>    map_coordinates : ndarray<br>        The result of transforming the <span class="hljs-built_in">input</span>. The shape of the output <span class="hljs-keyword">is</span><br>        derived from that of `coordinates` by dropping the <span class="hljs-keyword">first</span> axis.<br><br>    See Also<br>    --------<br>    spline_filter, geometric_transform, scipy.interpolate<br><br>    Examples<br>    --------<br>    &gt;&gt;&gt; from scipy import ndimage<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span> = np.arange(<span class="hljs-number">12</span>.).reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>    &gt;&gt;&gt; <span class="hljs-keyword">a</span><br>    array([[  <span class="hljs-number">0</span>.,   <span class="hljs-number">1</span>.,   <span class="hljs-number">2</span>.],<br>           [  <span class="hljs-number">3</span>.,   <span class="hljs-number">4</span>.,   <span class="hljs-number">5</span>.],<br>           [  <span class="hljs-number">6</span>.,   <span class="hljs-number">7</span>.,   <span class="hljs-number">8</span>.],<br>           [  <span class="hljs-number">9</span>.,  <span class="hljs-number">10</span>.,  <span class="hljs-number">11</span>.]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, [[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>]], order=<span class="hljs-number">1</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">7</span>.])<br><br>    Above, the interpolated value of <span class="hljs-keyword">a</span>[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>] gives output[<span class="hljs-number">0</span>], <span class="hljs-keyword">while</span><br>    <span class="hljs-keyword">a</span>[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">is</span> output[<span class="hljs-number">1</span>].<br><br>    &gt;&gt;&gt; inds = np.array([[<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>]])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=-<span class="hljs-number">33.3</span>)<br>    array([  <span class="hljs-number">2</span>. , -<span class="hljs-number">33.3</span>])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, <span class="hljs-keyword">mode</span>=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br>    array([ <span class="hljs-number">2</span>.,  <span class="hljs-number">8</span>.])<br>    &gt;&gt;&gt; ndimage.map_coordinates(<span class="hljs-keyword">a</span>, inds, order=<span class="hljs-number">1</span>, cval=<span class="hljs-number">0</span>, output=bool)<br>    array([ True, False], dtype=bool)<br><br>    <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/home/joe/MyBlog/themes/fluid/source/img/meshgrid.png"> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lllxxq141592654/article/details/81532855">meshgrid</a></p>]]></content>
    
    
    <categories>
      
      <category>医学图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索</title>
    <link href="/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/"/>
    <url>/2021/04/15/%E7%AE%97%E6%B3%95(5)%EF%BC%9A%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="DFS（Deep-First-Search）深度优先搜索"><a href="#DFS（Deep-First-Search）深度优先搜索" class="headerlink" title="DFS（Deep First Search）深度优先搜索"></a>DFS（Deep First Search）深度优先搜索</h2><p>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。</p><h3 id="树的深度优先搜索"><a href="#树的深度优先搜索" class="headerlink" title="树的深度优先搜索"></a>树的深度优先搜索</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h2 id="BFS（Breadth-First-Search）广度优先搜索"><a href="#BFS（Breadth-First-Search）广度优先搜索" class="headerlink" title="BFS（Breadth First Search）广度优先搜索"></a>BFS（Breadth First Search）广度优先搜索</h2><p>###树的广度优先搜索</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def BFS(root):<br>    if not root:<br>        return<br>    queue = [root]<br>    while queue:<br>        <span class="hljs-literal">current</span> = queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            queue.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><h3 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h3><p>（leetcode 111题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = [root]<br>        minDep = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.left <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.right:<br>                    <span class="hljs-keyword">return</span> minDep<br>                <span class="hljs-keyword">if</span> node.left:<br>                    level.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    level.append(node.right)<br>            queue = level<br>            minDep += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/04/14/%E7%AE%97%E6%B3%95(4)%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>分治：最优子结构<br>动规：最优子结构、重叠子问题<br>贪心：最优子结构、重叠子问题、贪心选择性质</p><p>分治：为了解决一个问题，把它分解成若干个与此问题相似的子问题。<br>这样的“能分解”的性质就叫做最优子结构（又称无后效性）。很多问题都可以满足这个性质。</p><p>动态规划：动态规划是分治的特例。采用分治思想得到的子问题“不一定需要再次求解”，因为之前可能已经计算过相同的子问题了。这样的性质叫做重叠子问题。</p><p>贪心：贪心比动态规划更特殊，它还需要问题满足另一个性质——贪心选择性质。每次都可以把原问题分解为一个子问题。<br>动态规划是一种特殊的分治，而贪心是一种特殊的动态规划。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>递归形式：改分治。先进行判断。如果这个子问题已经处理过，那就直接把数组里储存了的值输出；否则就“计算结果”，最后储存答案。<br>递推形式：找出一种可行的拓扑序列。<br>两者在时间复杂度上没什么区别，而递归形式代码一般比较容易实现。具体区别请见：为什么线性动态规划类问题通常使用递推求解子问题，而不使用记忆化递归。<br>事实上动态规划最关键的是上文提到的“计算结果”，即列一个数学方程，这个方程被称为状态转移方程。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>**第一步骤：定义数组元素的含义<br>第二步骤：找出数组元素之间的关系式<br>第三步骤：找出初始值<br>**</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>（leetcode70题）经典爬楼梯：<br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n  <span class="hljs-comment"># 定义数组</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>  <span class="hljs-comment"># 定义初始状态</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]  <span class="hljs-comment"># 状态转移</span><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>（leetcode746题）最小代价爬楼梯：<br>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。<br>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。<br>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        prev = <span class="hljs-number">0</span> <br>        cur = <span class="hljs-number">0</span>   <span class="hljs-comment"># 把dp[i]设为第i阶为天台</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(cost)+<span class="hljs-number">1</span>):<br>            prev, cur = cur, <span class="hljs-built_in">min</span>(prev+cost[i-<span class="hljs-number">2</span>], cur+cost[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><h3 id="子串、子序列、子数组"><a href="#子串、子序列、子数组" class="headerlink" title="子串、子序列、子数组"></a>子串、子序列、子数组</h3><p>最大子段和（leetcode53题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>]+nums[i], nums[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>最长公共子序列（leetcode1143题）：<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1, text2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type text1: str</span><br><span class="hljs-string">        :type text2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意顺序</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] <br></code></pre></td></tr></table></figure><p>最长重复子数组（leetcode718题）：<br>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLength</span>(<span class="hljs-params">self, nums1, nums2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        dp = [[<span class="hljs-number">0</span>] * (<span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>)]<br>        maxr = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums1[i-<span class="hljs-number">1</span>] == nums2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                    maxr = <span class="hljs-built_in">max</span>(maxr, dp[i][j])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> maxr<br></code></pre></td></tr></table></figure><h3 id="丑数II"><a href="#丑数II" class="headerlink" title="丑数II"></a>丑数II</h3><p>（leetcode264题）<br>给你一个整数 n ，请你找出并返回第 n 个 丑数 。<br>丑数 就是只包含质因数 2、3 和/或 5 的正整数。<br>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">class Solution(object):<br>    def nthUglyNumber(self, n):<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        :<span class="hljs-built_in">type</span> n: <span class="hljs-keyword">int</span><br>        :rtype: <span class="hljs-keyword">int</span><br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">&quot;</span><br>        p2 = p3 =p5 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>] * n<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">min</span>(<span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>, <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>, <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p2]*<span class="hljs-number">2</span>:<br>                p2 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p3]*<span class="hljs-number">3</span>:<br>                p3 += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] == <span class="hljs-keyword">dp</span>[p5]*<span class="hljs-number">5</span>:<br>                p5 += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">dp</span>[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h3><p>I. (leetcode198题)<br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>II. (leetcode 213题)<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">robRange</span>(<span class="hljs-params">nums</span>):</span><br>            dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>            dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>]+nums[i])<br>            <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(robRange(nums[:-<span class="hljs-number">1</span>]), robRange(nums[<span class="hljs-number">1</span>:]))  <span class="hljs-comment"># 先分解为两个单排问题</span><br><br></code></pre></td></tr></table></figure><p>III. </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/topic/19660018/hot">动态规划概念</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念和算法</title>
    <link href="/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/13/%E7%AE%97%E6%B3%95(3)%EF%BC%9A%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/tree.jpg" alt=" " title="二叉树"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>满二叉树</strong>：顾名思义<br><strong>完全二叉树</strong>：满二叉树从最后一个结点开始删除</p><p><strong>二叉搜索树</strong>（二叉查找树）：二叉搜索树中，左子树都比其根节点小，右子树都比其根节点大，递归定义。<br>    二叉搜索树中序遍历从小到大排序<br>正常情况下时间复杂度： O(logn)<br>最差：O(n)<br>避免最差情况：使用<strong>平衡二叉树</strong>（AVL）</p><p><strong>平衡二叉树</strong>：平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于 1，并且子树也必须是一棵平衡二叉树。<strong>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)</strong><br><strong>平衡因子</strong>：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。（左减右）<br><strong>最小失衡子树</strong>：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。<br>平衡二叉树的失衡调整主要是通过<strong>旋转</strong>最小失衡子树来实现的。根据旋转的方向有两种处理方式，**左旋 **与 <strong>右旋</strong> 。旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><p>节点的<strong>度</strong>就是这个节点的孩子数量，例如有左右孩子的节点，它的度为2，如果只有左孩子或者只有右孩子的节点，它的度就是1，叶节点就是度为0的节点</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树结点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = x<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>树的建立：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">if</span> <span class="hljs-type">__name</span><span class="hljs-type">__</span> <span class="hljs-operator">==</span> <span class="hljs-string">&quot;__main__&quot;</span><span class="hljs-operator">:</span><br>    <span class="hljs-built_in">D</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">D</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">E</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">E</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">F</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">F</span><span class="hljs-operator">&#x27;</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-built_in">C</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-built_in">C</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">None</span><span class="hljs-operator">,</span> <span class="hljs-variable">F</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">B</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-variable">TreeNode</span><span class="hljs-punctuation">(</span><span class="hljs-operator">&#x27;</span><span class="hljs-variable">A</span><span class="hljs-operator">&#x27;,</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><br>    <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-variable">A</span><br></code></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root</span>):</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable">root</span>:</span><br><span class="hljs-function">        <span class="hljs-variable">return</span></span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-variable">root.val</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.left</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">preorder</span>(<span class="hljs-variable">root.right</span>)</span><br></code></pre></td></tr></table></figure><p>深度优先：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nsis">def DFS(root):<br>    if not root:<br>        return<br>    stack = [root]<br><br>    while stack:<br>        <span class="hljs-literal">current</span> = stack.pop()<br>        <span class="hljs-literal">print</span>(<span class="hljs-literal">current</span>.val)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">left</span>)<br>        if <span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>:<br>            stack.append(<span class="hljs-literal">current</span>.<span class="hljs-literal">right</span>)<br></code></pre></td></tr></table></figure><p>广度优先（leetcode101题）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vim"># Definition <span class="hljs-keyword">for</span> <span class="hljs-keyword">a</span> binary tree node.<br># class TreeNode(object):<br>#     def __init__(self, val=<span class="hljs-number">0</span>, <span class="hljs-keyword">left</span>=None, <span class="hljs-keyword">right</span>=None):<br>#         self.val = val<br>#         self.<span class="hljs-keyword">left</span> = <span class="hljs-keyword">left</span><br>#         self.<span class="hljs-keyword">right</span> = <span class="hljs-keyword">right</span><br>class Solution(object):<br>    def levelOrder(self, root):<br>        <span class="hljs-keyword">res</span> = []<br>        <span class="hljs-keyword">if</span> not roo<span class="hljs-variable">t:</span><br>            <span class="hljs-keyword">return</span> []<br>        queue = [root]<br><br>        <span class="hljs-keyword">while</span> queue:<br>            level = []<br>            <span class="hljs-keyword">for</span> _ in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                level.<span class="hljs-keyword">append</span>(queue[<span class="hljs-number">0</span>].val)<br>                current = queue.<span class="hljs-keyword">pop</span>(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> current.lef<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">left</span>)<br>                <span class="hljs-keyword">if</span> current.righ<span class="hljs-variable">t:</span><br>                    queue.<span class="hljs-keyword">append</span>(current.<span class="hljs-keyword">right</span>)<br>            <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(level)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>数组中第K个最大元素（leecode215题）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_heap</span>(<span class="hljs-params">i, nums, length</span>):</span>  <span class="hljs-comment"># 构建最大堆</span><br>            left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左子树</span><br>            right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右子树</span><br>            max_index = i  <span class="hljs-comment"># 最大结点下标</span><br>            <span class="hljs-keyword">if</span> left &lt; length <span class="hljs-keyword">and</span> nums[i] &lt; nums[left]:<br>                max_index = left<br>            <span class="hljs-keyword">if</span> right &lt; length <span class="hljs-keyword">and</span> nums[max_index] &lt; nums[right]:<br>                max_index = right<br>            <span class="hljs-keyword">if</span> max_index != i:<br>                nums[i], nums[max_index] = nums[max_index], nums[i]<br>                build_heap(max_index, nums, length)  <span class="hljs-comment"># 如果经过了调换，对调换的子结点继续构建堆</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            build_heap(i, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            nums[<span class="hljs-number">0</span>], nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>] = nums[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]<br>            result = nums.pop()<br>            build_heap(<span class="hljs-number">0</span>, nums, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://zhuanlan.zhihu.com/p/106828968">基本概念</a><br><a href="https://zhuanlan.zhihu.com/p/56066942">平衡二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/12/%E7%AE%97%E6%B3%95(2)%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">bubble_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 外层冒泡轮数</span><br>        for <span class="hljs-keyword">j </span>in range(length<span class="hljs-number">-1</span>-i):  <span class="hljs-comment"># 里层依次比较，最大（最小）沉底</span><br>            if arr[<span class="hljs-keyword">j] </span>&gt; arr[<span class="hljs-keyword">j+1]:</span><br><span class="hljs-keyword"> </span>               arr[<span class="hljs-keyword">j], </span>arr[<span class="hljs-keyword">j+1] </span>= arr[<span class="hljs-keyword">j+1], </span>arr[<span class="hljs-keyword">j]</span><br><span class="hljs-keyword"> </span>   return arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):  <span class="hljs-comment"># 循环轮数</span><br>        <span class="hljs-built_in">min</span> = arr[i]<br>        mini = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, length):<br>            <span class="hljs-keyword">if</span> arr[j] &lt; <span class="hljs-built_in">min</span>:<br>                <span class="hljs-built_in">min</span> = arr[j]<br>                mini = j<br>        arr[i], arr[mini] = arr[mini], arr[i]  <span class="hljs-comment"># 将最小的数和第i个数交换</span><br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>嵌套循环，时间复杂度为<strong>O(n2)。</strong></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>python实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def <span class="hljs-keyword">insertion_sort(arr):</span><br><span class="hljs-keyword"> </span>   length = len(arr)<br>    for i in range(length):  <span class="hljs-comment"># 循环轮数</span><br>        value = arr[i]<br>        <span class="hljs-keyword">j </span>= i<br>        while <span class="hljs-keyword">j </span>&gt; <span class="hljs-number">0</span>:<br>            if value &lt; arr[<span class="hljs-keyword">j-1]: </span> <span class="hljs-comment">#每次将第i个数插入有序数组中正确位置</span><br>                arr[<span class="hljs-keyword">j] </span>= arr[<span class="hljs-keyword">j-1]</span><br><span class="hljs-keyword"> </span>               <span class="hljs-keyword">j </span>-= <span class="hljs-number">1</span><br><span class="hljs-symbol">            else:</span><br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword"> </span>       arr[<span class="hljs-keyword">j] </span>= value<br>    return arr<br></code></pre></td></tr></table></figure><p>插入排序实现方法类比扑克牌摸牌。<br>时间复杂度为<strong>O(n2)。</strong></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shells_sort</span>(<span class="hljs-params">arr</span>):</span><br>    length = <span class="hljs-built_in">len</span>(arr)<br>    gap = <span class="hljs-built_in">int</span>(length/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">while</span> gap &gt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, length):  <span class="hljs-comment"># 从第二个数开始选择插入</span><br>            value = arr[i]<br>            j = i<br>            <span class="hljs-keyword">while</span> j - gap &gt;= <span class="hljs-number">0</span>:  <span class="hljs-comment"># 前面还有数</span><br>                <span class="hljs-keyword">if</span> value &lt; arr[j-gap]:<br>                    arr[j] = arr[j-gap]  <span class="hljs-comment"># 当前数更小，则前移</span><br>                    j -= gap<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 否则为正确位置，插入</span><br>            arr[j] = value<br>        <span class="hljs-keyword">if</span> gap == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        gap = <span class="hljs-built_in">int</span>(gap/<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> arr<br></code></pre></td></tr></table></figure><p>希尔排序也称作“缩小增量排序”，<strong>是插入排序的一种更高效的改进版本。</strong><br>根据增量进行跳跃的插入排序，然后缩小增量，最后进行增量为1的插入排序。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>python实现：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> merge(arr<span class="hljs-number">1</span>, arr<span class="hljs-number">2</span>):  # 治<br>    <span class="hljs-attribute">arr</span> =<span class="hljs-meta"> []</span><br>    <span class="hljs-attribute">node1</span>, node<span class="hljs-number">2</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-attribute">while</span> node<span class="hljs-number">1</span> &lt; len(arr<span class="hljs-number">1</span>) and node<span class="hljs-number">2</span> &lt; len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">if</span> arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>] &lt; arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>]:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>])<br>            <span class="hljs-attribute">node1</span> += <span class="hljs-number">1</span><br>        <span class="hljs-attribute">else</span>:<br>            <span class="hljs-attribute">arr</span>.append(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>])<br>            <span class="hljs-attribute">node2</span> += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">1</span> == len(arr<span class="hljs-number">1</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">2</span>[node<span class="hljs-number">2</span>:])<br>    <span class="hljs-attribute">if</span> node<span class="hljs-number">2</span> == len(arr<span class="hljs-number">2</span>):<br>        <span class="hljs-attribute">arr</span>.extend(arr<span class="hljs-number">1</span>[node<span class="hljs-number">1</span>:])<br>    <span class="hljs-attribute">return</span> arr<br><br><br><span class="hljs-attribute">def</span> merge_sort(arr):  # 分<br>    <span class="hljs-attribute">length</span> = len(arr)<br>    <span class="hljs-attribute">if</span> length == <span class="hljs-number">1</span>:<br>        <span class="hljs-attribute">return</span> arr<br><br>    <span class="hljs-attribute">left</span> = merge_sort(arr[:int(length/<span class="hljs-number">2</span>)])<br>    <span class="hljs-attribute">right</span> = merge_sort(arr[int(length/<span class="hljs-number">2</span>):])<br>    <span class="hljs-attribute">return</span> merge(left, right)<br></code></pre></td></tr></table></figure><p>分治法（Divide and Conquer）的一个非常典型的应用</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>python实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql">def quick_sort(arr):<br>    length <span class="hljs-operator">=</span> len(arr)<br>    if length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>]  # 取基准元素<br>    <span class="hljs-keyword">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  # 左指针<br>    <span class="hljs-keyword">right</span> <span class="hljs-operator">=</span> length<span class="hljs-number">-1</span>  # 右指针<br>    ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span>  # 左右指针交替移动，先从右指针移动<br>    while <span class="hljs-keyword">left</span> <span class="hljs-operator">!=</span> <span class="hljs-keyword">right</span>:<br>        if ifright:<br>            if arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">right</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            if arr[<span class="hljs-keyword">left</span>] <span class="hljs-operator">&lt;</span> <span class="hljs-keyword">value</span>:<br>                <span class="hljs-keyword">left</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                arr[<span class="hljs-keyword">right</span>] <span class="hljs-operator">=</span> arr[<span class="hljs-keyword">left</span>]<br>                ifright <span class="hljs-operator">=</span> <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">right</span> <span class="hljs-operator">-</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> quick_sort(arr[:<span class="hljs-keyword">left</span>])<span class="hljs-operator">+</span>[<span class="hljs-keyword">value</span>]<span class="hljs-operator">+</span>quick_sort(arr[(<span class="hljs-keyword">left</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>):])<br></code></pre></td></tr></table></figure><p>快速排序的思想：<br>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）<br>2.将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置<br>3.对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>):<br>    left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>  <span class="hljs-comment"># 左叶子</span><br>    <span class="hljs-literal">right</span> = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>  <span class="hljs-comment"># 右叶子</span><br>    max_index = i  <span class="hljs-comment"># 最大元素下标</span><br>    <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[left] &gt;= nums[i]:<br>        max_index = left<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">right</span> &lt; <span class="hljs-built_in">length</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-literal">right</span>] &gt; nums[max_index]:<br>        max_index = <span class="hljs-literal">right</span><br>    <span class="hljs-keyword">if</span> max_index != i:  <span class="hljs-comment"># 如果需要交换，先进行交换，然后对交换后的叶子构建堆</span><br>        nums[i], nums[max_index] = nums[max_index], nums[i]<br>        bulid_big_heap(nums, max_index, <span class="hljs-built_in">length</span>)<br><br>def heap_sort(nums):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(nums)<br>    sorted = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span><span class="hljs-comment"> // 2 - 1, -1, -1):  # 从最后一个非叶子结点开始构建堆</span><br>        bulid_big_heap(nums, i, <span class="hljs-built_in">length</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):  <span class="hljs-comment"># 输出堆顶元素</span><br>        nums[<span class="hljs-number">0</span>], nums[j] = nums[j], nums[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 与最后一个元素交换</span><br>        sorted.insert(<span class="hljs-number">0</span>, nums.pop())  <span class="hljs-comment"># 输出</span><br>        bulid_big_heap(nums, <span class="hljs-number">0</span>, j)  <span class="hljs-comment"># 从堆顶开始重新构建堆</span><br>    <span class="hljs-literal">return</span> sorted<br></code></pre></td></tr></table></figure><p>堆排序的过程梳理：</p><ol><li>把数组构建成完全二叉树</li><li>从最后一个非叶子结点开始构建堆</li><li>输出堆顶元素，重建构建成堆</li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def count_sort(arr):<br>    <span class="hljs-built_in">length</span> = <span class="hljs-built_in">len</span>(arr)<br>    max_num = arr[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>):<br>        max_num = <span class="hljs-built_in">max</span>(max_num, arr[i])<br>    count_arr = [<span class="hljs-number">0</span>] * (max_num+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>):<br>        count_arr[arr[i]] += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">result</span> = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">length</span>+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">while</span> count_arr[i] &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">result</span>.append(i)<br>            count_arr[i] -= <span class="hljs-number">1</span><br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p>计数排序思路：找出最大值; 计数; 取出<br>适合取值范围相差不大的数组</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect">十大排序算法</a><br><a href="https://zhuanlan.zhihu.com/p/63202860">快速排序</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础</title>
    <link href="/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/11/%E7%AE%97%E6%B3%95(1)%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。<br>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</p><p>严谨的进行算法的时间复杂度：「 大O符号表示法 」，即 T(n) = O(f(n))。<br>其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。<br><strong>一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。</strong></p><p>O(1): 无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)<br>O(n): for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。<br>O(n²) : 当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>O(logn): 在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。<br>O(nlogn): 将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。</p><h2 id="基本算法思想"><a href="#基本算法思想" class="headerlink" title="基本算法思想"></a>基本算法思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p><strong>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</strong><br>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归算法是一种直接或者间接调用自身函数或者方法的算法。<br>1.找到如何将大问题分解为小问题的规律<br>2.通过规律写出递推公式<br>3.通过递归公式的临界点推敲出终止条件<br>4.将递推公式和终止条件翻译成代码</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。<br>步骤：<br>定义数组元素的含义;<br>找出数组元素之间的关系式;<br>找出初始值。</p><h3 id="动态规划和递归的区别"><a href="#动态规划和递归的区别" class="headerlink" title="动态规划和递归的区别"></a>动态规划和递归的区别</h3><p>用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。<br>1.动态规划法试图只解决每个子问题一次<br>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。<br>爬台阶（递归）自顶向下:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>) return <span class="hljs-number">2</span>;<br>  return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>爬台阶（动态规划）自底向上：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>int f(<span class="hljs-type">int</span> n) &#123;<br> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> <span class="hljs-number">3</span>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br> <span class="hljs-number">4</span>    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， <span class="hljs-keyword">temp</span> 保存当前状态的数据<br> <span class="hljs-number">5</span>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br> <span class="hljs-number">6</span>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">7</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br> <span class="hljs-number">8</span>        <span class="hljs-keyword">temp</span> = a + b;<br> <span class="hljs-number">9</span>        a = b;<br><span class="hljs-number">10</span>        b = <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">11</span>    &#125;<br><span class="hljs-number">12</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>; <br><span class="hljs-number">13</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治算法，根据字面意思解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/23148377/answer/907915556">程序员必须掌握哪些算法</a><br><a href="https://www.cxyxiaowu.com/852.html">贪心算法</a><br><a href="https://zhuanlan.zhihu.com/p/91582909">告别动态规划，连刷 40 道题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485228&idx=1&sn=9f48aee51dcb2b98b56b1827cc658439&chksm=fa0e68adcd79e1bbcd0183ef30a79ede4e46c5835ce05ee6644169c3cc9454073019ccd85d3d&scene=21#wechat_redirect">分治算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动调参工具optuna</title>
    <link href="/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/"/>
    <url>/2021/04/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7(1)%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E5%8F%82%E5%B7%A5%E5%85%B7optuna/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/optuna/optuna">optuna</a>是一个为机器学习设计的自动超参数优化软件框架。它有一个命令式的、按运行方式定义的用户API，用Optuna编写的代码具有很高的模块化，Optuna的用户可以动态地为超参数构建搜索空间。</p><h2 id="optuna基本概念"><a href="#optuna基本概念" class="headerlink" title="optuna基本概念"></a>optuna基本概念</h2><p>study：根据目标函数的优化Session,由一系列的trial组成。<br>trial：根据目标函数作出一次执行。<br><strong>study的学习目标就是根据多次trial得到的结果发现其中最优的超参数。</strong></p><h2 id="optuna常用搜索方式"><a href="#optuna常用搜索方式" class="headerlink" title="optuna常用搜索方式"></a>optuna常用搜索方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 选择型搜索方式【从MomentumSGD和Adam二者中选】</span><br>trail.suggest_categorical(<span class="hljs-string">&#x27;optimizer&#x27;</span>,[<span class="hljs-string">&#x27;MomentumSGD&#x27;</span>,<span class="hljs-string">&#x27;Adam&#x27;</span>])<br><span class="hljs-comment"># 整型搜索方式【从1～3范围内的int选择】</span><br>trail.suggest_int(<span class="hljs-string">&#x27;num_layers&#x27;</span>,1,3)<br><span class="hljs-comment"># 浮点型搜索方式【从0.0～1.0范围内float选择】</span><br>trial.suggest_float(<span class="hljs-string">&#x27;momentum&#x27;</span>, 0.0, 1.0)<br><span class="hljs-comment"># 连续均匀采样搜索方式 【从0～1.0之间的浮点数进行均匀采样】</span><br>trail.suggest_uniform(<span class="hljs-string">&#x27;dropout_rate&#x27;</span>,0.0,1.0)<br><span class="hljs-comment"># 对数均匀采样方式 【从log(1e-5)~log(1e-2)均匀分布中采样结果再取e的自然指数】</span><br>trail.suggest_loguniform(<span class="hljs-string">&#x27;learning_rate,1e-5,1e-2&#x27;</span>)<br><span class="hljs-comment"># 离散均匀采样方式 【以0.1为步长拆分0～1后的离散均匀分布中采样】</span><br>**trail.suggest_discrete_uniform(<span class="hljs-string">&#x27;drop_path_rate&#x27;</span>,0.0,1.0,0.1)<br></code></pre></td></tr></table></figure><p>具体可以查看一下<a href="https://github.com/optuna/optuna/blob/master/optuna/trial/_trial.py">文档</a></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先导入包，重设随机种子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import optuna<br><span class="hljs-function"><span class="hljs-title">reset_rand</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>定义目标函数，返回需要最大化（最小化）的目标</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def objective(trial):<br>    def model_opt():<br>        lr = trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;lr&#x27;</span>, 1e-3, 1e-2, 1e-3)<br>        model = network()<br>        optimizer = Adam(model.parameters(), lr)<br>        return model, optimizer<br><br>    acc = kFoldTraining(wd,<br>                        int(trial.suggest_discrete_uniform(<span class="hljs-string">&#x27;batch_size&#x27;</span>, 32, 256, 32)),<br>                        epoch,<br>                        <span class="hljs-attribute">model_optimizer</span>=model_opt,<br>                        <span class="hljs-attribute">loss</span>=nn.CrossEntropyLoss(),<br>                        <span class="hljs-attribute">device</span>=<span class="hljs-string">&#x27;cuda:0&#x27;</span>,<br>                        <span class="hljs-attribute">deterministic</span>=<span class="hljs-literal">True</span>,<br>                        <span class="hljs-attribute">parallel</span>=<span class="hljs-literal">False</span><br>                        )<br>    return acc<br></code></pre></td></tr></table></figure><p>最后在主函数中调用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>study = optuna.create_study(<span class="hljs-attribute">direction</span>=<span class="hljs-string">&quot;maximize&quot;</span>, <span class="hljs-attribute">pruner</span>=optuna.pruners.HyperbandPruner())<br>study.optimize(objective, <span class="hljs-attribute">n_trials</span>=50)  # 调参的次数 <br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Number of finished trials: &quot;</span>, len(study.trials))<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;Best trial:&quot;</span>)<br>trial = study.best_trial<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Value: &quot;</span>, trial.value)<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;  Params: &quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.params.items():<br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.format(key, value))<br>df = study.trials_dataframe(attrs=(<span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;params&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>))<br>df.to_csv(keys[<span class="hljs-string">&#x27;result&#x27;</span>] + <span class="hljs-string">&#x27;/dataframe.csv&#x27;</span>, <span class="hljs-attribute">index</span>=<span class="hljs-literal">False</span>)<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/384519338/answer/1206812752">有没有什么可以节省大量时间的 Deep Learning 效率神器？</a><br><a href="https://zhuanlan.zhihu.com/p/259993570">Optuna — 超参自动化调整利器 学习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建过程记录</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(2)%EF%BC%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录简单的个人博客搭建过程。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install git-core<br></code></pre></td></tr></table></figure><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh<br></code></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvm install stable<br></code></pre></td></tr></table></figure><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>建立博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p>文件夹名称可以自己随意取，这三句命令的作用是初始化 Hexo </p><p>再次输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>作用是生成静态文件，然后输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>作用是启动服务器。这时候就可以用浏览器打开网址： <a href="http://localhost:4000/">http://localhost:4000/</a> 来进行预览了。</p><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p>注册帐号，创建repo等操作就省略了，具体可参考其他博客（比如参考里面的）</p><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>如果已有public-key可以先删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add -D<br>$ rm -r ~/.ssh<br></code></pre></td></tr></table></figure><p>生成一个github用的SSH-Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@your.com” -f ~/.ssh/github-rsa</span><br></code></pre></td></tr></table></figure><p>添加私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-add ~/.ssh/id_rsa $ ssh-add ~/.ssh/github_rsa<br><span class="hljs-comment"># 可以通过 ssh-add -l 来确私钥列表</span><br>$ ssh-add -l<br><span class="hljs-comment"># 可以通过 ssh-add -D 来清空私钥列表</span><br>$ ssh-add -D<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 ~/.ssh 目录下新建一个config文件</span><br>$ touch config<br></code></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github</span><br>Host github.com<br>    HostName github.com<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/github_rsa<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>输出You’ve successfully authenticated, but GitHub does not provide shell access.就表示成功的连上github了</p><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br><span class="hljs-comment"># 本地预览</span><br>$ hexo s<br>$ hexo d<br></code></pre></td></tr></table></figure><p>如果hexo d之后出现 ERROR Deployer not found: git，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>即可</p><p>上传时报错：incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line at….<br>要把标题里英文冒号改为中文的</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8">hexo fluid配置地址</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/hzq_0111/article/details/78956821">在github上搭建hexo个人博客</a><br><a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程</a><br><a href="https://my.oschina.net/stefanzhlg/blog/529403">git配置多个ssh-key</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04 + Pycharm 配置Pyqt5</title>
    <link href="/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/"/>
    <url>/2021/04/02/%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95(1)%EF%BC%9Aubuntu16.04%20+%20Pycharm%20%E9%85%8D%E7%BD%AEPyqt5/</url>
    
    <content type="html"><![CDATA[<p>安装指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install qt5-default<br>sudo apt-get install qttools5-dev-tools<br>pip install pyqt5 -i https://pypi.douban.com/simple <span class="hljs-comment">#安装pyqt5包</span><br>sudo apt install pyqt5* <span class="hljs-comment">#安装依赖</span><br></code></pre></td></tr></table></figure><p>在Pycharm中进行配置：<br>打开pycharm后点击File - &gt; setting - &gt; Tools - &gt; External Tools, 点击 + 号添加两个文件。<br>（1）第一个是QtDesign用于通过pycharm直接启动QtDesigner，自定义Name（QtDesigner）, Group（Qt5）等参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>bin/designer  <span class="hljs-comment"># 填入Program</span><br><span class="hljs-variable">$FileDir</span>$  <span class="hljs-comment"># 填入Working directory</span><br></code></pre></td></tr></table></figure><p>（2）第二个是将ui文件转换成py文件</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/usr/bin/python3  <span class="hljs-comment"># 填入Program</span><br>-m PyQt5.uic.pyuic  <span class="hljs-variable">$FileName</span><span class="hljs-variable">$ </span>-o <span class="hljs-variable">$FileNameWithoutExtension</span><span class="hljs-variable">$.</span>py  <span class="hljs-comment"># 填入Arguments</span><br><span class="hljs-variable">$FileDir</span><span class="hljs-variable">$ </span> <span class="hljs-comment"># 填入Working direction</span><br></code></pre></td></tr></table></figure><p>将ui文件转换为py文件：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pyuic5 -o <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>py <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lnc</span>.</span></span>ui<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/qq_37541097/article/details/80021315">Ubuntu16.04+pycharm+pyqt5安装与配置</a></p>]]></content>
    
    
    <categories>
      
      <category>配置记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
